# 📋 代码审查规范

## 🎯 审查目标

代码审查是保障代码质量、促进团队学习和知识共享的重要环节。我们的审查规范旨在：

- ✅ **保证代码质量**: 确保代码符合项目标准和最佳实践
- 🧠 **促进知识共享**: 通过审查过程传播技术知识和最佳实践
- 🐛 **早期发现问题**: 在代码合并前发现潜在bug和设计问题
- 🚀 **加速团队成长**: 帮助开发者提升技能和代码意识

## 📊 审查流程

### 1. 提交阶段 (Author)

#### PR准备清单
```bash
# 提交前必须执行的检查
make prepush          # 完整的提交前验证
make test.unit        # 单元测试通过
make test.int         # 集成测试通过
make lint             # 代码检查通过
make coverage         # 覆盖率检查

# 智能修复工具（可选）
python3 scripts/smart_quality_fixer.py
```

#### PR描述要求
- 📝 **清晰的变更描述**: 说明为什么做这个变更
- 🔗 **关联Issue**: 必须关联相关的Issue编号
- 🧪 **测试说明**: 描述如何测试这些变更
- 📸 **截图/演示**: UI变更必须提供截图或演示

#### 代码质量要求
- [ ] **代码风格**: 通过`ruff check`检查
- [ ] **类型注解**: 公共函数必须有完整的类型注解
- [ ] **文档字符串**: 所有公共函数和类有docstring
- [ ] **测试覆盖**: 新功能必须有对应的测试用例

### 2. 审查阶段 (Reviewer)

#### 审查优先级
1. **🚨 紧急审查** (2小时内响应)
   - 生产环境热修复
   - 安全漏洞修复
   - 阻塞性问题修复

2. **⚡ 高优先级** (8小时内响应)
   - 主要功能开发
   - 架构变更
   - 性能优化

3. **📋 普通审查** (24小时内响应)
   - 一般功能改进
   - 文档更新
   - 重构优化

#### 审查步骤

##### 第一步：自动检查 (5分钟)
```bash
# 验证CI状态
# 检查所有自动化检查是否通过
# 确认测试覆盖率和代码质量指标
```

##### 第二步：整体理解 (15分钟)
- 📖 **理解变更目的**: 为什么要做这个变更？
- 🗺️ **查看架构影响**: 这个变更如何影响系统架构？
- 📋 **评估变更范围**: 变更的影响范围有多大？

##### 第三步：详细审查 (30-45分钟)
- 🔍 **逐行代码检查**: 重点关注逻辑正确性和代码质量
- 🧪 **测试审查**: 检查测试覆盖率和测试质量
- 🏗️ **设计审查**: 评估设计模式和架构决策
- 🔒 **安全审查**: 检查安全漏洞和输入验证

##### 第四步：反馈整理 (10分钟)
- ✅ **总结问题**: 按优先级整理发现的问题
- 💡 **提供建议**: 给出具体的改进建议
- 🎯 **确认修复点**: 明确必须修复的问题

### 3. 修改阶段 (Author)

#### 反馈处理
- 🚨 **必须修复**: 功能错误、安全问题、架构问题
- ⚠️ **建议修复**: 代码质量、性能优化、最佳实践
- 💡 **改进建议**: 代码风格、重构建议、学习分享

#### 修改要求
- [ ] **逐一响应**: 对每个审查意见都要回应
- [ ] **彻底修复**: 确保问题得到完整解决
- [ ] **回归测试**: 修复后运行相关测试
- [ ] **更新文档**: 如需要，更新相关文档

## 🔍 审查检查清单

### 🏗️ 架构和设计

#### DDD设计原则
- [ ] **领域模型**: 领域对象设计合理，职责明确
- [ ] **边界上下文**: 模块边界清晰，依赖关系合理
- [ ] **聚合设计**: 聚合根设计正确，不变性保护
- [ ] **领域服务**: 领域服务职责单一，无状态设计

#### CQRS模式
- [ ] **命令查询分离**: 读写操作明确分离
- [ ] **命令设计**: 命令对象设计合理，包含必要信息
- [ ] **查询设计**: 查询对象优化，避免过度获取
- [ ] **事件处理**: 事件处理逻辑正确，幂等性保证

#### 设计模式
- [ ] **策略模式**: 策略接口设计合理，实现可替换
- [ ] **工厂模式**: 工厂类职责单一，创建逻辑清晰
- [ ] **仓储模式**: 仓储接口设计合理，实现高效
- [ ] **依赖注入**: 依赖关系清晰，生命周期管理正确

### 💻 代码质量

#### 基础规范 (Ruff检查)
- [ ] **命名规范**: 变量、函数、类命名清晰有意义
- [ ] **代码风格**: 遵循PEP8和项目代码规范
- [ ] **导入顺序**: 标准库、第三方库、本地导入顺序正确
- [ ] **行长度**: 行长度控制在88字符以内

#### 函数设计
- [ ] **单一职责**: 函数只做一件事，职责明确
- [ ] **参数数量**: 函数参数不超过5个
- [ ] **函数长度**: 函数不超过50行（复杂逻辑除外）
- [ ] **返回值**: 返回值类型一致，错误处理合理

#### 类设计
- [ ] **类职责**: 类职责单一，内聚性高
- [ ] **封装性**: 私有方法使用下划线前缀
- [ ] **继承关系**: 继承关系合理，避免过深继承
- [ ] **组合优于继承**: 优先使用组合而非继承

### 🧪 测试质量

#### 测试覆盖
- [ ] **单元测试**: 核心逻辑100%覆盖
- [ ] **边界测试**: 包含边界条件和异常情况
- [ ] **集成测试**: 重要功能有集成测试
- [ ] **端到端测试**: 关键流程有E2E测试

#### 测试设计
- [ ] **AAA模式**: Arrange, Act, Assert结构清晰
- [ ] **测试命名**: 测试名称清楚描述测试内容
- [ ] **测试独立性**: 测试之间无依赖关系
- [ ] **断言完整**: 断言检查预期结果和边界情况

#### Mock使用
- [ ] **隔离外部依赖**: 正确使用mock隔离外部依赖
- [ ] **Mock配置**: Mock配置合理，行为符合预期
- [ ] **验证交互**: 验证与外部服务的交互
- [ ] **避免过度Mock**: 只mock必要的依赖

### 🔒 安全性

#### 输入验证
- [ ] **参数验证**: 所有输入参数都经过验证
- [ ] **类型检查**: 使用Pydantic进行数据验证
- [ ] **长度限制**: 字符串和数组长度限制
- [ ] **格式验证**: 邮箱、电话等格式验证

#### 权限控制
- [ ] **身份认证**: 用户身份验证机制
- [ ] **权限检查**: 操作权限验证
- [ ] **资源访问**: 资源访问权限控制
- [ ] **API安全**: API端点安全保护

#### 数据安全
- [ ] **敏感信息**: 密码、token等敏感信息不记录日志
- [ ] **SQL注入**: 使用参数化查询防止SQL注入
- [ ] **XSS防护**: 输出时进行HTML转义
- [ ] **加密存储**: 敏感数据加密存储

### ⚡ 性能

#### 算法效率
- [ ] **时间复杂度**: 算法时间复杂度合理
- [ ] **空间复杂度**: 内存使用效率良好
- [ ] **循环优化**: 避免嵌套循环和不必要的循环
- [ ] **递归优化**: 递归深度控制，避免栈溢出

#### 数据库优化
- [ ] **查询优化**: 避免N+1查询问题
- [ ] **索引使用**: 合理使用数据库索引
- [ ] **连接池**: 数据库连接正确管理
- [ ] **事务管理**: 事务范围合理，避免长事务

#### 缓存策略
- [ ] **缓存设计**: 合理使用缓存提升性能
- [ ] **缓存失效**: 缓存失效策略正确
- [ ] **缓存一致性**: 缓存与数据库一致性保证
- [ ] **缓存穿透**: 防止缓存穿透攻击

### 🛠️ 工程实践

#### 错误处理
- [ ] **异常捕获**: 异常捕获范围合理
- [ ] **错误日志**: 错误日志包含足够的上下文信息
- [ ] **用户友好**: 向用户显示友好的错误信息
- [ ] **错误恢复**: 提供错误恢复机制

#### 配置管理
- [ ] **环境变量**: 配置通过环境变量管理
- [ ] **默认值**: 配置有合理的默认值
- [ ] **配置验证**: 启动时验证配置完整性
- [ ] **敏感配置**: 敏感配置加密存储

#### 日志记录
- [ ] **结构化日志**: 使用结构化日志格式
- [ ] **日志级别**: 正确使用日志级别
- [ ] **关键操作**: 关键操作有日志记录
- [ ] **性能日志**: 性能敏感操作有耗时日志

## 📝 审查反馈模板

### 🚨 问题反馈 (必须修复)

```markdown
#### 🚨 必须修复: [问题类型]

**位置**: `文件路径:行号-行号`
**问题描述**: 清晰描述发现的问题
**影响说明**: 解释为什么这是个问题以及可能的影响
**建议方案**: 提供具体的修复建议
**代码示例**:
```python
# 提供修复后的代码示例
def fixed_function():
    # 修复后的实现
    pass
```
**优先级**: 🔴 高 | 🟡 中 | 🟢 低
```

### ⚠️ 改进建议 (建议修复)

```markdown
#### 💡 改进建议: [改进类型]

**位置**: `文件路径:行号`
**当前实现**: 描述当前的实现方式
**改进建议**: 提供改进的具体建议
**收益说明**: 说明改进后的好处
**实现难度**: 🟢 简单 | 🟡 中等 | 🔴 复杂
```

### 👍 正面反馈

```markdown
#### 👍 做得很好: [具体方面]

**位置**: `文件路径:行号`
**优点描述**: 具体说明做得好的地方
**学习价值**: 可以从中学到什么
**最佳实践**: 体现了哪个最佳实践
```

## 🎯 审查重点领域

### API设计审查

#### RESTful设计
- [ ] **HTTP方法**: GET/POST/PUT/DELETE使用正确
- [ ] **资源命名**: 资源命名清晰且一致
- [ ] **状态码**: HTTP状态码使用正确
- [ ] **响应格式**: API响应格式统一

#### API文档
- [ ] **OpenAPI规范**: 符合OpenAPI 3.0规范
- [ ] **参数说明**: 请求参数和响应字段说明完整
- [ ] **示例代码**: 提供完整的使用示例
- [ ] **错误码**: 错误码和错误信息说明清晰

#### API安全
- [ ] **认证机制**: API认证机制设计合理
- [ ] **限流控制**: API限流和熔断机制
- [ ] **输入验证**: API输入参数验证完整
- [ ] **输出过滤**: 敏感信息过滤处理

### 数据库审查

#### 模型设计
- [ ] **表结构**: 表结构设计合理，范式正确
- [ ] **字段类型**: 字段类型选择合适
- [ ] **索引设计**: 索引设计合理，覆盖查询需求
- [ ] **约束条件**: 主键、外键、唯一约束正确

#### 查询优化
- [ ] **查询效率**: 查询语句高效，避免全表扫描
- [ ] **JOIN优化**: JOIN操作优化，避免笛卡尔积
- [ ] **分页查询**: 大数据量分页查询优化
- [ ] **事务处理**: 事务处理合理，避免死锁

#### 数据迁移
- [ ] **迁移脚本**: 迁移脚本安全，可回滚
- [ ] **数据验证**: 迁移后数据完整性验证
- [ ] **性能影响**: 迁移对生产环境影响评估
- [ ] **回滚方案**: 提供完整的回滚方案

### 前端审查 (如适用)

#### 组件设计
- [ ] **组件职责**: 组件职责单一，可复用
- [ ] **状态管理**: 状态管理合理，避免冗余
- [ ] **属性传递**: Props传递清晰，避免过度传递
- [ ] **事件处理**: 事件处理逻辑正确

#### 用户体验
- [ ] **响应式设计**: 适配不同屏幕尺寸
- [ ] **加载状态**: 提供加载状态反馈
- [ ] **错误处理**: 友好的错误提示
- [ ] **交互反馈**: 及时的用户操作反馈

#### 性能优化
- [ ] **代码分割**: 合理的代码分割策略
- [ ] **资源优化**: 图片、字体等资源优化
- [ ] **缓存策略**: 浏览器缓存策略合理
- [ ] **首屏加载**: 首屏加载时间优化

## 📊 审查质量指标

### 及时性指标
- 🎯 **响应时间**: PR提交后24小时内首次审查
- ⚡ **紧急响应**: 紧急PR 2小时内响应
- 🔄 **审查轮次**: 平均审查轮次 < 3轮
- ✅ **完成时间**: 从提交到合并平均 < 3天

### 质量指标
- 🐛 **缺陷发现率**: 审查发现的bug占比 > 70%
- 🧪 **测试覆盖率**: 新功能测试覆盖率 > 80%
- 📋 **检查清单完整度**: 审查检查清单完成度 > 90%
- 📚 **文档完整性**: API文档和代码注释完整度 > 85%

### 学习成长指标
- 💡 **知识分享**: 每次审查都有学习收获
- 🎓 **技能提升**: 团队整体代码质量持续提升
- 🤝 **参与率**: 团队成员审查参与率 > 90%
- 📈 **改进建议**: 建设性改进建议占比 > 60%

## 🔄 持续改进

### 定期回顾
- **每周**: 审查质量快速回顾
- **每月**: 审查流程优化讨论
- **每季度**: 审查规范更新和培训

### 工具优化
- **自动化工具**: 集成更多自动化审查工具
- **效率工具**: 开发提升审查效率的工具
- **质量监控**: 建立审查质量监控面板

### 知识库建设
- **最佳实践**: 持续更新最佳实践文档
- **案例库**: 建立审查案例库供学习参考
- **培训材料**: 定期更新审查培训材料

## 📞 获取帮助

### 审查过程中的问题
1. **不确定的标准**: 查阅本规范文档或咨询技术负责人
2. **复杂设计问题**: 在团队技术讨论群讨论
3. **工具使用问题**: 查看工具文档或请教有经验的同事
4. **时间冲突**: 及时沟通，寻找其他审查者

### 学习资源
- 📚 **项目文档**: `CLAUDE.md`, `CONTRIBUTING.md`
- 🎯 **最佳实践**: 项目最佳实践文档
- 🔧 **工具指南**: 开发工具使用指南
- 💬 **团队讨论**: 技术讨论频道历史记录

---

## 📋 附录

### A. 快速检查清单

#### 5分钟快速检查
- [ ] CI检查是否全部通过？
- [ ] PR描述是否清晰完整？
- [ ] 是否有关联的Issue？
- [ ] 代码风格是否符合规范？
- [ ] 是否有足够的测试覆盖？

#### 15分钟详细检查
- [ ] 业务逻辑是否正确？
- [ ] 是否有潜在的安全问题？
- [ ] 性能是否有影响？
- [ ] 错误处理是否完善？
- [ ] 文档是否需要更新？

### B. 常见问题

#### Q: 如何处理审查意见不一致的情况？
A: 优先听取有相关经验的开发者的意见，如有争议可引入第三方审查者或技术负责人决策。

#### Q: 审查时间不够怎么办？
A: 优先检查关键部分（安全性、核心逻辑、测试），可以分多次审查，但要及时沟通进度。

#### Q: 如何提高审查效率？
A: 使用自动化工具辅助，建立审查检查清单，积累审查经验，专注于重要问题。

---

**记住**: 代码审查是团队学习和成长的机会，不仅是质量控制手段！🚀

*文档版本: v1.0 | 最后更新: 2025-11-03*
