#!/usr/bin/env python3
"""
Batch-Δ-021: 赔率收集器全面测试 (Phase 5.3.1)

目标文件: src/data/collectors/odds_collector.py
当前覆盖率: 9% (127/144 行未覆盖)
目标覆盖率: ≥70%
测试重点: 数据获取、异常处理、API集成
"""

import pytest
import asyncio
import json
from unittest.mock import Mock, patch, AsyncMock, MagicMock
from datetime import datetime, timedelta
from typing import Dict, Any, List
from decimal import Decimal

# 预导入所有重量级依赖
modules_to_mock = {
    'pandas': Mock(),
    'numpy': Mock(),
    'requests': Mock(),
    'aiohttp': Mock(),
    'asyncio': Mock()
}

with patch.dict('sys.modules', modules_to_mock):
    from src.data.collectors.odds_collector import OddsCollector
    from src.data.collectors.base_collector import CollectionResult


class TestOddsCollector:
    """赔率收集器全面测试"""

    def setup_method(self):
        """每个测试方法前的设置"""
        self.collector = OddsCollector(
            data_source="test_odds_api",
            api_key="test_key",
            base_url="https://test.api.com"
        )

    def test_collector_initialization(self):
        """测试收集器初始化"""
        print("🧪 测试收集器初始化...")

        # 测试默认初始化
        collector = OddsCollector()
        assert collector.data_source == "odds_api"
        assert collector.api_key is None
        assert collector.base_url == "https://api.the-odds-api.com/v4"
        assert collector.time_window_minutes == 5
        assert isinstance(collector._recent_odds_keys, set)
        assert isinstance(collector._last_odds_values, dict)

        # 测试自定义配置初始化
        custom_collector = OddsCollector(
            data_source="custom_api",
            api_key="test_key",
            base_url="https://custom.api.com",
            time_window_minutes=10
        )
        assert custom_collector.data_source == "custom_api"
        assert custom_collector.api_key == "test_key"
        assert custom_collector.base_url == "https://custom.api.com"
        assert custom_collector.time_window_minutes == 10

        print("✅ 收集器初始化测试通过")

    @pytest.mark.asyncio
    async def test_collect_fixtures_skipped(self):
        """测试collect_fixtures方法（跳过）"""
        print("🧪 测试collect_fixtures方法...")

        result = await self.collector.collect_fixtures()

        assert isinstance(result, CollectionResult)
        assert result.data_source == "test_odds_api"
        assert result.collection_type == "fixtures"
        assert result.records_collected == 0
        assert result.success_count == 0
        assert result.error_count == 0
        assert result.status == "skipped"

        print("✅ collect_fixtures方法测试通过")

    @pytest.mark.asyncio
    async def test_collect_live_scores_skipped(self):
        """测试collect_live_scores方法（跳过）"""
        print("🧪 测试collect_live_scores方法...")

        result = await self.collector.collect_live_scores()

        assert isinstance(result, CollectionResult)
        assert result.data_source == "test_odds_api"
        assert result.collection_type == "live_scores"
        assert result.records_collected == 0
        assert result.success_count == 0
        assert result.error_count == 0
        assert result.status == "skipped"

        print("✅ collect_live_scores方法测试通过")

    @pytest.mark.asyncio
    async def test_collect_odds_success(self):
        """测试成功收集赔率数据"""
        print("🧪 测试赔率数据收集...")

        # Mock依赖方法
        mock_match_odds = [
            {
                "match_id": "1",
                "bookmaker": "bet365",
                "market_type": "h2h",
                "outcomes": [
                    {"name": "Arsenal", "price": 2.10},
                    {"name": "Draw", "price": 3.20},
                    {"name": "Chelsea", "price": 3.50}
                ],
                "last_update": "2023-01-01T12:00:00Z"
            }
        ]

        with patch.object(self.collector, '_get_active_bookmakers', return_value=["bet365"]):
            with patch.object(self.collector, '_get_upcoming_matches', return_value=["1"]):
                with patch.object(self.collector, '_clean_expired_odds_cache'):
                    with patch.object(self.collector, '_collect_match_odds', return_value=mock_match_odds):
                        with patch.object(self.collector, '_has_odds_changed', return_value=True):
                            with patch.object(self.collector, '_clean_odds_data', return_value=mock_match_odds[0]):
                                with patch.object(self.collector, '_save_to_bronze_layer'):
                                    result = await self.collector.collect_odds()

                                    assert result.success is True
                                    assert result.records_collected == 1
                                    assert result.success_count == 1
                                    assert result.error_count == 0
                                    assert result.status == "success"
                                    assert len(result.collected_data) == 1

        print("✅ 赔率数据收集测试通过")

    @pytest.mark.asyncio
    async def test_collect_odds_with_errors(self):
        """测试收集赔率数据时的错误处理"""
        print("🧪 测试收集赔率数据错误处理...")

        # Mock API错误
        with patch.object(self.collector, '_get_active_bookmakers', side_effect=Exception("API Error")):
            result = await self.collector.collect_odds()

            assert result.success is False
            assert result.status == "failed"
            assert result.error_count == 1
            assert "API Error" in result.error_message

        print("✅ 收集赔率数据错误处理测试通过")

    @pytest.mark.asyncio
    async def test_get_active_bookmakers(self):
        """测试获取活跃博彩公司"""
        print("🧪 测试获取活跃博彩公司...")

        bookmakers = await self.collector._get_active_bookmakers()

        assert isinstance(bookmakers, list)
        assert len(bookmakers) > 0
        assert "bet365" in bookmakers
        assert "pinnacle" in bookmakers

        print("✅ 获取活跃博彩公司测试通过")

    @pytest.mark.asyncio
    async def test_get_active_bookmakers_error(self):
        """测试获取活跃博彩公司错误处理"""
        print("🧪 测试获取活跃博彩公司错误处理...")

        # 模拟异常
        with patch.object(self.collector, '_get_active_bookmakers', side_effect=Exception("Database error")):
            bookmakers = await self.collector._get_active_bookmakers()

            # 应该返回默认博彩公司
            assert isinstance(bookmakers, list)
            assert len(bookmakers) == 2
            assert "bet365" in bookmakers
            assert "pinnacle" in bookmakers

        print("✅ 获取活跃博彩公司错误处理测试通过")

    @pytest.mark.asyncio
    async def test_get_upcoming_matches(self):
        """测试获取即将开始的比赛"""
        print("🧪 测试获取即将开始的比赛...")

        matches = await self.collector._get_upcoming_matches()

        assert isinstance(matches, list)
        # 目前返回空列表作为占位符

        print("✅ 获取即将开始的比赛测试通过")

    @pytest.mark.asyncio
    async def test_clean_expired_odds_cache(self):
        """测试清理过期赔率缓存"""
        print("🧪 测试清理过期赔率缓存...")

        # 目前只是占位符实现，应该不抛出异常
        await self.collector._clean_expired_odds_cache()

        print("✅ 清理过期赔率缓存测试通过")

    @pytest.mark.asyncio
    async def test_collect_match_odds(self):
        """测试采集指定比赛的赔率数据"""
        print("🧪 测试采集指定比赛的赔率数据...")

        mock_response = [
            {
                "id": "1",
                "bookmakers": [
                    {
                        "key": "bet365",
                        "markets": [
                            {
                                "key": "h2h",
                                "outcomes": [
                                    {"name": "Arsenal", "price": 2.10},
                                    {"name": "Chelsea", "price": 3.50}
                                ],
                                "last_update": "2023-01-01T12:00:00Z"
                            }
                        ]
                    }
                ]
            }
        ]

        with patch.object(self.collector, '_make_request', return_value=mock_response):
            result = await self.collector._collect_match_odds("1", ["bet365"], ["h2h"])

            assert isinstance(result, list)
            assert len(result) == 1
            assert result[0]["match_id"] == "1"
            assert result[0]["bookmaker"] == "bet365"
            assert result[0]["market_type"] == "h2h"
            assert len(result[0]["outcomes"]) == 2

        print("✅ 采集指定比赛的赔率数据测试通过")

    @pytest.mark.asyncio
    async def test_collect_match_odds_error(self):
        """测试采集指定比赛赔率数据的错误处理"""
        print("🧪 测试采集指定比赛赔率数据错误处理...")

        with patch.object(self.collector, '_make_request', side_effect=Exception("API Error")):
            result = await self.collector._collect_match_odds("1", ["bet365"], ["h2h"])

            assert result == []  # 出错时返回空列表

        print("✅ 采集指定比赛赔率数据错误处理测试通过")

    def test_generate_odds_key(self):
        """测试生成赔率唯一键"""
        print("🧪 测试生成赔率唯一键...")

        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h"
        }

        key = self.collector._generate_odds_key(odds_data)

        assert isinstance(key, str)
        assert len(key) == 32  # MD5哈希长度

        # 相同数据应该生成相同的键
        key2 = self.collector._generate_odds_key(odds_data)
        assert key == key2

        print("✅ 生成赔率唯一键测试通过")

    @pytest.mark.asyncio
    async def test_has_odds_changed_true(self):
        """测试赔率变化检测（有变化）"""
        print("🧪 测试赔率变化检测（有变化）...")

        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 2.15},  # 赔率变化
                {"name": "Chelsea", "price": 3.50}
            ]
        }

        # 设置上次记录的赔率值
        odds_id = "1:bet365:h2h"
        self.collector._last_odds_values[odds_id] = {
            "Arsenal": Decimal("2.10"),
            "Chelsea": Decimal("3.50")
        }

        has_changed = await self.collector._has_odds_changed(odds_data)
        assert has_changed is True

        print("✅ 赔率变化检测（有变化）测试通过")

    @pytest.mark.asyncio
    async def test_has_odds_changed_false(self):
        """测试赔率变化检测（无变化）"""
        print("🧪 测试赔率变化检测（无变化）...")

        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 2.10},
                {"name": "Chelsea", "price": 3.50}
            ]
        }

        # 设置上次记录的赔率值
        odds_id = "1:bet365:h2h"
        self.collector._last_odds_values[odds_id] = {
            "Arsenal": Decimal("2.10"),
            "Chelsea": Decimal("3.50")
        }

        has_changed = await self.collector._has_odds_changed(odds_data)
        assert has_changed is False

        print("✅ 赔率变化检测（无变化）测试通过")

    @pytest.mark.asyncio
    async def test_has_odds_changed_first_time(self):
        """测试首次赔率变化检测"""
        print("🧪 测试首次赔率变化检测...")

        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 2.10},
                {"name": "Chelsea", "price": 3.50}
            ]
        }

        # 确保没有上次记录
        self.collector._last_odds_values.clear()

        has_changed = await self.collector._has_odds_changed(odds_data)
        assert has_changed is True  # 首次记录应该返回True

        print("✅ 首次赔率变化检测测试通过")

    @pytest.mark.asyncio
    async def test_clean_odds_data_success(self):
        """测试清洗赔率数据（成功）"""
        print("🧪 测试清洗赔率数据...")

        raw_odds = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 2.10},
                {"name": "Draw", "price": 3.20},
                {"name": "Chelsea", "price": 3.50}
            ],
            "last_update": "2023-01-01T12:00:00Z"
        }

        cleaned = await self.collector._clean_odds_data(raw_odds)

        assert cleaned is not None
        assert cleaned["external_match_id"] == "1"
        assert cleaned["bookmaker"] == "bet365"
        assert cleaned["market_type"] == "h2h"
        assert len(cleaned["outcomes"]) == 3
        assert cleaned["processed"] is False
        assert "collected_at" in cleaned

        print("✅ 清洗赔率数据测试通过")

    @pytest.mark.asyncio
    async def test_clean_odds_data_invalid(self):
        """测试清洗无效赔率数据"""
        print("🧪 测试清洗无效赔率数据...")

        # 缺少必要字段
        invalid_odds = {
            "match_id": "1",
            "bookmaker": "bet365"
            # 缺少market_type和outcomes
        }

        cleaned = await self.collector._clean_odds_data(invalid_odds)
        assert cleaned is None

        # 无效赔率值
        invalid_price_odds = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 0.5}  # 赔率小于1
            ]
        }

        cleaned = await self.collector._clean_odds_data(invalid_price_odds)
        assert cleaned is None

        print("✅ 清洗无效赔率数据测试通过")

    @pytest.mark.asyncio
    async def test_collect_odds_partial_success(self):
        """测试部分成功的赔率收集"""
        print("🧪 测试部分成功的赔率收集...")

        # Mock一些成功一些失败的情况
        with patch.object(self.collector, '_get_active_bookmakers', return_value=["bet365"]):
            with patch.object(self.collector, '_get_upcoming_matches', return_value=["1", "2"]):
                with patch.object(self.collector, '_clean_expired_odds_cache'):
                    # 第一个比赛成功，第二个比赛失败
                    def mock_collect_match_odds(match_id, bookmakers, markets):
                        if match_id == "1":
                            return [{
                                "match_id": "1",
                                "bookmaker": "bet365",
                                "market_type": "h2h",
                                "outcomes": [{"name": "Arsenal", "price": 2.10}],
                                "last_update": "2023-01-01T12:00:00Z"
                            }]
                        else:
                            raise Exception("API Error for match 2")

                    with patch.object(self.collector, '_collect_match_odds', side_effect=mock_collect_match_odds):
                        with patch.object(self.collector, '_has_odds_changed', return_value=True):
                            with patch.object(self.collector, '_clean_odds_data', side_effect=lambda x: x):
                                with patch.object(self.collector, '_save_to_bronze_layer'):
                                    result = await self.collector.collect_odds()

                                    assert result.status == "partial"
                                    assert result.success_count > 0
                                    assert result.error_count > 0
                                    assert result.records_collected > 0

        print("✅ 部分成功的赔率收集测试通过")

    @pytest.mark.asyncio
    async def test_time_window_deduplication(self):
        """测试时间窗口去重机制"""
        print("🧪 测试时间窗口去重...")

        # 测试去重键生成
        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h"
        }

        key1 = self.collector._generate_odds_key(odds_data)

        # 添加到去重集合
        self.collector._recent_odds_keys.add(key1)

        # 再次生成相同的数据，应该被去重
        key2 = self.collector._generate_odds_key(odds_data)
        assert key1 == key2
        assert key2 in self.collector._recent_odds_keys

        print("✅ 时间窗口去重测试通过")

    @pytest.mark.asyncio
    async def test_odds_change_detection_sensitivity(self):
        """测试赔率变化检测灵敏度"""
        print("🧪 测试赔率变化检测灵敏度...")

        odds_data = {
            "match_id": "1",
            "bookmaker": "bet365",
            "market_type": "h2h",
            "outcomes": [
                {"name": "Arsenal", "price": 2.101},  # 变化很小
                {"name": "Chelsea", "price": 3.50}
            ]
        }

        # 设置上次记录的赔率值
        odds_id = "1:bet365:h2h"
        self.collector._last_odds_values[odds_id] = {
            "Arsenal": Decimal("2.10"),
            "Chelsea": Decimal("3.50")
        }

        has_changed = await self.collector._has_odds_changed(odds_data)
        assert has_changed is False  # 变化小于0.01阈值

        print("✅ 赔率变化检测灵敏度测试通过")


def test_odds_collector_comprehensive():
    """赔率收集器综合测试"""
    print("🚀 开始 Batch-Δ-021: 赔率收集器全面测试...")

    test_instance = TestOddsCollector()

    # 执行所有测试
    tests = [
        test_instance.test_collector_initialization,
        test_instance.test_collect_fixtures_skipped,
        test_instance.test_collect_live_scores_skipped,
        test_instance.test_collect_odds_success,
        test_instance.test_collect_odds_with_errors,
        test_instance.test_get_active_bookmakers,
        test_instance.test_get_active_bookmakers_error,
        test_instance.test_get_upcoming_matches,
        test_instance.test_clean_expired_odds_cache,
        test_instance.test_collect_match_odds,
        test_instance.test_collect_match_odds_error,
        test_instance.test_generate_odds_key,
        test_instance.test_has_odds_changed_true,
        test_instance.test_has_odds_changed_false,
        test_instance.test_has_odds_changed_first_time,
        test_instance.test_clean_odds_data_success,
        test_instance.test_clean_odds_data_invalid,
        test_instance.test_collect_odds_partial_success,
        test_instance.test_time_window_deduplication,
        test_instance.test_odds_change_detection_sensitivity
    ]

    passed = 0
    failed = 0

    for test in tests:
        try:
            test_instance.setup_method()

            # 检查是否是异步测试
            if asyncio.iscoroutinefunction(test):
                asyncio.run(test())
            else:
                test()

            passed += 1
            print(f"  ✅ {test.__name__}")
        except Exception as e:
            failed += 1
            print(f"  ❌ {test.__name__}: {e}")

    print(f"\n📊 测试结果: {passed} 通过, {failed} 失败")

    if failed == 0:
        print("🎉 Batch-Δ-021: 赔率收集器测试完成")
        print("\n📋 测试覆盖的功能:")
        print("  - ✅ 收集器初始化和配置")
        print("  - ✅ 赔率数据收集和处理")
        print("  - ✅ 时间窗口去重机制")
        print("  - ✅ 赔率变化检测")
        print("  - ✅ 数据清洗和验证")
        print("  - ✅ 错误处理和异常管理")
        print("  - ✅ 博彩公司管理")
        print("  - ✅ 比赛数据获取")
        print("  - ✅ 缓存管理")
        print("  - ✅ 部分成功场景处理")
    else:
        print("❌ 部分测试失败")


if __name__ == "__main__":
    test_odds_collector_comprehensive()