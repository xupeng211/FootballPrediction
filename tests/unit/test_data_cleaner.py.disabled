"""
单元测试：足球数据清洗器

测试足球数据清洗的核心功能，包括：
- 比赛数据清洗 (clean_match_data)
- 赔率数据清洗 (clean_odds_data)
- 数据验证和标准化
- 异常处理

专注于测试数据清洗业务逻辑，使用Mock隔离数据库依赖。
"""

from unittest.mock import patch

import pytest

from src.data.processing.football_data_cleaner import FootballDataCleaner


@pytest.mark.unit
class TestFootballDataCleaner:
    """足球数据清洗器测试类"""

    @pytest.fixture
    def data_cleaner(self):
        """创建数据清洗器实例"""
        with patch('src.data.processing.football_data_cleaner.DatabaseManager'):
            return FootballDataCleaner()

    @pytest.fixture
    def sample_raw_match_data(self):
        """原始比赛数据样本"""
        return {
            "fixture_id": 12345,
            "home_team": "Arsenal",
            "away_team": "Chelsea",
            "match_date": "2025-09-15T15:00:00Z",
            "home_score": 2,
            "away_score": 1,
            "match_status": "FT",  # Full Time
            "league_name": "Premier League",
            "season": "2024-25",
            "venue": "Emirates Stadium",
            "referee": "Michael Oliver",
        }

    @pytest.fixture
    def sample_raw_odds_data(self):
        """原始赔率数据样本"""
        return [
            {
                "match_id": 12345,
                "bookmaker": "bet365",
                "home_odds": "2.10",  # 字符串格式
                "draw_odds": "3.40",
                "away_odds": "3.50",
                "last_updated": "2025-09-15T14:30:00Z",
            }
        ]

    @pytest.mark.asyncio
    async def test_clean_match_data_success(self, data_cleaner, sample_raw_match_data):
        """测试比赛数据清洗成功场景"""
        # Mock数据库相关方法
        with patch.object(data_cleaner, '_get_or_create_team_id', return_value=1):
            with patch.object(data_cleaner, '_get_or_create_league_id', return_value=1):
                result = await data_cleaner.clean_match_data(sample_raw_match_data)

                assert result is not None
                assert isinstance(result, dict)
                # 验证基本字段存在
                assert "fixture_id" in result
                assert "home_team_id" in result or "home_team" in result
                assert "away_team_id" in result or "away_team" in result

    @pytest.mark.asyncio
    async def test_clean_match_data_with_missing_fields(self, data_cleaner):
        """测试缺失字段的比赛数据清洗"""
        incomplete_data = {
            "fixture_id": 12346,
            "home_team": "Liverpool",
            # 缺少 away_team
            "match_date": "2025-09-16T15:00:00Z",
        }

        result = await data_cleaner.clean_match_data(incomplete_data)
        # 应该返回None或抛出异常
        assert result is None or "away_team" not in result

    def test_validate_score_range_normal(self, data_cleaner):
        """测试正常比分范围验证"""
        score_data = {"home_score": 0, "away_score": 0}
        result = data_cleaner.validate_score_range(score_data)
        assert result is True or result == score_data

    def test_validate_score_range_invalid(self, data_cleaner):
        """测试无效比分范围验证"""
        invalid_score_data = {"home_score": -1, "away_score": 150}
        result = data_cleaner.validate_score_range(invalid_score_data)
        assert result is False or result != invalid_score_data

    def test_standardize_match_status(self, data_cleaner):
        """测试比赛状态标准化"""
        test_cases = [
            ("FT", "finished"),
            ("1H", "first_half"),
            ("HT", "half_time"),
            ("LIVE", "live"),
            ("PST", "postponed")
        ]

        for input_status, expected_output in test_cases:
            result = data_cleaner.standardize_match_status(input_status)
            assert result == expected_output

    @pytest.mark.asyncio
    async def test_clean_odds_data_success(self, data_cleaner, sample_raw_odds_data):
        """测试赔率数据清洗成功场景"""
        result = await data_cleaner.clean_odds_data(sample_raw_odds_data)

        assert result is not None
        if isinstance(result, list) and len(result) > 0:
            odds_item = result[0]
            assert "match_id" in odds_item
            assert "bookmaker" in odds_item

    @pytest.mark.asyncio
    async def test_clean_odds_data_invalid_values(self, data_cleaner):
        """测试无效赔率数据清洗"""
        invalid_odds_data = [
            {
                "match_id": 12345,
                "bookmaker": "bet365",
                "home_odds": "invalid",  # 无效赔率
                "draw_odds": "3.40",
                "away_odds": "3.50",
            }
        ]

        result = await data_cleaner.clean_odds_data(invalid_odds_data)
        # 应该过滤掉无效数据或返回空列表
        assert result is None or len(result) == 0

    @pytest.mark.asyncio
    async def test_odds_probability_consistency(self, data_cleaner, sample_raw_odds_data):
        """测试赔率概率一致性检查"""
        result = await data_cleaner.clean_odds_data(sample_raw_odds_data)

        if result and len(result) > 0:
            odds_item = result[0]
            # 验证赔率转换为概率后总和接近1
            if all(key in odds_item for key in ["home_odds", "draw_odds", "away_odds"]):
                home_prob = 1.0 / float(odds_item["home_odds"])
                draw_prob = 1.0 / float(odds_item["draw_odds"])
                away_prob = 1.0 / float(odds_item["away_odds"])
                total_prob = home_prob + draw_prob + away_prob
                assert 0.95 <= total_prob <= 1.15  # 允许一定的书商利润空间

    def test_handle_missing_values_strategy(self, data_cleaner):
        """测试缺失值处理策略"""
        test_data = {
            "fixture_id": 12345,
            "home_team": "Arsenal",
            "away_team": None,  # 缺失值
            "venue": "",  # 空字符串
        }

        result = data_cleaner.handle_missing_values(test_data, strategy="skip")
        assert result is not None

    @pytest.mark.asyncio
    async def test_data_quality_checks(self, data_cleaner, sample_raw_match_data):
        """测试数据质量检查"""
        with patch.object(data_cleaner, '_get_or_create_team_id', return_value=1):
            with patch.object(data_cleaner, '_get_or_create_league_id', return_value=1):
                result = await data_cleaner.clean_match_data(sample_raw_match_data)

                if result:
                    # 验证数据质量
                    assert "fixture_id" in result
                    assert result["fixture_id"] is not None

    def test_empty_data_handling(self, data_cleaner):
        """测试空数据处理"""
        empty_data = {}
        result = data_cleaner.validate_score_range(empty_data)
        # 应该能正确处理空数据而不崩溃
        assert result is not None or result is False

    @pytest.mark.asyncio
    @pytest.mark.slow
    async def test_batch_cleaning_performance(self, data_cleaner):
        """测试批量清洗性能"""
        batch_data = []
        for i in range(100):
            data = {
                "fixture_id": i,
                "home_team": f"Team{i}A",
                "away_team": f"Team{i}B",
                "match_date": "2025-09-15T15:00:00Z",
            }
            batch_data.append(data)

        # 测试批量处理不会超时
        with patch.object(data_cleaner, '_get_or_create_team_id', return_value=1):
            with patch.object(data_cleaner, '_get_or_create_league_id', return_value=1):
                for data in batch_data[:5]:  # 只测试前5个避免测试过慢
                    result = await data_cleaner.clean_match_data(data)
                    assert result is not None

    @pytest.mark.asyncio
    async def test_data_type_conversion(self, data_cleaner):
        """测试数据类型转换"""
        mixed_type_data = {
            "fixture_id": "12345",  # 字符串格式的ID
            "home_team": "Arsenal",
            "away_team": "Chelsea",
            "home_score": "2",  # 字符串格式的分数
            "away_score": "1",
            "match_date": "2025-09-15T15:00:00Z",
        }

        with patch.object(data_cleaner, '_get_or_create_team_id', return_value=1):
            with patch.object(data_cleaner, '_get_or_create_league_id', return_value=1):
                result = await data_cleaner.clean_match_data(mixed_type_data)

                if result:
                    # 验证类型转换
                    assert isinstance(result.get("fixture_id"), (int, str))

    @pytest.mark.asyncio
    async def test_special_characters_handling(self, data_cleaner):
        """测试特殊字符处理"""
        special_char_data = {
            "fixture_id": 12345,
            "home_team": "Real Madrid CF",  # 包含特殊字符
            "away_team": "Barcelona FC",
            "venue": "Santiago Bernabéu",  # 包含重音符号
            "match_date": "2025-09-15T15:00:00Z",
        }

        with patch.object(data_cleaner, '_get_or_create_team_id', return_value=1):
            with patch.object(data_cleaner, '_get_or_create_league_id', return_value=1):
                result = await data_cleaner.clean_match_data(special_char_data)

                if result:
                    # 验证特殊字符被正确处理
                    assert "home_team" in result
                    assert "venue" in result or result.get("venue") is None
