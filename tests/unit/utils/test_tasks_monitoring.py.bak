"""
任务监控模块测试
"""

import pytest
from unittest.mock import AsyncMock, patch
from datetime import datetime, timedelta
import time

from prometheus_client import CollectorRegistry

from src.tasks.monitoring import TaskMonitor


class TestTaskMonitor:
    """任务监控器测试"""

    @pytest.fixture
    def monitor(self):
        """创建任务监控器实例（使用独立注册表）"""
        registry = CollectorRegistry()
        return TaskMonitor(registry=registry)

    @pytest.fixture
    def monitor_with_global_registry(self):
        """创建使用全局注册表的监控器"""
        return TaskMonitor()

    def test_monitor_init(self, monitor):
        """测试监控器初始化"""
        assert monitor.registry is not None
        assert monitor.task_counter is not None
        assert monitor.task_duration is not None
        assert monitor.task_error_rate is not None
        assert monitor.active_tasks is not None
        assert monitor.queue_size is not None
        assert monitor.retry_counter is not None

    def test_monitor_init_with_global_registry(self, monitor_with_global_registry):
        """测试使用全局注册表初始化"""
        monitor = monitor_with_global_registry
        assert monitor.registry is not None
        assert monitor.task_counter is not None

    def test_create_counter(self, monitor):
        """测试创建计数器"""
        counter = monitor._create_counter(
            "test_counter", "Test counter description", ["label1", "label2"]
        )
        assert counter is not None

    def test_create_counter_existing(self, monitor):
        """测试创建已存在的计数器"""
        # 第一次创建
        monitor._create_counter("existing_counter", "Existing counter", ["label"])

        # 第二次创建应该返回相同的实例或mock
        counter2 = monitor._create_counter(
            "existing_counter", "Existing counter", ["label"]
        )
        assert counter2 is not None

    def test_create_histogram(self, monitor):
        """测试创建直方图"""
        histogram = monitor._create_histogram(
            "test_histogram", "Test histogram description", ["task_name"]
        )
        assert histogram is not None

    def test_create_gauge(self, monitor):
        """测试创建仪表盘"""
        gauge = monitor._create_gauge(
            "test_gauge", "Test gauge description", ["queue_name"]
        )
        assert gauge is not None

    def test_record_task_start(self, monitor):
        """测试记录任务开始"""
        with patch.object(monitor.task_counter, "inc") as mock_inc:
            with patch.object(monitor.active_tasks, "inc") as mock_active:
                monitor.record_task_start("test_task", task_id="task_123")

                mock_inc.assert_called_once_with(
                    task_name="test_task", status="started"
                )
                mock_active.assert_called_once_with(task_name="test_task")

    def test_record_task_completion(self, monitor):
        """测试记录任务完成"""
        start_time = time.time() - 5  # 5秒前开始

        with patch.object(monitor.task_counter, "inc") as mock_inc:
            with patch.object(monitor.task_duration, "observe") as mock_observe:
                with patch.object(monitor.active_tasks, "dec") as mock_dec:
                    monitor.record_task_completion(
                        "test_task",
                        start_time=start_time,
                        success=True,
                        task_id="task_123",
                    )

                    mock_inc.assert_called_once_with(
                        task_name="test_task", status="success"
                    )
                    assert mock_observe.call_count == 1
                    assert mock_observe.call_args[0][0] >= 4.9  # 至少4.9秒
                    mock_dec.assert_called_once_with(task_name="test_task")

    def test_record_task_failure(self, monitor):
        """测试记录任务失败"""
        start_time = time.time() - 2

        with patch.object(monitor.task_counter, "inc") as mock_inc:
            with patch.object(monitor.task_duration, "observe") as mock_observe:
                with patch.object(monitor.active_tasks, "dec") as mock_dec:
                    monitor.record_task_failure(
                        "failed_task",
                        start_time=start_time,
                        error_type="ValueError",
                        task_id="task_456",
                    )

                    mock_inc.assert_called_once_with(
                        task_name="failed_task", status="failed"
                    )
                    mock_observe.assert_called_once()
                    mock_dec.assert_called_once_with(task_name="failed_task")

    def test_record_retry_attempt(self, monitor):
        """测试记录重试尝试"""
        with patch.object(monitor.retry_counter, "inc") as mock_inc:
            monitor.record_retry_attempt(
                "retryable_task", retry_count=2, error_type="TimeoutError"
            )

            mock_inc.assert_called_once_with(
                task_name="retryable_task", retry_count="2"
            )

    def test_update_queue_size(self, monitor):
        """测试更新队列大小"""
        with patch.object(monitor.queue_size, "set") as mock_set:
            monitor.update_queue_size("default_queue", 100)
            mock_set.assert_called_once_with(queue_name="default_queue", value=100)

    @pytest.mark.asyncio
    async def test_get_task_statistics(self, monitor):
        """测试获取任务统计"""
        # 模拟数据库查询
        with patch.object(
            monitor, "_query_task_stats", new_callable=AsyncMock
        ) as mock_query:
            mock_stats = {
                "total_tasks": 1000,
                "successful_tasks": 950,
                "failed_tasks": 30,
                "running_tasks": 20,
                "avg_duration": 2.5,
                "error_rate": 0.03,
                "tasks_by_type": {
                    "data_collection": 400,
                    "api_sync": 300,
                    "report_generation": 200,
                    "cleanup": 100,
                },
            }
            mock_query.return_value = mock_stats

            stats = await monitor.get_task_statistics(
                start_time=datetime.now() - timedelta(hours=24), end_time=datetime.now()
            )

            assert stats["total_tasks"] == 1000
            assert stats["successful_tasks"] == 950
            assert stats["failed_tasks"] == 30
            assert stats["error_rate"] == 0.03
            assert "tasks_by_type" in stats

    @pytest.mark.asyncio
    async def test_update_error_rate(self, monitor):
        """测试更新错误率"""
        with patch.object(monitor.task_error_rate, "set") as mock_set:
            await monitor.update_error_rate("test_task", hours=1)
            mock_set.assert_called_once()

            # 验证错误率值在0-1之间
            error_rate = mock_set.call_args[1]["value"]
            assert 0 <= error_rate <= 1

    @pytest.mark.asyncio
    async def test_monitor_health_check(self, monitor):
        """测试监控器健康检查"""
        with patch.object(
            monitor, "_check_prometheus_health", new_callable=AsyncMock
        ) as mock_check:
            mock_check.return_value = {
                "status": "healthy",
                "metrics_count": 10,
                "last_update": datetime.now().isoformat(),
            }

            health = await monitor.health_check()
            assert health["status"] == "healthy"
            assert "metrics_count" in health
            assert "last_update" in health

    def test_get_metrics_summary(self, monitor):
        """测试获取指标摘要"""
        # 模拟指标数据
        with patch.object(monitor.registry, "_collector_to_names") as mock_collectors:
            mock_collectors.return_value = {
                "football_tasks_total": MagicMock(),
                "football_task_duration_seconds": MagicMock(),
                "football_task_error_rate": MagicMock(),
                "football_active_tasks": MagicMock(),
                "football_queue_size": MagicMock(),
                "football_task_retries_total": MagicMock(),
            }

            summary = monitor.get_metrics_summary()
            assert len(summary) == 6
            assert "football_tasks_total" in summary
            assert "football_task_duration_seconds" in summary

    @pytest.mark.asyncio
    async def test_export_metrics(self, monitor):
        """测试导出指标"""
        with patch("src.tasks.monitoring.generate_latest") as mock_generate:
            mock_generate.return_value = b"metrics_data"

            data = await monitor.export_metrics()
            assert data == b"metrics_data"
            mock_generate.assert_called_once_with(monitor.registry)

    def test_reset_metrics(self, monitor):
        """测试重置指标"""
        with patch.object(monitor.registry, "_collector_to_names") as mock_collectors:
            mock_collectors.clear.return_value = None

            # 重置应该不会抛出异常
            monitor.reset_metrics()

            # 验证clear被调用
            mock_collectors.clear.assert_called_once()

    def test_custom_labels(self, monitor):
        """测试自定义标签"""
        with patch.object(monitor.task_counter, "labels") as mock_labels:
            with patch.object(monitor.task_counter, "inc"):
                mock_counter = MagicMock()
                mock_labels.return_value = mock_counter

                monitor.record_task_start(
                    "custom_task", task_id="task_789", custom_label="custom_value"
                )

                # 验证labels被调用
                mock_labels.assert_called_once_with(
                    task_name="custom_task", status="started"
                )
