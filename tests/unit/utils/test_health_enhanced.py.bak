"""
增强的健康检查API测试
提高health.py模块的测试覆盖率
"""

# 可选依赖导入
try:
    from src.dependencies.optional import *
except ImportError:
    pass

import time
from datetime import datetime
from unittest.mock import MagicMock, patch
import pytest
from fastapi import status
from sqlalchemy.exc import SQLAlchemyError
from src.api.health import (
    ServiceCheckError,
    _check_database,
    _collect_database_health,
    _optional_check_skipped,
    _optional_checks_enabled,
    health_check,
    liveness_check,
    readiness_check,
)


class TestHealthCheckBasics:
    """基础健康检查测试"""

    @pytest.mark.asyncio
    async def test_health_check_basic_response(self):
        """测试基础健康检查响应结构"""
        # 模拟minimal模式
        with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
            with patch("src.api.health._collect_database_health") as mock_db:
                mock_db.return_value = _optional_check_skipped("database")

                result = await health_check(check_db=False)

                assert result["status"] == "healthy"
                assert result["service"] == "football-prediction-api"
                assert result["version"] == "1.0.0"
                assert "timestamp" in result
                assert "uptime" in result
                assert "checks" in result
                assert result["mode"] == "minimal"

    @pytest.mark.asyncio
    async def test_health_check_with_db_true(self):
        """测试check_db=True时的行为"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
            with patch("src.api.health._collect_database_health") as mock_db:
                mock_db.return_value = {
                    "healthy": True,
                    "status": "healthy",
                    "response_time_ms": 10,
                    "details": {"message": "数据库连接正常"},
                }

                result = await health_check(check_db=True)

                assert result["mode"] == "full"
                assert result["checks"]["database"]["status"] == "healthy"
                mock_db.assert_called_once()

    @pytest.mark.asyncio
    async def test_health_check_with_db_false(self):
        """测试check_db=False时的行为"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", False):
            with patch("src.api.health._collect_database_health") as mock_db:
                mock_db.return_value = _optional_check_skipped("database")

                result = await health_check(check_db=False)

                assert result["mode"] == "minimal"
                assert result["checks"]["database"]["status"] == "skipped"
                mock_db.assert_called_once()

    @pytest.mark.asyncio
    async def test_health_check_full_mode(self):
        """测试完整模式的健康检查"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", False):
            with patch("src.api.health.FAST_FAIL", True):
                with patch("src.api.health._collect_database_health") as mock_db:
                    with patch("src.api.health._check_redis") as mock_redis:
                        with patch("src.api.health._check_kafka") as mock_kafka:
                            with patch("src.api.health._check_mlflow") as mock_mlflow:
                                with patch(
                                    "src.api.health._check_filesystem"
                                ) as mock_fs:
                                    # 设置所有检查通过
                                    mock_db.return_value = {
                                        "healthy": True,
                                        "status": "healthy",
                                        "response_time_ms": 5,
                                    }
                                    mock_redis.return_value = {
                                        "healthy": True,
                                        "status": "healthy",
                                        "response_time_ms": 3,
                                    }
                                    mock_kafka.return_value = {
                                        "healthy": True,
                                        "status": "healthy",
                                        "response_time_ms": 10,
                                    }
                                    mock_mlflow.return_value = {
                                        "healthy": True,
                                        "status": "healthy",
                                        "response_time_ms": 15,
                                    }
                                    mock_fs.return_value = {
                                        "healthy": True,
                                        "status": "healthy",
                                        "response_time_ms": 1,
                                    }

                                    result = await health_check()

                                    assert result["status"] == "healthy"
                                    assert result["mode"] == "full"
                                    assert all(
                                        check["status"] == "healthy"
                                        for check in result["checks"].values()
                                    )

    @pytest.mark.asyncio
    async def test_health_check_unhealthy_raises_exception(self):
        """测试不健康状态抛出HTTP异常"""
        with patch("src.api.health._collect_database_health") as mock_db:
            mock_db.return_value = {
                "healthy": False,
                "status": "unhealthy",
                "response_time_ms": 0,
                "details": {"error": "Connection failed"},
            }

            with pytest.raises(Exception) as exc_info:
                await health_check(check_db=True)

            assert exc_info.value.status_code == status.HTTP_503_SERVICE_UNAVAILABLE
            detail = exc_info.value.detail
            assert detail["status"] == "unhealthy"
            assert "database" in detail["failed_checks"]

    @pytest.mark.asyncio
    async def test_health_check_response_time_calculation(self):
        """测试响应时间计算"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
            with patch("src.api.health._collect_database_health"):
                start = time.time()
                result = await health_check(check_db=False)
                elapsed = (time.time() - start) * 1000

                assert "response_time_ms" in result
                assert result["response_time_ms"] >= 0
                # 允许一定的误差
                assert abs(result["response_time_ms"] - elapsed) < 50


class TestLivenessCheck:
    """存活性检查测试"""

    @pytest.mark.asyncio
    async def test_liveness_check_basic(self):
        """测试基础存活性检查"""
        result = await liveness_check()

        assert result["status"] == "alive"
        assert "timestamp" in result
        assert datetime.fromisoformat(result["timestamp"]) is not None


class TestReadinessCheck:
    """就绪性检查测试"""

    @pytest.mark.asyncio
    async def test_readiness_check_all_healthy(self):
        """测试所有服务健康时的就绪性检查"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
            with patch("src.api.health._collect_database_health") as mock_db:
                mock_db.return_value = _optional_check_skipped("database")

                result = await readiness_check()

                assert result["ready"] is True
                assert "timestamp" in result
                assert "checks" in result

    @pytest.mark.asyncio
    async def test_readiness_check_unhealthy_raises_exception(self):
        """测试不健康状态抛出异常"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", False):
            with patch("src.api.health._collect_database_health") as mock_db:
                mock_db.return_value = {
                    "healthy": False,
                    "status": "unhealthy",
                    "error": "Database connection failed",
                }

                with pytest.raises(Exception) as exc_info:
                    await readiness_check()

                assert exc_info.value.status_code == status.HTTP_503_SERVICE_UNAVAILABLE
                detail = exc_info.value.detail
                assert detail["ready"] is False
                assert detail["checks"]["database"]["healthy"] is False

    @pytest.mark.asyncio
    async def test_readiness_check_handles_exceptions(self):
        """测试就绪性检查处理异常"""
        with patch("src.api.health._collect_database_health") as mock_db:
            mock_db.side_effect = Exception("Unexpected error")

            result = await readiness_check()

            # 应该捕获异常并标记为不健康
            assert result["checks"]["database"]["healthy"] is False
            assert "error" in result["checks"]["database"]


class TestDatabaseHealthCheck:
    """数据库健康检查测试"""

    @pytest.mark.asyncio
    async def test_check_database_success(self):
        """测试数据库连接成功"""
        mock_session = MagicMock()
        mock_session.execute.return_value = None

        result = await _check_database(mock_session)

        assert result["healthy"] is True
        assert result["status"] == "healthy"
        assert "数据库连接正常" in result["details"]["message"]

    @pytest.mark.asyncio
    async def test_check_database_failure(self):
        """测试数据库连接失败"""
        mock_session = MagicMock()
        mock_session.execute.side_effect = SQLAlchemyError("Connection failed")

        result = await _check_database(mock_session)

        assert result["healthy"] is False
        assert result["status"] == "unhealthy"
        assert "Connection failed" in result["details"]["error"]

    @pytest.mark.asyncio
    async def test_collect_database_health_no_manager(self):
        """测试数据库管理器未初始化的情况"""
        with patch("src.api.health.get_database_manager") as mock_get_manager:
            mock_get_manager.side_effect = RuntimeError(
                "Database manager not initialized"
            )

            result = await _collect_database_health()

            assert result["status"] == "skipped"
            assert "Database manager not initialised" in result["details"]["message"]

    @pytest.mark.asyncio
    async def test_collect_database_health_session_unavailable(self):
        """测试数据库会话不可用的情况"""
        with patch("src.api.health.get_database_manager") as mock_get_manager:
            mock_manager = MagicMock()
            mock_manager.get_session.side_effect = RuntimeError("Session unavailable")
            mock_get_manager.return_value = mock_manager

            result = await _collect_database_health()

            assert result["status"] == "skipped"
            assert "Database session unavailable" in result["details"]["message"]


class TestServiceCheckError:
    """ServiceCheckError异常测试"""

    def test_service_check_error_basic(self):
        """测试ServiceCheckError基本功能"""
        error = ServiceCheckError("Test error")

        assert str(error) == "Test error"
        assert error.details == {}

    def test_service_check_error_with_details(self):
        """测试带详细信息的ServiceCheckError"""
        details = {"code": 500, "service": "redis"}
        error = ServiceCheckError("Test error", details=details)

        assert str(error) == "Test error"
        assert error.details == details


class TestUtilityFunctions:
    """工具函数测试"""

    def test_optional_checks_enabled(self):
        """测试_optional_checks_enabled函数"""
        # 测试FAST_FAIL=true, MINIMAL_HEALTH_MODE=false
        with patch("src.api.health.FAST_FAIL", True):
            with patch("src.api.health.MINIMAL_HEALTH_MODE", False):
                assert _optional_checks_enabled() is True

        # 测试FAST_FAIL=false
        with patch("src.api.health.FAST_FAIL", False):
            with patch("src.api.health.MINIMAL_HEALTH_MODE", False):
                assert _optional_checks_enabled() is False

        # 测试MINIMAL_HEALTH_MODE=true
        with patch("src.api.health.FAST_FAIL", True):
            with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
                assert _optional_checks_enabled() is False

    def test_optional_check_skipped(self):
        """测试_optional_check_skipped函数"""
        service = "Redis"
        result = _optional_check_skipped(service)

        assert result["healthy"] is True
        assert result["status"] == "skipped"
        assert result["response_time_ms"] == 0.0
        assert service in result["details"]["message"]
        assert (
            result["details"]["message"] == f"{service} check skipped in minimal mode"
        )


class TestHealthCheckEdgeCases:
    """边界情况测试"""

    @pytest.mark.asyncio
    async def test_health_check_uptime_calculation(self):
        """测试运行时间计算"""
        with patch("src.api.health._app_start_time", time.time() - 100):
            with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
                with patch("src.api.health._collect_database_health"):
                    result = await health_check(check_db=False)

                    assert result["uptime"] >= 99  # 允许1秒误差
                    assert result["uptime"] <= 101

    @pytest.mark.asyncio
    async def test_health_check_global_exception_handling(self):
        """测试全局异常处理"""
        with patch("src.api.health._collect_database_health") as mock_db:
            mock_db.side_effect = ValueError("Unexpected error")

            with pytest.raises(Exception) as exc_info:
                await health_check(check_db=True)

            assert exc_info.value.status_code == status.HTTP_503_SERVICE_UNAVAILABLE
            detail = exc_info.value.detail
            assert detail["status"] == "unhealthy"
            assert "Unexpected error" in detail["error"]

    @pytest.mark.asyncio
    async def test_health_check_timestamp_format(self):
        """测试时间戳格式"""
        with patch("src.api.health.MINIMAL_HEALTH_MODE", True):
            with patch("src.api.health._collect_database_health"):
                result = await health_check(check_db=False)

                # 验证ISO格式时间戳
                timestamp = result["timestamp"]
                parsed = datetime.fromisoformat(timestamp)
                assert parsed is not None
                assert parsed.tzinfo is None or parsed.tzinfo.total_seconds() == 0
