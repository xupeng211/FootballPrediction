"""测试赔率收集器"""

import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timedelta
import json
import aiohttp

from src.collectors.odds_collector_improved import OddsCollector


@pytest.fixture
def mock_db_session():
    """创建模拟数据库会话"""
    session = AsyncMock()
    session.execute = AsyncMock()
    session.commit = AsyncMock()
    session.add = MagicMock()
    session.refresh = AsyncMock()
    return session


@pytest.fixture
def mock_redis_client():
    """创建模拟Redis客户端"""
    redis = AsyncMock()
    redis.get = AsyncMock(return_value=None)
    redis.set = AsyncMock(return_value=True)
    redis.delete = AsyncMock(return_value=True)
    redis.exists = AsyncMock(return_value=False)
    redis.get_cache_value = AsyncMock(return_value=None)
    redis.set_cache_value = AsyncMock(return_value=True)
    return redis


@pytest.fixture
def odds_collector(mock_db_session, mock_redis_client):
    """创建赔率收集器实例"""
    collector = OddsCollector(
        db_session=mock_db_session,
        redis_manager=mock_redis_client,
        api_key="test_api_key",
        update_interval=300
    )
    return collector


class TestOddsCollector:
    """测试赔率收集器"""

    def test_collector_initialization(self, odds_collector):
        """测试收集器初始化"""
        assert odds_collector.api_key == "test_api_key"
        assert odds_collector.update_interval == 300
        assert odds_collector.running is False
        assert odds_collector.odds_cache == {}
        assert odds_collector.bookmakers == []

    @pytest.mark.asyncio
    async def test_start_collection(self, odds_collector):
        """测试开始收集"""
        # Mock收集任务
        with patch.object(odds_collector, '_start_collection_task') as mock_task:
            await odds_collector.start()
            assert odds_collector.running is True
            mock_task.assert_called_once()

    @pytest.mark.asyncio
    async def test_stop_collection(self, odds_collector):
        """测试停止收集"""
        odds_collector.running = True
        odds_collector.collection_task = AsyncMock()

        await odds_collector.stop()

        assert odds_collector.running is False
        odds_collector.collection_task.cancel.assert_called_once()

    @pytest.mark.asyncio
    async def test_fetch_odds_from_api(self, odds_collector):
        """测试从API获取赔率"""
        mock_response = {
            "response": [
                {
                    "fixture": {"id": 123},
                    "bookmakers": [
                        {
                            "id": 1,
                            "name": "Bet365",
                            "bets": [
                                {
                                    "id": 1,
                                    "name": "Match Winner",
                                    "values": [
                                        {"value": "Home", "odd": 2.10},
                                        {"value": "Draw", "odd": 3.20},
                                        {"value": "Away", "odd": 3.50}
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }

        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_response_obj = AsyncMock()
            mock_response_obj.json = AsyncMock(return_value=mock_response)
            mock_response_obj.status = 200
            mock_get.return_value.__aenter__.return_value = mock_response_obj

            result = await odds_collector._fetch_odds_from_api(fixture_id=123)

            assert result == mock_response
            mock_get.assert_called_once()

    @pytest.mark.asyncio
    async def test_process_odds_data(self, odds_collector):
        """测试处理赔率数据"""
        odds_data = {
            "fixture_id": 123,
            "bookmaker": "Bet365",
            "market": "Match Winner",
            "outcomes": [
                {"name": "Home", "price": 2.10},
                {"name": "Draw", "price": 3.20},
                {"name": "Away", "price": 3.50}
            ],
            "timestamp": datetime.utcnow().isoformat()
        }

        # Mock数据库保存
        odds_collector.db_session.add = MagicMock()
        odds_collector.db_session.commit = AsyncMock()

        # Mock缓存
        odds_collector.redis_manager.set = AsyncMock()

        result = await odds_collector._process_odds_data(odds_data)

        assert result is True
        assert odds_collector.odds_cache.get(123) is not None

    @pytest.mark.asyncio
    async def test_collect_match_odds(self, odds_collector):
        """测试收集比赛赔率"""
        fixture_id = 123

        # Mock缓存未命中
        odds_collector.redis_manager.get_cache_value = AsyncMock(return_value=None)

        # Mock API获取
        mock_odds = {
            "fixture_id": fixture_id,
            "bookmakers": ["Bet365", "William Hill"],
            "markets": ["Match Winner", "Over/Under"]
        }
        odds_collector._fetch_odds_from_api = AsyncMock(return_value=mock_odds)

        # Mock处理
        odds_collector._process_odds_data = AsyncMock(return_value=True)

        result = await odds_collector.collect_match_odds(fixture_id)

        assert isinstance(result, list)
        odds_collector._fetch_odds_from_api.assert_called_once_with(fixture_id)

    @pytest.mark.asyncio
    async def test_collect_multiple_matches_odds(self, odds_collector):
        """测试收集多场比赛赔率"""
        fixture_ids = [123, 456, 789]

        # Mock每个比赛的赔率收集
        async def mock_collect(fixture_id):
            return {
                "fixture_id": fixture_id,
                "bookmaker": "TestBookmaker",
                "odds": [2.10, 3.20, 3.50]
            }

        odds_collector.collect_match_odds = mock_collect

        results = await odds_collector.collect_multiple_matches_odds(fixture_ids)

        assert len(results) == 3
        assert all(isinstance(r, dict) for r in results)

    @pytest.mark.asyncio
    async def test_validate_odds_data(self, odds_collector):
        """测试验证赔率数据"""
        # 有效数据
        valid_data = {
            "fixture_id": 123,
            "bookmaker": "Bet365",
            "market": "Match Winner",
            "outcomes": [
                {"name": "Home", "price": 2.10}
            ]
        }
        assert await odds_collector._validate_odds_data(valid_data) is True

        # 无效数据 - 缺少必要字段
        invalid_data = {
            "fixture_id": 123,
            "bookmaker": "Bet365"
        }
        assert await odds_collector._validate_odds_data(invalid_data) is False

        # 无效数据 - 赔率值不合理
        invalid_odds = {
            "fixture_id": 123,
            "bookmaker": "Bet365",
            "market": "Match Winner",
            "outcomes": [
                {"name": "Home", "price": -1.0}  # 负赔率
            ]
        }
        assert await odds_collector._validate_odds_data(invalid_odds) is False

    @pytest.mark.asyncio
    async def test_calculate_overround(self, odds_collector):
        """测试计算返还率"""
        outcomes = [
            {"price": 2.00},  # 50%
            {"price": 3.00},  # 33.33%
            {"price": 4.00}   # 25%
        ]

        overround = odds_collector._calculate_overround(outcomes)

        # 总概率 = 50% + 33.33% + 25% = 108.33%
        # 返还率 = 100 / 108.33 = 92.31%
        assert 0 < overround < 1
        assert abs(overround - 0.9231) < 0.01

    @pytest.mark.asyncio
    async def test_identify_best_odds(self, odds_collector):
        """测试识别最佳赔率"""
        multiple_bookmakers = [
            {
                "bookmaker": "Bet365",
                "outcomes": [
                    {"name": "Home", "price": 2.10},
                    {"name": "Draw", "price": 3.20},
                    {"name": "Away", "price": 3.50}
                ]
            },
            {
                "bookmaker": "William Hill",
                "outcomes": [
                    {"name": "Home", "price": 2.15},  # 更高
                    {"name": "Draw", "price": 3.10},
                    {"name": "Away", "price": 3.60}   # 更高
                ]
            }
        ]

        best_odds = odds_collector._identify_best_odds(multiple_bookmakers)

        assert best_odds["Home"]["price"] == 2.15
        assert best_odds["Home"]["bookmaker"] == "William Hill"
        assert best_odds["Away"]["price"] == 3.60
        assert best_odds["Away"]["bookmaker"] == "William Hill"
        assert best_odds["Draw"]["price"] == 3.20
        assert best_odds["Draw"]["bookmaker"] == "Bet365"

    @pytest.mark.asyncio
    async def test_track_odds_changes(self, odds_collector):
        """测试跟踪赔率变化"""
        fixture_id = 123

        # 设置初始赔率
        odds_collector.odds_cache[fixture_id] = {
            "timestamp": datetime.utcnow(),
            "odds": {"Home": 2.10}
        }

        # 新赔率
        new_odds = {
            "fixture_id": fixture_id,
            "bookmaker": "Bet365",
            "outcomes": [{"name": "Home", "price": 2.20}]  # 赔率上升
        }

        changes = await odds_collector._track_odds_changes(new_odds)

        assert len(changes) > 0
        assert changes[0]["type"] == "price_change"
        assert changes[0]["from_price"] == 2.10
        assert changes[0]["to_price"] == 2.20

    @pytest.mark.asyncio
    async def test_save_odds_to_database(self, odds_collector):
        """测试保存赔率到数据库"""
        odds_data = {
            "fixture_id": 123,
            "bookmaker_id": 1,
            "market": "Match Winner",
            "odds": json.dumps({"Home": 2.10, "Draw": 3.20, "Away": 3.50}),
            "timestamp": datetime.utcnow()
        }

        # Mock数据库操作
        odds_collector.db_session.add = MagicMock()
        odds_collector.db_session.commit = AsyncMock()

        await odds_collector._save_odds_to_database(odds_data)

        odds_collector.db_session.add.assert_called()
        odds_collector.db_session.commit.assert_called()

    @pytest.mark.asyncio
    async def test_get_historical_odds(self, odds_collector):
        """测试获取历史赔率"""
        fixture_id = 123
        hours_back = 24

        # Mock数据库查询
        historical_odds = [
            {
                "timestamp": datetime.utcnow() - timedelta(hours=1),
                "home_odds": 2.10,
                "draw_odds": 3.20,
                "away_odds": 3.50
            },
            {
                "timestamp": datetime.utcnow() - timedelta(hours=2),
                "home_odds": 2.05,
                "draw_odds": 3.15,
                "away_odds": 3.45
            }
        ]

        odds_collector.db_session.execute = AsyncMock()
        odds_collector.db_session.execute.return_value.scalars.return_value.all.return_value = historical_odds

        result = await odds_collector.get_historical_odds(fixture_id, hours_back)

        assert len(result) == 2
        assert result[0]["home_odds"] == 2.10

    @pytest.mark.asyncio
    async def test_get_odds_summary(self, odds_collector):
        """测试获取赔率汇总"""
        fixture_id = 123

        # Mock赔率数据
        odds_collector.odds_cache[fixture_id] = {
            "bookmakers": ["Bet365", "William Hill"],
            "markets": ["Match Winner", "Over/Under"],
            "last_update": datetime.utcnow()
        }

        summary = await odds_collector.get_odds_summary(fixture_id)

        assert "bookmakers" in summary
        assert "markets" in summary
        assert "last_update" in summary
        assert len(summary["bookmakers"]) == 2

    def test_format_price(self, odds_collector):
        """测试格式化赔率"""
        # 测试不同格式
        assert odds_collector._format_price(2.10) == "2.10"
        assert odds_collector._format_price("2.10") == "2.10"
        assert odds_collector._format_price(2) == "2.00"
        assert odds_collector._format_price(None) == "N/A"

    @pytest.mark.asyncio
    async def test_error_handling_api_error(self, odds_collector):
        """测试API错误处理"""
        # Mock API抛出异常
        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_get.side_effect = aiohttp.ClientError("API Error")

            with patch.object(odds_collector, 'logger') as mock_logger:
                result = await odds_collector._fetch_odds_from_api(fixture_id=123)

                assert result is None
                mock_logger.error.assert_called()

    @pytest.mark.asyncio
    async def test_cache_odds_data(self, odds_collector):
        """测试缓存赔率数据"""
        fixture_id = 123
        odds_data = {"home": 2.10, "draw": 3.20, "away": 3.50}
        cache_key = f"odds:{fixture_id}"

        # Mock缓存设置
        odds_collector.redis_manager.set_cache_value = AsyncMock(return_value=True)

        await odds_collector._cache_odds_data(fixture_id, odds_data)

        # 验证缓存键
        expected_key = f"odds:{fixture_id}"
        odds_collector.redis_manager.set_cache_value.assert_called_once()

    @pytest.mark.asyncio
    async def test_clean_old_cache(self, odds_collector):
        """测试清理旧缓存"""
        # 添加旧数据
        old_time = datetime.utcnow() - timedelta(hours=2)
        odds_collector.odds_cache[123] = {
            "timestamp": old_time,
            "data": {"test": "data"}
        }

        # 添加新数据
        new_time = datetime.utcnow()
        odds_collector.odds_cache[456] = {
            "timestamp": new_time,
            "data": {"test": "data"}
        }

        # 清理超过1小时的缓存
        await odds_collector._clean_old_cache(max_age_hours=1)

        # 验证旧数据被移除
        assert 123 not in odds_collector.odds_cache
        assert 456 in odds_collector.odds_cache

    @pytest.mark.asyncio
    async def test_get_bookmaker_ranking(self, odds_collector):
        """测试获取博彩公司排名"""
        # Mock博彩公司性能数据
        bookmaker_stats = {
            "Bet365": {
                "odds_count": 1000,
                "avg_overround": 0.95,
                "update_frequency": 300
            },
            "William Hill": {
                "odds_count": 800,
                "avg_overround": 0.94,
                "update_frequency": 360
            }
        }

        odds_collector._get_bookmaker_stats = AsyncMock(return_value=bookmaker_stats)

        ranking = await odds_collector.get_bookmaker_ranking()

        assert len(ranking) == 2
        # William Hill 应该排第一（更低的overround）
        assert ranking[0]["name"] == "William Hill"
        assert ranking[1]["name"] == "Bet365"

    @pytest.mark.asyncio
    async def test_detect_arbitrage_opportunity(self, odds_collector):
        """测试检测套利机会"""
        fixture_id = 123

        # 设置多个博彩公司的赔率
        odds_data = {
            "Bet365": {"Home": 2.10, "Draw": 3.20, "Away": 3.50},
            "William Hill": {"Home": 2.15, "Draw": 3.10, "Away": 3.40},
            "Betway": {"Home": 2.05, "Draw": 3.30, "Away": 3.60}
        }

        opportunities = await odds_collector._detect_arbitrage_opportunity(
            fixture_id,
            odds_data
        )

        # 检查是否有套利机会
        if opportunities:
            assert "opportunity" in opportunities[0]
            assert "profit_percentage" in opportunities[0]
            assert opportunities[0]["profit_percentage"] > 0