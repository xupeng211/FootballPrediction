"""测试改进的比分收集器"""

import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch, Mock
from datetime import datetime, timedelta
import json
import aiohttp

from src.collectors.scores_collector_improved import ScoresCollector


@pytest.fixture
def mock_db_session():
    """创建模拟数据库会话"""
    session = AsyncMock()
    session.execute = AsyncMock()
    session.commit = AsyncMock()
    session.rollback = AsyncMock()
    return session


@pytest.fixture
def mock_redis_manager():
    """创建模拟Redis管理器"""
    redis = AsyncMock()
    redis.get = AsyncMock(return_value=None)
    redis.set = AsyncMock(return_value=True)
    redis.delete = AsyncMock(return_value=True)
    redis.exists = AsyncMock(return_value=False)
    return redis


@pytest.fixture
def scores_collector(mock_db_session, mock_redis_manager):
    """创建比分收集器实例"""
    collector = ScoresCollector(
        db_session=mock_db_session,
        redis_manager=mock_redis_manager,
        api_key="test_api_key",
        websocket_url="ws://test.example.com/scores",
        poll_interval=30
    )
    return collector


class TestScoresCollector:
    """测试比分收集器"""

    def test_collector_initialization(self, scores_collector):
        """测试收集器初始化"""
        assert scores_collector.api_key == "test_api_key"
        assert scores_collector.websocket_url == "ws://test.example.com/scores"
        assert scores_collector.poll_interval == 30
        assert scores_collector.running is False
        assert scores_collector.match_cache == {}
        assert scores_collector.last_update_cache == {}

    @pytest.mark.asyncio
    async def test_start_collection(self, scores_collector):
        """测试开始收集"""
        # Mock WebSocket和HTTP任务
        with patch.object(scores_collector, '_start_websocket') as mock_ws, \
             patch.object(scores_collector, '_start_polling') as mock_poll:

            await scores_collector.start()

            assert scores_collector.running is True
            mock_ws.assert_called_once()
            mock_poll.assert_called_once()

    @pytest.mark.asyncio
    async def test_stop_collection(self, scores_collector):
        """测试停止收集"""
        # 先设置运行状态
        scores_collector.running = True
        scores_collector.websocket_task = AsyncMock()
        scores_collector.poll_task = AsyncMock()

        await scores_collector.stop()

        assert scores_collector.running is False
        scores_collector.websocket_task.cancel.assert_called_once()
        scores_collector.poll_task.cancel.assert_called_once()

    @pytest.mark.asyncio
    async def test_fetch_from_api_football_data(self, scores_collector):
        """测试从Football API获取数据"""
        mock_response = {
            "matches": [
                {
                    "id": 123,
                    "utcDate": "2024-01-15T15:00:00Z",
                    "status": "IN_PLAY",
                    "score": {
                        "fullTime": {"home": 2, "away": 1}
                    },
                    "homeTeam": {"id": 1, "name": "Team A"},
                    "awayTeam": {"id": 2, "name": "Team B"}
                }
            ]
        }

        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_response_obj = AsyncMock()
            mock_response_obj.json = AsyncMock(return_value=mock_response)
            mock_response_obj.status = 200
            mock_get.return_value.__aenter__.return_value = mock_response_obj

            result = await scores_collector._fetch_from_football_api()

            assert result == mock_response
            mock_get.assert_called_once()

    @pytest.mark.asyncio
    async def test_fetch_from_api_sports(self, scores_collector):
        """测试从API Sports获取数据"""
        mock_response = {
            "response": [
                {
                    "fixture": {"id": 456},
                    "goals": {"home": 1, "away": 2},
                    "status": {"short": "FT"},
                    "teams": {
                        "home": {"id": 3, "name": "Team C"},
                        "away": {"id": 4, "name": "Team D"}
                    }
                }
            ]
        }

        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_response_obj = AsyncMock()
            mock_response_obj.json = AsyncMock(return_value=mock_response)
            mock_response_obj.status = 200
            mock_get.return_value.__aenter__.return_value = mock_response_obj

            result = await scores_collector._fetch_from_api_sports()

            assert result == mock_response
            mock_get.assert_called_once()

    @pytest.mark.asyncio
    async def test_process_score_data(self, scores_collector):
        """测试处理比分数据"""
        raw_data = {
            "match_id": 123,
            "home_score": 2,
            "away_score": 1,
            "status": "IN_PLAY",
            "minute": 65,
            "last_updated": "2024-01-15T15:65:00Z"
        }

        # Mock数据库保存
        scores_collector.db_session.execute = AsyncMock()
        scores_collector.db_session.commit = AsyncMock()

        # Mock缓存
        scores_collector.redis_manager.set = AsyncMock()

        result = await scores_collector._process_score_data(raw_data)

        assert result is True
        assert scores_collector.match_cache[123]["home_score"] == 2
        assert scores_collector.match_cache[123]["away_score"] == 1

    @pytest.mark.asyncio
    async def test_validate_score_data(self, scores_collector):
        """测试验证比分数据"""
        # 有效数据
        valid_data = {
            "match_id": 123,
            "home_score": 2,
            "away_score": 1,
            "status": "IN_PLAY"
        }
        assert await scores_collector._validate_score_data(valid_data) is True

        # 无效数据 - 缺少必要字段
        invalid_data = {
            "match_id": 123,
            "home_score": 2
        }
        assert await scores_collector._validate_score_data(invalid_data) is False

        # 无效数据 - 比分不合理
        invalid_score = {
            "match_id": 123,
            "home_score": -1,
            "away_score": 100,
            "status": "IN_PLAY"
        }
        assert await scores_collector._validate_score_data(invalid_score) is False

    @pytest.mark.asyncio
    async def test_websocket_connection(self, scores_collector):
        """测试WebSocket连接"""
        mock_websocket = AsyncMock()
        mock_websocket.recv = AsyncMock(
            side_effect=[
                json.dumps({
                    "type": "score_update",
                    "data": {
                        "match_id": 123,
                        "home_score": 1,
                        "away_score": 0,
                        "status": "IN_PLAY"
                    }
                }),
                asyncio.CancelledError()  # 模拟连接关闭
            ]
        )

        with patch('websockets.connect', return_value=mock_websocket):
            try:
                await scores_collector._websocket_handler()
            except asyncio.CancelledError:
                pass  # 预期的取消

            # 验证接收到数据
            assert 123 in scores_collector.match_cache

    @pytest.mark.asyncio
    async def test_http_polling(self, scores_collector):
        """测试HTTP轮询"""
        # Mock API响应
        scores_collector._fetch_from_football_api = AsyncMock(
            return_value={
                "matches": [
                    {
                        "id": 123,
                        "status": "IN_PLAY",
                        "score": {"fullTime": {"home": 2, "away": 1}}
                    }
                ]
            }
        )

        # Mock处理
        scores_collector._process_score_data = AsyncMock(return_value=True)

        # Mock延迟
        with patch('asyncio.sleep', AsyncMock()):
            # 运行一次轮询
            task = asyncio.create_task(scores_collector._poll_handler())
            await asyncio.sleep(0.01)
            task.cancel()

            try:
                await task
            except asyncio.CancelledError:
                pass

    @pytest.mark.asyncio
    async def test_duplicate_data_handling(self, scores_collector):
        """测试重复数据处理"""
        # 添加现有数据到缓存
        scores_collector.match_cache[123] = {
            "home_score": 2,
            "away_score": 1,
            "last_updated": datetime.utcnow()
        }
        scores_collector.last_update_cache[123] = datetime.utcnow()

        # 相同的新数据
        duplicate_data = {
            "match_id": 123,
            "home_score": 2,
            "away_score": 1,
            "status": "IN_PLAY",
            "last_updated": datetime.utcnow().isoformat()
        }

        # 处理应该被跳过
        result = await scores_collector._process_score_data(duplicate_data)
        assert result is False  # 没有更新

    @pytest.mark.asyncio
    async def test_error_handling(self, scores_collector):
        """测试错误处理"""
        # Mock API抛出异常
        scores_collector._fetch_from_football_api = AsyncMock(
            side_effect=aiohttp.ClientError("API Error")
        )

        # 错误应该被记录但不中断处理
        with patch.object(scores_collector, 'logger') as mock_logger:
            await scores_collector._poll_handler()
            # 验证错误被记录
            mock_logger.error.assert_called()

    @pytest.mark.asyncio
    async def test_cache_cleanup(self, scores_collector):
        """测试缓存清理"""
        # 添加过期数据
        old_time = datetime.utcnow() - timedelta(hours=2)
        scores_collector.match_cache[123] = {"test": "data"}
        scores_collector.last_update_cache[123] = old_time

        # 添加新数据
        new_time = datetime.utcnow()
        scores_collector.match_cache[456] = {"test": "data"}
        scores_collector.last_update_cache[456] = new_time

        # 清理缓存
        await scores_collector._cleanup_cache()

        # 验证过期数据被移除
        assert 123 not in scores_collector.match_cache
        assert 123 not in scores_collector.last_update_cache
        assert 456 in scores_collector.match_cache

    @pytest.mark.asyncio
    async def test_get_live_matches(self, scores_collector):
        """测试获取进行中的比赛"""
        # 添加比赛数据
        scores_collector.match_cache = {
            123: {"status": "IN_PLAY", "home_score": 2, "away_score": 1},
            456: {"status": "FT", "home_score": 1, "away_score": 1},
            789: {"status": "NS", "home_score": 0, "away_score": 0}
        }

        live_matches = await scores_collector.get_live_matches()

        assert len(live_matches) == 1
        assert 123 in live_matches
        assert live_matches[123]["status"] == "IN_PLAY"

    @pytest.mark.asyncio
    async def test_batch_process_scores(self, scores_collector):
        """测试批量处理比分"""
        scores_list = [
            {"match_id": 123, "home_score": 2, "away_score": 1, "status": "IN_PLAY"},
            {"match_id": 456, "home_score": 1, "away_score": 1, "status": "FT"},
            {"match_id": 789, "home_score": 0, "away_score": 0, "status": "NS"}
        ]

        # Mock处理方法
        scores_collector._process_score_data = AsyncMock(return_value=True)

        results = await scores_collector._batch_process_scores(scores_list)

        assert len(results) == 3
        assert all(results)  # 所有都应该成功
        assert scores_collector._process_score_data.call_count == 3

    def test_format_match_data(self, scores_collector):
        """测试格式化比赛数据"""
        api_data = {
            "id": 123,
            "utcDate": "2024-01-15T15:00:00Z",
            "status": "IN_PLAY",
            "score": {
                "fullTime": {"home": 2, "away": 1}
            },
            "homeTeam": {"id": 1, "name": "Team A"},
            "awayTeam": {"id": 2, "name": "Team B"}
        }

        formatted = scores_collector._format_api_data(api_data)

        assert formatted["match_id"] == 123
        assert formatted["home_score"] == 2
        assert formatted["away_score"] == 1
        assert formatted["status"] == "IN_PLAY"
        assert "timestamp" in formatted

    @pytest.mark.asyncio
    async def test_performance_metrics(self, scores_collector):
        """测试性能指标"""
        # 模拟一些性能数据
        scores_collector.stats = {
            "api_calls": 100,
            "successful_updates": 95,
            "failed_updates": 5,
            "average_response_time": 0.15,
            "cache_hits": 80,
            "cache_misses": 20
        }

        metrics = await scores_collector.get_performance_metrics()

        assert metrics["api_calls"] == 100
        assert metrics["success_rate"] == 0.95
        assert metrics["average_response_time"] == 0.15
        assert metrics["cache_hit_rate"] == 0.8