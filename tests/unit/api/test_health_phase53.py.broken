"""
Phase 5.3.2: API 健康检查全面测试

目标文件: src/api/health.py
当前覆盖率: 41% (99/178 行未覆盖)
目标覆盖率: ≥70%
测试重点: FastAPI路由、健康检查逻辑、错误处理、依赖注入
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch, Mock
from fastapi.testclient import TestClient
from fastapi import FastAPI, HTTPException, Depends
from datetime import datetime, timedelta
import time
import json
from typing import Dict, Any

# 导入目标模块
from src.api.health import router, health_check, liveness_check, readiness_check, _check_database, _check_redis, _check_kafka, _check_mlflow, _check_filesystem
from src.api.schemas import HealthCheckResponse
from src.database.connection import get_db_session
from src.utils.retry import CircuitBreaker


class TestHealthAPIPhase53:
    """Phase 5.3.2 健康检查API全面测试"""

    @pytest.fixture
    def client(self):
        """创建测试客户端"""
        app = FastAPI()
        app.include_router(router)

        # Mock数据库依赖
        async def mock_get_db_session():
            mock_db = AsyncMock()
            mock_db.execute = AsyncMock()
            return mock_db

        app.dependency_overrides[get_db_session] = mock_get_db_session
        return TestClient(app)

    @pytest.fixture
    def mock_db_session(self):
        """Mock数据库会话"""
        mock_db = AsyncMock()
        mock_db.execute = AsyncMock()
        return mock_db

    def test_liveness_check_basic(self, client):
        """测试基本存活性检查"""
        response = client.get("/health/liveness")
        assert response.status_code == 200

        data = response.json()
        assert "status" in data
        assert "timestamp" in data
        assert data["status"] == "alive"
        assert isinstance(data["timestamp"], str)

    def test_liveness_check_response_structure(self, client):
        """测试存活性检查响应结构"""
        response = client.get("/health/liveness")
        data = response.json()

        # 验证必需字段
        required_fields = ["status", "timestamp"]
        for field in required_fields:
            assert field in data, f"Missing field: {field}"

        # 验证字段类型
        assert isinstance(data["status"], str)
        assert isinstance(data["timestamp"], str)

    def test_readiness_check_success(self, client):
        """测试就绪性检查成功场景"""
        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis, \
             patch('src.api.health._check_kafka') as mock_kafka, \
             patch('src.api.health._check_mlflow') as mock_mlflow, \
             patch('src.api.health._check_filesystem') as mock_fs:

            # Mock所有服务都健康
            mock_db.return_value = {"healthy": True, "details": "Database OK"}
            mock_redis.return_value = {"healthy": True, "details": "Redis OK"}
            mock_kafka.return_value = {"healthy": True, "details": "Kafka OK"}
            mock_mlflow.return_value = {"healthy": True, "details": "MLflow OK"}
            mock_fs.return_value = {"healthy": True, "details": "Feature Store OK"}

            response = client.get("/health/readiness")
            assert response.status_code == 200

            data = response.json()
            assert data["ready"] is True
            assert "checks" in data
            assert "database" in data["checks"]
            assert "redis" in data["checks"]
            assert "kafka" in data["checks"]
            assert "mlflow" in data["checks"]

    def test_readiness_check_partial_failure(self, client):
        """测试就绪性检查部分失败场景"""
        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis, \
             patch('src.api.health._check_kafka') as mock_kafka, \
             patch('src.api.health._check_mlflow') as mock_mlflow, \
             patch('src.api.health._check_filesystem') as mock_fs:

            # Mock部分服务失败
            mock_db.return_value = {"healthy": True, "details": "Database OK"}
            mock_redis.return_value = {"healthy": False, "details": "Redis connection failed", "error": "Connection timeout"}
            mock_kafka.return_value = {"healthy": False, "details": "Kafka connection failed", "error": "Kafka broker not available"}
            mock_mlflow.return_value = {"healthy": True, "details": "MLflow OK"}
            mock_fs.return_value = {"healthy": True, "details": "Filesystem OK"}

            response = client.get("/health/readiness")
            assert response.status_code == 503  # Service Unavailable

            data = response.json()
            assert "detail" in data
            assert data["detail"]["ready"] is False
            assert "checks" in data["detail"]

    def test_readiness_check_all_failure(self, client):
        """测试就绪性检查全部失败场景"""
        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis, \
             patch('src.api.health._check_kafka') as mock_kafka, \
             patch('src.api.health._check_mlflow') as mock_mlflow, \
             patch('src.api.health._check_filesystem') as mock_fs:

            # Mock所有服务都失败
            mock_db.side_effect = Exception("Database connection failed")
            mock_redis.side_effect = Exception("Redis connection failed")
            mock_kafka.side_effect = Exception("Kafka connection failed")
            mock_mlflow.side_effect = Exception("MLflow connection failed")
            mock_fs.side_effect = Exception("Filesystem error")

            response = client.get("/health/readiness")
            assert response.status_code == 503

            data = response.json()
            assert "detail" in data
            assert data["detail"]["ready"] is False
            assert "checks" in data["detail"]

    def test_health_check_comprehensive(self, client):
        """测试综合健康检查"""
        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis, \
             patch('src.api.health._check_kafka') as mock_kafka, \
             patch('src.api.health._check_mlflow') as mock_mlflow, \
             patch('src.api.health._check_filesystem') as mock_fs:

            # Mock服务状态
            mock_db.return_value = {"healthy": True, "details": "Database OK", "response_time_ms": 0.001}
            mock_redis.return_value = {"healthy": True, "details": "Redis OK", "response_time_ms": 0.0005}
            mock_kafka.return_value = {"healthy": True, "details": "Kafka OK", "response_time_ms": 0.002}
            mock_mlflow.return_value = {"healthy": True, "details": "MLflow OK", "response_time_ms": 0.003}
            mock_fs.return_value = {"status": "healthy", "details": {"log_directory": "/tmp/logs"}, "response_time_ms": 0.001}

            response = client.get("/health")
            assert response.status_code == 200

            data = response.json()
            assert "status" in data
            assert "timestamp" in data
            assert "checks" in data

    @pytest.mark.asyncio
    async def test_check_database_success(self):
        """测试数据库检查成功场景"""
        mock_db = AsyncMock()
        mock_result = Mock()
        mock_result.scalar.return_value = 1
        mock_db.execute.return_value = mock_result

        result = await _check_database(mock_db)
        assert result["healthy"] is True
        assert "response_time_ms" in result
        assert result["details"] == "Database connection successful"

    @pytest.mark.asyncio
    async def test_check_database_failure(self):
        """测试数据库检查失败场景"""
        mock_db = AsyncMock()
        mock_db.execute.side_effect = Exception("Connection failed")

        result = await _check_database(mock_db)
        assert result["healthy"] is False
        assert "error" in result
        assert "Connection failed" in result["error"]

    @pytest.mark.asyncio
    async def test_check_database_timeout(self):
        """测试数据库检查超时场景"""
        mock_db = AsyncMock()
        mock_db.execute.side_effect = TimeoutError("Query timeout")

        result = await _check_database(mock_db)
        assert result["healthy"] is False
        assert "timeout" in result["error"].lower()

    @pytest.mark.asyncio
    async def test_check_redis_success(self):
        """测试Redis检查成功场景"""
        with patch('src.cache.redis_manager.RedisManager') as mock_redis_manager_class:
            mock_redis_manager = AsyncMock()
            mock_redis_manager.aping.return_value = True
            mock_redis_manager.get_info.return_value = {
                "version": "7.0.0",
                "connected_clients": 5,
                "used_memory_human": "1MB"
            }
            mock_redis_manager_class.return_value = mock_redis_manager

            result = await _check_redis()
            assert result["healthy"] is True
            assert "version" in result["details"]
            assert result["details"]["version"] == "7.0.0"

    @pytest.mark.asyncio
    async def test_check_redis_connection_failure(self):
        """测试Redis连接失败场景"""
        with patch('src.cache.redis_manager.RedisManager') as mock_redis_manager_class:
            mock_redis_manager = AsyncMock()
            mock_redis_manager.aping.side_effect = Exception("Connection failed")
            mock_redis_manager_class.return_value = mock_redis_manager

            result = await _check_redis()
            assert result["healthy"] is False
            assert "error" in result
            assert "connection failed" in result["error"].lower()

    @pytest.mark.asyncio
    async def test_check_redis_timeout(self):
        """测试Redis超时场景"""
        with patch('src.cache.redis_manager.RedisManager') as mock_redis_manager_class:
            mock_redis_manager = AsyncMock()
            mock_redis_manager.aping.side_effect = TimeoutError("Redis timeout")
            mock_redis_manager_class.return_value = mock_redis_manager

            result = await _check_redis()
            assert result["healthy"] is False
            assert "timeout" in result["error"].lower()

    @pytest.mark.asyncio
    async def test_check_kafka_success(self):
        """测试Kafka检查成功场景"""
        with patch('src.streaming.kafka_consumer.FootballKafkaConsumer') as mock_consumer_class:
            mock_consumer = AsyncMock()
            mock_consumer.check_connection.return_value = {
                "healthy": True,
                "brokers": ["localhost:9092"],
                "topics": ["test-topic"]
            }
            mock_consumer_class.return_value = mock_consumer

            result = await _check_kafka()
            assert result["healthy"] is True
            assert "brokers" in result["details"]

    @pytest.mark.asyncio
    async def test_check_kafka_failure(self):
        """测试Kafka检查失败场景"""
        with patch('src.streaming.kafka_consumer.FootballKafkaConsumer') as mock_consumer_class:
            mock_consumer = AsyncMock()
            mock_consumer.check_connection.side_effect = Exception("Kafka not available")
            mock_consumer_class.return_value = mock_consumer

            result = await _check_kafka()
            assert result["healthy"] is False
            assert "error" in result

    @pytest.mark.asyncio
    async def test_check_mlflow_success(self):
        """测试MLflow检查成功场景"""
        with patch('src.models.model_training.MLflowClient') as mock_client_class:
            mock_client = Mock()
            mock_client.tracking_server_uri = "http://localhost:5000"
            mock_client_class.return_value = mock_client

            result = await _check_mlflow()
            assert result["healthy"] is True
            assert "tracking_server_uri" in result["details"]

    @pytest.mark.asyncio
    async def test_check_mlflow_failure(self):
        """测试MLflow检查失败场景"""
        with patch('src.models.model_training.MLflowClient') as mock_client_class:
            mock_client_class.side_effect = Exception("MLflow server not available")

            result = await _check_mlflow()
            assert result["healthy"] is False
            assert "error" in result

    @pytest.mark.asyncio
    async def test_check_filesystem_success(self):
        """测试文件系统检查成功场景"""
        with patch('os.path.exists', return_value=True), \
             patch('os.makedirs'):

            result = await _check_filesystem()
            assert result["status"] == "healthy"
            assert "response_time_ms" in result
            assert "log_directory" in result["details"]

    @pytest.mark.asyncio
    async def test_check_filesystem_failure(self):
        """测试文件系统检查失败场景"""
        with patch('os.path.exists', return_value=False), \
             patch('os.makedirs', side_effect=Exception("Permission denied")):

            result = await _check_filesystem()
            assert result["status"] == "unhealthy"
            assert "error" in result

    def test_health_check_response_model(self):
        """测试健康检查响应模型"""
        # 测试响应序列化
        response_data = {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "version": "1.0.0",
            "uptime": 3600,
            "checks": {
                "database": {"healthy": True, "response_time": 0.001},
                "redis": {"healthy": True, "response_time": 0.0005}
            },
            "overall_score": 0.95
        }

        # 验证可以被序列化为JSON
        json_str = json.dumps(response_data)
        parsed_data = json.loads(json_str)
        assert parsed_data["status"] == "healthy"

    def test_circuit_breaker_integration(self, client):
        """测试断路器集成"""
        with patch('src.api.health._check_database') as mock_db:
            # 模拟连续失败触发断路器
            mock_db.side_effect = Exception("Database failure")

            # 发送多个请求来触发断路器
            for _ in range(3):
                response = client.get("/health/readiness")
                assert response.status_code == 503

    def test_health_check_timing(self, client):
        """测试健康检查响应时间"""
        start_time = time.time()

        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis:

            mock_db.return_value = {"healthy": True, "response_time": 0.001}
            mock_redis.return_value = {"healthy": True, "response_time": 0.0005}

            response = client.get("/health")
            end_time = time.time()

            assert response.status_code == 200
            assert (end_time - start_time) < 1.0  # 响应时间应该小于1秒

    def test_health_check_error_handling(self, client):
        """测试健康检查错误处理"""
        with patch('src.api.health._check_database') as mock_db, \
             patch('src.api.health._check_redis') as mock_redis, \
             patch('src.api.health._check_kafka') as mock_kafka, \
             patch('src.api.health._check_mlflow') as mock_mlflow, \
             patch('src.api.health._check_filesystem') as mock_fs:

            # 模拟未处理的异常
            mock_db.side_effect = RuntimeError("Unexpected error")

            response = client.get("/health/readiness")
            assert response.status_code == 503

            data = response.json()
            assert "detail" in data
            assert "checks" in data["detail"]

    def test_health_check_dependency_injection(self, client):
        """测试依赖注入"""
        # 测试数据库依赖注入
        with patch('src.api.health.get_db_session') as mock_get_db:
            mock_db = AsyncMock()
            mock_result = Mock()
            mock_result.scalar.return_value = 1
            mock_db.execute.return_value = mock_result
            mock_get_db.return_value = mock_db

            response = client.get("/health/readiness")
            assert response.status_code == 200


def test_health_api_comprehensive_phase53():
    """Phase 5.3.2 健康检查API综合测试"""
    print("🚀 开始 Phase 5.3.2: API 健康检查全面测试...")

    test_instance = TestHealthAPIPhase53()

    # 执行所有测试
    tests = [
        # 基本功能测试
        test_instance.test_liveness_check_basic,
        test_instance.test_liveness_check_response_structure,
        test_instance.test_readiness_check_success,
        test_instance.test_readiness_check_partial_failure,
        test_instance.test_readiness_check_all_failure,
        test_instance.test_health_check_comprehensive,

        # 数据库检查测试
        test_instance.test_check_database_success,
        test_instance.test_check_database_failure,
        test_instance.test_check_database_timeout,

        # Redis检查测试
        test_instance.test_check_redis_success,
        test_instance.test_check_redis_connection_failure,
        test_instance.test_check_redis_timeout,

        # Kafka检查测试
        test_instance.test_check_kafka_success,
        test_instance.test_check_kafka_failure,

        # MLflow检查测试
        test_instance.test_check_mlflow_success,
        test_instance.test_check_mlflow_failure,

        # 文件系统检查测试
        test_instance.test_check_filesystem_success,
        test_instance.test_check_filesystem_failure,

        # 集成测试
        test_instance.test_health_check_response_model,
        test_instance.test_circuit_breaker_integration,
        test_instance.test_health_check_timing,
        test_instance.test_health_check_error_handling,
        test_instance.test_health_check_dependency_injection,
    ]

    passed = 0
    failed = 0

    # 执行同步测试
    for test in tests:
        try:
            test()
            passed += 1
            print(f"  ✅ {test.__name__}")
        except Exception as e:
            failed += 1
            print(f"  ❌ {test.__name__}: {e}")

    print(f"\n📊 测试结果: {passed} 通过, {failed} 失败")

    if failed == 0:
        print("🎉 Phase 5.3.2: API 健康检查测试完成")
        print("\n📋 测试覆盖的功能:")
        print("  - ✅ FastAPI路由测试")
        print("  - ✅ 存活性和就绪性检查")
        print("  - ✅ 数据库健康检查")
        print("  - ✅ Redis健康检查")
        print("  - ✅ Kafka健康检查")
        print("  - ✅ MLflow健康检查")
        print("  - ✅ 文件系统健康检查")
        print("  - ✅ 错误处理和异常场景")
        print("  - ✅ 断路器集成")
        print("  - ✅ 依赖注入测试")
        print("  - ✅ 响应时间和性能")
        print("  - ✅ 响应模型验证")
    else:
        print("❌ 部分测试失败")


if __name__ == "__main__":
    test_health_api_comprehensive_phase53()