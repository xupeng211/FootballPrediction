"""
任务工具函数模块测试
"""

# 可选依赖导入
try:
    from src.dependencies.optional import *
except ImportError:
    pass

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timedelta
from typing import List

from src.tasks.utils import (
    should_collect_live_scores,
    get_upcoming_matches,
    is_match_day,
    get_active_leagues,
    calculate_next_collection_time,
    cleanup_stale_tasks,
    get_task_priority,
)


class TestShouldCollectLiveScores:
    """测试是否应该采集实时比分"""

    @pytest.mark.asyncio
    async def test_should_collect_with_matches(self):
        """测试有比赛时返回True"""
        mock_session = MagicMock()
        mock_result = MagicMock()
        mock_result.scalar = MagicMock(return_value=5)  # 5场比赛

        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            result = await should_collect_live_scores()
            assert result is True

    @pytest.mark.asyncio
    async def test_should_collect_no_matches(self):
        """测试无比赛时返回False"""
        mock_session = MagicMock()
        mock_result = MagicMock()
        mock_result.scalar = MagicMock(return_value=0)  # 0场比赛

        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            result = await should_collect_live_scores()
            assert result is False

    @pytest.mark.asyncio
    async def test_should_collect_with_exception(self):
        """测试异常时返回False"""
        with patch(
            "src.tasks.utils.DatabaseManager", side_effect=Exception("DB error")
        ):
            result = await should_collect_live_scores()
            assert result is False


class TestGetUpcomingMatches:
    """测试获取即将到来的比赛"""

    @pytest.mark.asyncio
    async def test_get_upcoming_matches_success(self):
        """测试成功获取比赛列表"""
        # 模拟数据库返回
        mock_rows = [
            MagicMock(
                id="1",
                home_team_id="10",
                away_team_id="20",
                league_id="100",
                match_time=datetime(2024, 1, 1, 15, 0),
                match_status="scheduled",
            ),
            MagicMock(
                id="2",
                home_team_id="30",
                away_team_id="40",
                league_id="200",
                match_time=datetime(2024, 1, 1, 17, 0),
                match_status="live",
            ),
        ]

        mock_result = MagicMock()
        mock_result.__iter__ = MagicMock(return_value=iter(mock_rows))

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            matches = await get_upcoming_matches(hours=24)

            assert len(matches) == 2
            assert matches[0]["id"] == "1"
            assert matches[0]["match_status"] == "scheduled"
            assert matches[1]["id"] == "2"
            assert matches[1]["match_status"] == "live"

    @pytest.mark.asyncio
    async def test_get_upcoming_matches_empty(self):
        """测试无比赛时返回空列表"""
        mock_result = MagicMock()
        mock_result.__iter__ = MagicMock(return_value=iter([]))

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            matches = await get_upcoming_matches(hours=24)
            assert matches == []

    @pytest.mark.asyncio
    async def test_get_upcoming_matches_with_exception(self):
        """测试异常时返回空列表"""
        with patch(
            "src.tasks.utils.DatabaseManager", side_effect=Exception("DB error")
        ):
            matches = await get_upcoming_matches(hours=24)
            assert matches == []

    @pytest.mark.asyncio
    async def test_get_upcoming_matches_custom_hours(self):
        """测试自定义时间范围"""
        mock_result = MagicMock()
        mock_result.__iter__ = MagicMock(return_value=iter([]))

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            await get_upcoming_matches(hours=12)

            # 验证查询参数
            mock_session.execute.assert_called_once()
            call_args = mock_session.execute.call_args[1]
            assert "end_time" in call_args


class TestIsMatchDay:
    """测试检查是否是比赛日"""

    def test_is_match_day_saturday(self):
        """测试周六是比赛日"""
        saturday = datetime(2024, 1, 6)  # 周六
        assert is_match_day(saturday) is True

    def test_is_match_day_sunday(self):
        """测试周日是比赛日"""
        sunday = datetime(2024, 1, 7)  # 周日
        assert is_match_day(sunday) is True

    def test_is_match_day_monday(self):
        """测试周一不是比赛日"""
        monday = datetime(2024, 1, 8)  # 周一
        assert is_match_day(monday) is False

    def test_is_match_day_default_today(self):
        """测试默认使用今天"""
        with patch("src.tasks.utils.datetime") as mock_datetime:
            now = datetime(2024, 1, 10)  # 假设是周三
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            # 周三不是比赛日
            assert is_match_day() is False

    def test_is_match_day_all_weekdays(self):
        """测试所有星期几"""
        # 2024年1月8日到14日是一周
        dates = [
            datetime(2024, 1, 8),  # 周一
            datetime(2024, 1, 9),  # 周二
            datetime(2024, 1, 10),  # 周三
            datetime(2024, 1, 11),  # 周四
            datetime(2024, 1, 12),  # 周五
            datetime(2024, 1, 13),  # 周六
            datetime(2024, 1, 14),  # 周日
        ]

        expected = [False, False, False, False, False, True, True]
        results = [is_match_day(date) for date in dates]

        assert results == expected


class TestGetActiveLeagues:
    """测试获取活跃联赛"""

    @pytest.mark.asyncio
    async def test_get_active_leagues_success(self):
        """测试成功获取活跃联赛"""
        mock_rows = [
            MagicMock(name="Premier League"),
            MagicMock(name="La Liga"),
            MagicMock(name="Serie A"),
        ]

        mock_result = MagicMock()
        mock_result.__iter__ = MagicMock(return_value=iter(mock_rows))

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            leagues = await get_active_leagues()

            assert len(leagues) == 3
            assert "Premier League" in leagues
            assert "La Liga" in leagues
            assert "Serie A" in leagues

    @pytest.mark.asyncio
    async def test_get_active_leagues_with_exception(self):
        """测试异常时返回默认联赛"""
        with patch(
            "src.tasks.utils.DatabaseManager", side_effect=Exception("DB error")
        ):
            leagues = await get_active_leagues()

            # 返回默认联赛列表
            assert len(leagues) == 4
            assert "Premier League" in leagues
            assert "La Liga" in leagues
            assert "Serie A" in leagues
            assert "Bundesliga" in leagues

    @pytest.mark.asyncio
    async def test_get_active_leagues_empty(self):
        """测试无活跃联赛时返回默认联赛"""
        mock_result = MagicMock()
        mock_result.__iter__ = MagicMock(return_value=iter([]))

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            leagues = await get_active_leagues()

            # 即使查询成功但无结果，异常处理会返回默认联赛
            # 这取决于实际的数据库查询是否抛出异常
            assert isinstance(leagues, list)


class TestCalculateNextCollectionTime:
    """测试计算下次采集时间"""

    def test_calculate_next_fixtures_collection(self):
        """测试计算赛程采集时间"""
        now = datetime(2024, 1, 1, 10, 0)  # 上午10点
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_fixtures_task")

            # 应该是次日凌晨2点
            expected = datetime(2024, 1, 2, 2, 0)
            assert next_time == expected

    def test_calculate_next_fixtures_collection_before_2am(self):
        """测试凌晨2点前的赛程采集时间"""
        now = datetime(2024, 1, 1, 1, 0)  # 凌晨1点
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_fixtures_task")

            # 应该是当天凌晨2点
            expected = datetime(2024, 1, 1, 2, 0)
            assert next_time == expected

    def test_calculate_next_odds_collection(self):
        """测试计算赔率采集时间"""
        now = datetime(2024, 1, 1, 10, 2)  # 10:02
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_odds_task")

            # 应该是10:05
            expected = datetime(2024, 1, 1, 10, 5)
            assert next_time == expected

    def test_calculate_next_odds_collection_hour_boundary(self):
        """测试跨小时的赔率采集时间"""
        now = datetime(2024, 1, 1, 10, 58)  # 10:58
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_odds_task")

            # 应该是11:00
            expected = datetime(2024, 1, 1, 11, 0)
            assert next_time == expected

    def test_calculate_next_scores_collection(self):
        """测试计算比分采集时间"""
        now = datetime(2024, 1, 1, 10, 1)  # 10:01
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_scores_task")

            # 应该是10:02
            expected = datetime(2024, 1, 1, 10, 2)
            assert next_time == expected

    def test_calculate_next_scores_collection_hour_boundary(self):
        """测试跨小时的比分采集时间"""
        now = datetime(2024, 1, 1, 10, 59)  # 10:59
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("collect_scores_task")

            # 应该是11:00
            expected = datetime(2024, 1, 1, 11, 0)
            assert next_time == expected

    def test_calculate_next_unknown_task(self):
        """测试未知任务的采集时间"""
        now = datetime(2024, 1, 1, 10, 0)
        with patch("src.tasks.utils.datetime") as mock_datetime:
            mock_datetime.now = MagicMock(return_value=now)
            mock_datetime.side_effect = lambda *args, **kw: datetime(*args, **kw)

            next_time = calculate_next_collection_time("unknown_task")

            # 默认1小时后
            expected = datetime(2024, 1, 1, 11, 0)
            assert next_time == expected


class TestCleanupStaleTasks:
    """测试清理过期任务"""

    @pytest.mark.asyncio
    async def test_cleanup_stale_tasks_success(self):
        """测试成功清理过期任务"""
        mock_result = MagicMock()
        mock_result.rowcount = 10  # 清理了10条记录

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)
        mock_session.commit = AsyncMock()

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            cleaned_count = await cleanup_stale_tasks()

            assert cleaned_count == 10
            mock_session.execute.assert_called_once()
            mock_session.commit.assert_called_once()

    @pytest.mark.asyncio
    async def test_cleanup_stale_tasks_no_rowcount(self):
        """测试没有rowcount属性的结果"""
        mock_result = MagicMock()
        del mock_result.rowcount  # 删除rowcount属性

        mock_session = MagicMock()
        mock_session.execute = MagicMock(return_value=mock_result)
        mock_session.commit = AsyncMock()

        mock_db_manager = MagicMock()
        mock_db_manager.get_async_session.return_value.__aenter__ = MagicMock(
            return_value=mock_session
        )
        mock_db_manager.get_async_session.return_value.__aexit__ = AsyncMock(
            return_value=None
        )

        with patch("src.tasks.utils.DatabaseManager", return_value=mock_db_manager):
            cleaned_count = await cleanup_stale_tasks()

            assert cleaned_count == 0

    @pytest.mark.asyncio
    async def test_cleanup_stale_tasks_with_exception(self):
        """测试异常时返回0"""
        with patch(
            "src.tasks.utils.DatabaseManager", side_effect=Exception("DB error")
        ):
            cleaned_count = await cleanup_stale_tasks()
            assert cleaned_count == 0


class TestGetTaskPriority:
    """测试获取任务优先级"""

    def test_get_scores_task_priority(self):
        """测试比分采集任务优先级"""
        priority = get_task_priority("collect_scores_task")
        assert priority == 1  # 最高优先级

    def test_get_odds_task_priority(self):
        """测试赔率采集任务优先级"""
        priority = get_task_priority("collect_odds_task")
        assert priority == 2  # 中等优先级

    def test_get_fixtures_task_priority(self):
        """测试赛程采集任务优先级"""
        priority = get_task_priority("collect_fixtures_task")
        assert priority == 3  # 较低优先级

    def test_get_unknown_task_priority(self):
        """测试未知任务优先级"""
        priority = get_task_priority("unknown_task")
        assert priority == 5  # 默认优先级

    def test_get_task_priority_string_conversion(self):
        """测试任务名称字符串转换"""
        # 测试传入非字符串类型
        priority = get_task_priority(123)  # 数字类型
        assert priority == 5  # 默认优先级

        priority = get_task_priority(None)  # None类型
        assert priority == 5  # 默认优先级

    def test_all_priorities_defined(self):
        """测试所有已定义的优先级"""
        tasks = ["collect_scores_task", "collect_odds_task", "collect_fixtures_task"]
        priorities = [get_task_priority(task) for task in tasks]

        # 确保优先级是唯一的且按预期排序
        assert sorted(priorities) == priorities
        assert priorities[0] == 1  # 比分采集最高优先级
        assert priorities[1] == 2  # 赔率采集中等优先级
        assert priorities[2] == 3  # 赛程采集较低优先级
