#!/usr/bin/env python3
"""
P3.1.3 Repositoryå±‚é›†æˆæµ‹è¯•
å‡çº§P2 Mockæµ‹è¯•åˆ°çœŸå®æ•°æ®åº“é›†æˆæµ‹è¯•
éªŒè¯CRUDæ“ä½œåœ¨çœŸå®PostgreSQLæ•°æ®åº“ä¸­çš„å·¥ä½œæƒ…å†µ
"""

import asyncio
import pytest
import pytest_asyncio
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text

# å¯¼å…¥P3.1.2çš„çœŸå®æ•°æ®åº“è¿æ¥fixtures
from tests.integration.conftest import (
    integration_db_session,
    integration_connection_pool,
    database_transaction_manager,
)

# å¯¼å…¥çœŸå®çš„Repositoryå®ç°
from src.database.repositories.user import UserRepository
from src.database.repositories.prediction import PredictionRepository
from src.database.connection import DatabaseManager

# å¯¼å…¥æ•°æ®æ¨¡å‹
from src.database.models.user import User, UserRole
from src.database.models.predictions import Predictions


class TestUserRepositoryIntegration:
    """UserRepositoryçœŸå®æ•°æ®åº“é›†æˆæµ‹è¯•"""

    @pytest_asyncio.fixture
    async def user_repository(
        self, integration_db_session: AsyncSession
    ) -> UserRepository:
        """åˆ›å»ºUserRepositoryå®ä¾‹ï¼Œä½¿ç”¨çœŸå®çš„æ•°æ®åº“ä¼šè¯"""

        # åˆ›å»ºä¸´æ—¶çš„DatabaseManagerç”¨äºæµ‹è¯•
        class TestDatabaseManager(DatabaseManager):
            def __init__(self, session: AsyncSession):
                self._session = session

            async def get_async_session(self):
                return self._session

        test_db_manager = TestDatabaseManager(integration_db_session)
        return UserRepository(test_db_manager)

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_user_create_real_database(
        self, user_repository: UserRepository, integration_db_session: AsyncSession
    ):
        """æµ‹è¯•ç”¨æˆ·åˆ›å»º - çœŸå®æ•°æ®åº“æ’å…¥"""
        print("\nğŸ‘¤ æµ‹è¯•ç”¨æˆ·åˆ›å»º (çœŸå®æ•°æ®åº“)...")

        user_data = {
            "username": "test_user_integration",
            "email": "test@integration.com",
            "password_hash": "hashed_password_123",
            "first_name": "Test",
            "last_name": "User",
            "role": UserRole.USER,
            "is_active": True,
            "is_verified": False,
        }

        # æ‰§è¡Œåˆ›å»ºæ“ä½œ
        created_user = await user_repository.create(user_data)

        print(f"âœ… ç”¨æˆ·åˆ›å»ºæˆåŠŸï¼ŒID: {created_user.id}")

        # éªŒè¯æ•°æ®åº“ä¸­çœŸçš„æ’å…¥äº†æ•°æ®
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text("SELECT COUNT(*) FROM users WHERE username = :username"),
                {"username": "test_user_integration"},
            )
            db_count = result.scalar()

        print(f"ğŸ“Š æ•°æ®åº“ä¸­è®°å½•æ•°: {db_count}")
        assert db_count == 1, f"æ•°æ®åº“ä¸­åº”è¯¥æœ‰1æ¡è®°å½•ï¼Œå®é™…: {db_count}"

        # éªŒè¯æ’å…¥çš„æ•°æ®å®Œæ•´æ€§
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    SELECT username, email, first_name, last_name, role, is_active
                    FROM users WHERE id = :user_id
                """
                ),
                {"user_id": created_user.id},
            )
            db_user = result.fetchone()

        assert db_user is not None, "æ•°æ®åº“ä¸­åº”è¯¥æ‰¾åˆ°ç”¨æˆ·è®°å½•"
        assert db_user.username == "test_user_integration"
        assert db_user.email == "test@integration.com"
        assert db_user.first_name == "Test"
        assert db_user.last_name == "User"
        assert db_user.role == UserRole.USER
        assert db_user.is_active is True

        print("âœ… ç”¨æˆ·åˆ›å»ºéªŒè¯é€šè¿‡ - æ•°æ®çœŸå®å­˜åœ¨äºæ•°æ®åº“ä¸­")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_user_read_real_database(
        self, user_repository: UserRepository, integration_db_session: AsyncSession
    ):
        """æµ‹è¯•ç”¨æˆ·è¯»å– - ä»çœŸå®æ•°æ®åº“è·å–"""
        print("\nğŸ“– æµ‹è¯•ç”¨æˆ·è¯»å– (çœŸå®æ•°æ®åº“)...")

        # å…ˆåœ¨æ•°æ®åº“ä¸­æ’å…¥æµ‹è¯•æ•°æ®
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO users (username, email, password_hash, first_name, last_name, role, created_at, updated_at)
                    VALUES (:username, :email, :password_hash, :first_name, :last_name, :role, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "username": "read_test_user",
                    "email": "read@test.com",
                    "password_hash": "hash_read_test",
                    "first_name": "Read",
                    "last_name": "Test",
                    "role": UserRole.USER,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            user_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•ç”¨æˆ·ï¼ŒID: {user_id}")

        # ä½¿ç”¨Repositoryè¯»å–æ•°æ®
        retrieved_user = await user_repository.get_by_id(user_id)

        assert retrieved_user is not None, f"åº”è¯¥èƒ½è¯»å–åˆ°ç”¨æˆ·ID {user_id}"
        assert retrieved_user.username == "read_test_user"
        assert retrieved_user.email == "read@test.com"
        assert retrieved_user.first_name == "Read"
        assert retrieved_user.last_name == "Test"

        print(f"âœ… ç”¨æˆ·è¯»å–æˆåŠŸ: {retrieved_user.username}")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_user_update_real_database(
        self, user_repository: UserRepository, integration_db_session: AsyncSession
    ):
        """æµ‹è¯•ç”¨æˆ·æ›´æ–° - çœŸå®æ•°æ®åº“æ›´æ–°"""
        print("\nâœï¸ æµ‹è¯•ç”¨æˆ·æ›´æ–° (çœŸå®æ•°æ®åº“)...")

        # å…ˆæ’å…¥æµ‹è¯•ç”¨æˆ·
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO users (username, email, password_hash, first_name, last_name, role, created_at, updated_at)
                    VALUES (:username, :email, :password_hash, :first_name, :last_name, :role, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "username": "update_test_user",
                    "email": "update@test.com",
                    "password_hash": "hash_update_test",
                    "first_name": "Update",
                    "last_name": "Test",
                    "role": UserRole.USER,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            user_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•ç”¨æˆ·ï¼ŒID: {user_id}")

        # ä½¿ç”¨Repositoryæ›´æ–°ç”¨æˆ·
        update_data = {
            "first_name": "Updated",
            "last_name": "Name",
            "is_verified": True,
            "last_login": datetime.utcnow(),
        }

        updated_user = await user_repository.update(user_id, update_data)

        assert updated_user is not None, "ç”¨æˆ·æ›´æ–°åº”è¯¥æˆåŠŸ"
        assert updated_user.first_name == "Updated"
        assert updated_user.last_name == "Name"
        assert updated_user.is_verified is True
        assert updated_user.last_login is not None

        # éªŒè¯æ•°æ®åº“ä¸­çš„æ•°æ®ç¡®å®æ›´æ–°äº†
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    SELECT first_name, last_name, is_verified, last_login
                    FROM users WHERE id = :user_id
                """
                ),
                {"user_id": user_id},
            )
            db_user = result.fetchone()

        assert db_user is not None
        assert db_user.first_name == "Updated"
        assert db_user.last_name == "Name"
        assert db_user.is_verified is True
        assert db_user.last_login is not None

        print("âœ… ç”¨æˆ·æ›´æ–°éªŒè¯é€šè¿‡ - æ•°æ®åº“ä¸­æ•°æ®å·²æ›´æ–°")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_user_delete_real_database(
        self, user_repository: UserRepository, integration_db_session: AsyncSession
    ):
        """æµ‹è¯•ç”¨æˆ·åˆ é™¤ - çœŸå®æ•°æ®åº“åˆ é™¤"""
        print("\nğŸ—‘ï¸ æµ‹è¯•ç”¨æˆ·åˆ é™¤ (çœŸå®æ•°æ®åº“)...")

        # å…ˆæ’å…¥æµ‹è¯•ç”¨æˆ·
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO users (username, email, password_hash, first_name, last_name, role, created_at, updated_at)
                    VALUES (:username, :email, :password_hash, :first_name, :last_name, :role, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "username": "delete_test_user",
                    "email": "delete@test.com",
                    "password_hash": "hash_delete_test",
                    "first_name": "Delete",
                    "last_name": "Test",
                    "role": UserRole.USER,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            user_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•ç”¨æˆ·ï¼ŒID: {user_id}")

        # éªŒè¯ç”¨æˆ·ç¡®å®å­˜åœ¨
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text("SELECT COUNT(*) FROM users WHERE id = :user_id"),
                {"user_id": user_id},
            )
            count_before = result.scalar()

        assert count_before == 1, "åˆ é™¤å‰ç”¨æˆ·åº”è¯¥å­˜åœ¨"

        # ä½¿ç”¨Repositoryåˆ é™¤ç”¨æˆ·
        deleted_user = await user_repository.delete(user_id)

        assert deleted_user is not None, "ç”¨æˆ·åˆ é™¤åº”è¯¥æˆåŠŸ"
        assert deleted_user.username == "delete_test_user"

        # éªŒè¯æ•°æ®åº“ä¸­ç”¨æˆ·ç¡®å®è¢«åˆ é™¤äº†
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text("SELECT COUNT(*) FROM users WHERE id = :user_id"),
                {"user_id": user_id},
            )
            count_after = result.scalar()

        assert count_after == 0, "åˆ é™¤åç”¨æˆ·åº”è¯¥ä¸å­˜åœ¨"

        print("âœ… ç”¨æˆ·åˆ é™¤éªŒè¯é€šè¿‡ - æ•°æ®åº“ä¸­æ•°æ®å·²åˆ é™¤")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_user_repository_special_methods(
        self, user_repository: UserRepository, integration_db_session: AsyncSession
    ):
        """æµ‹è¯•UserRepositoryç‰¹æ®Šæ–¹æ³•"""
        print("\nğŸ” æµ‹è¯•UserRepositoryç‰¹æ®Šæ–¹æ³•...")

        # æ’å…¥å¤šä¸ªæµ‹è¯•ç”¨æˆ·
        test_users = [
            ("special_user_1", "special1@test.com"),
            ("special_user_2", "special2@test.com"),
            ("special_user_3", "special3@test.com"),
        ]

        for username, email in test_users:
            async with integration_db_session.begin():
                await integration_db_session.execute(
                    text(
                        """
                        INSERT INTO users (username, email, password_hash, first_name, last_name, role, created_at, updated_at)
                        VALUES (:username, :email, :password_hash, :first_name, :last_name, :role, :created_at, :updated_at)
                    """
                    ),
                    {
                        "username": username,
                        "email": email,
                        "password_hash": "hash_special",
                        "first_name": "Special",
                        "last_name": "User",
                        "role": UserRole.USER,
                        "created_at": datetime.utcnow(),
                        "updated_at": datetime.utcnow(),
                    },
                )

        print("ğŸ“ æ’å…¥å¤šä¸ªæµ‹è¯•ç”¨æˆ·")

        # æµ‹è¯•get_by_username
        user_by_username = await user_repository.get_by_username("special_user_1")
        assert user_by_username is not None
        assert user_by_username.email == "special1@test.com"
        print("âœ… get_by_username æ–¹æ³•æµ‹è¯•é€šè¿‡")

        # æµ‹è¯•get_by_email
        user_by_email = await user_repository.get_by_email("special2@test.com")
        assert user_by_email is not None
        assert user_by_email.username == "special_user_2"
        print("âœ… get_by_email æ–¹æ³•æµ‹è¯•é€šè¿‡")

        # æµ‹è¯•username_exists
        exists_true = await user_repository.username_exists("special_user_3")
        assert exists_true is True

        exists_false = await user_repository.username_exists("non_existent_user")
        assert exists_false is False
        print("âœ… username_exists æ–¹æ³•æµ‹è¯•é€šè¿‡")

        # æµ‹è¯•email_exists
        email_exists_true = await user_repository.email_exists("special3@test.com")
        assert email_exists_true is True

        email_exists_false = await user_repository.email_exists("non_existent@test.com")
        assert email_exists_false is False
        print("âœ… email_exists æ–¹æ³•æµ‹è¯•é€šè¿‡")


class TestPredictionRepositoryIntegration:
    """PredictionRepositoryçœŸå®æ•°æ®åº“é›†æˆæµ‹è¯•"""

    @pytest_asyncio.fixture
    async def prediction_repository(
        self, integration_db_session: AsyncSession
    ) -> PredictionRepository:
        """åˆ›å»ºPredictionRepositoryå®ä¾‹ï¼Œä½¿ç”¨çœŸå®çš„æ•°æ®åº“ä¼šè¯"""

        class TestDatabaseManager(DatabaseManager):
            def __init__(self, session: AsyncSession):
                self._session = session

            async def get_async_session(self):
                return self._session

        test_db_manager = TestDatabaseManager(integration_db_session)
        return PredictionRepository(test_db_manager)

    @pytest_asyncio.fixture
    async def test_user(self, integration_db_session: AsyncSession) -> int:
        """åˆ›å»ºæµ‹è¯•ç”¨æˆ·"""
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO users (username, email, password_hash, first_name, last_name, role, created_at, updated_at)
                    VALUES (:username, :email, :password_hash, :first_name, :last_name, :role, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "username": "prediction_test_user",
                    "email": "prediction@test.com",
                    "password_hash": "hash_prediction_test",
                    "first_name": "Prediction",
                    "last_name": "Tester",
                    "role": UserRole.USER,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            return result.scalar()

    @pytest_asyncio.fixture
    async def test_match(self, integration_db_session: AsyncSession) -> int:
        """åˆ›å»ºæµ‹è¯•æ¯”èµ›"""
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO matches (home_team, away_team, match_date, status, created_at, updated_at)
                    VALUES (:home_team, :away_team, :match_date, :status, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "home_team": "Test Home Team",
                    "away_team": "Test Away Team",
                    "match_date": datetime.utcnow() + timedelta(days=1),
                    "status": "scheduled",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            return result.scalar()

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_prediction_create_real_database(
        self,
        prediction_repository: PredictionRepository,
        integration_db_session: AsyncSession,
        test_user: int,
        test_match: int,
    ):
        """æµ‹è¯•é¢„æµ‹åˆ›å»º - çœŸå®æ•°æ®åº“æ’å…¥"""
        print("\nğŸ”® æµ‹è¯•é¢„æµ‹åˆ›å»º (çœŸå®æ•°æ®åº“)...")

        prediction_data = {
            "user_id": test_user,
            "match_id": test_match,
            "predicted_home_score": 2,
            "predicted_away_score": 1,
            "confidence": 0.85,
            "model_version": "v1.0",
            "status": "pending",
        }

        # æ‰§è¡Œåˆ›å»ºæ“ä½œ
        created_prediction = await prediction_repository.create(prediction_data)

        print(f"âœ… é¢„æµ‹åˆ›å»ºæˆåŠŸï¼ŒID: {created_prediction.id}")

        # éªŒè¯æ•°æ®åº“ä¸­çœŸçš„æ’å…¥äº†æ•°æ®
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    "SELECT COUNT(*) FROM predictions WHERE user_id = :user_id AND match_id = :match_id"
                ),
                {"user_id": test_user, "match_id": test_match},
            )
            db_count = result.scalar()

        print(f"ğŸ“Š æ•°æ®åº“ä¸­è®°å½•æ•°: {db_count}")
        assert db_count == 1, f"æ•°æ®åº“ä¸­åº”è¯¥æœ‰1æ¡è®°å½•ï¼Œå®é™…: {db_count}"

        # éªŒè¯æ’å…¥çš„æ•°æ®å®Œæ•´æ€§
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    SELECT user_id, match_id, predicted_home_score, predicted_away_score, confidence, status
                    FROM predictions WHERE id = :prediction_id
                """
                ),
                {"prediction_id": created_prediction.id},
            )
            db_prediction = result.fetchone()

        assert db_prediction is not None, "æ•°æ®åº“ä¸­åº”è¯¥æ‰¾åˆ°é¢„æµ‹è®°å½•"
        assert db_prediction.user_id == test_user
        assert db_prediction.match_id == test_match
        assert db_prediction.predicted_home_score == 2
        assert db_prediction.predicted_away_score == 1
        assert float(db_prediction.confidence) == 0.85
        assert db_prediction.status == "pending"

        print("âœ… é¢„æµ‹åˆ›å»ºéªŒè¯é€šè¿‡ - æ•°æ®çœŸå®å­˜åœ¨äºæ•°æ®åº“ä¸­")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_prediction_read_real_database(
        self,
        prediction_repository: PredictionRepository,
        integration_db_session: AsyncSession,
        test_user: int,
        test_match: int,
    ):
        """æµ‹è¯•é¢„æµ‹è¯»å– - ä»çœŸå®æ•°æ®åº“è·å–"""
        print("\nğŸ“– æµ‹è¯•é¢„æµ‹è¯»å– (çœŸå®æ•°æ®åº“)...")

        # å…ˆåœ¨æ•°æ®åº“ä¸­æ’å…¥æµ‹è¯•æ•°æ®
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO predictions (user_id, match_id, predicted_home_score, predicted_away_score, confidence, status, created_at, updated_at)
                    VALUES (:user_id, :match_id, :predicted_home_score, :predicted_away_score, :confidence, :status, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "user_id": test_user,
                    "match_id": test_match,
                    "predicted_home_score": 3,
                    "predicted_away_score": 0,
                    "confidence": 0.75,
                    "status": "pending",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            prediction_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•é¢„æµ‹ï¼ŒID: {prediction_id}")

        # ä½¿ç”¨Repositoryè¯»å–æ•°æ®
        retrieved_prediction = await prediction_repository.get_by_id(prediction_id)

        assert retrieved_prediction is not None, f"åº”è¯¥èƒ½è¯»å–åˆ°é¢„æµ‹ID {prediction_id}"
        assert retrieved_prediction.user_id == test_user
        assert retrieved_prediction.match_id == test_match
        assert retrieved_prediction.predicted_home_score == 3
        assert retrieved_prediction.predicted_away_score == 0
        assert float(retrieved_prediction.confidence) == 0.75
        assert retrieved_prediction.status == "pending"

        print(
            f"âœ… é¢„æµ‹è¯»å–æˆåŠŸ: ä¸»é˜Ÿ{retrieved_prediction.predicted_home_score} - å®¢é˜Ÿ{retrieved_prediction.predicted_away_score}"
        )

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_prediction_update_real_database(
        self,
        prediction_repository: PredictionRepository,
        integration_db_session: AsyncSession,
        test_user: int,
        test_match: int,
    ):
        """æµ‹è¯•é¢„æµ‹æ›´æ–° - çœŸå®æ•°æ®åº“æ›´æ–°"""
        print("\nâœï¸ æµ‹è¯•é¢„æµ‹æ›´æ–° (çœŸå®æ•°æ®åº“)...")

        # å…ˆæ’å…¥æµ‹è¯•é¢„æµ‹
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO predictions (user_id, match_id, predicted_home_score, predicted_away_score, confidence, status, created_at, updated_at)
                    VALUES (:user_id, :match_id, :predicted_home_score, :predicted_away_score, :confidence, :status, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "user_id": test_user,
                    "match_id": test_match,
                    "predicted_home_score": 1,
                    "predicted_away_score": 1,
                    "confidence": 0.60,
                    "status": "pending",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            prediction_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•é¢„æµ‹ï¼ŒID: {prediction_id}")

        # ä½¿ç”¨Repositoryæ›´æ–°é¢„æµ‹ï¼ˆæ¨¡æ‹Ÿæ¯”èµ›ç»“æœï¼‰
        update_data = {
            "actual_home_score": 2,
            "actual_away_score": 1,
            "is_correct": True,
            "status": "completed",
            "points_earned": 10.0,
        }

        updated_prediction = await prediction_repository.update(
            prediction_id, update_data
        )

        assert updated_prediction is not None, "é¢„æµ‹æ›´æ–°åº”è¯¥æˆåŠŸ"
        assert updated_prediction.actual_home_score == 2
        assert updated_prediction.actual_away_score == 1
        assert updated_prediction.is_correct is True
        assert updated_prediction.status == "completed"
        assert float(updated_prediction.points_earned) == 10.0

        # éªŒè¯æ•°æ®åº“ä¸­çš„æ•°æ®ç¡®å®æ›´æ–°äº†
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    SELECT actual_home_score, actual_away_score, is_correct, status, points_earned
                    FROM predictions WHERE id = :prediction_id
                """
                ),
                {"prediction_id": prediction_id},
            )
            db_prediction = result.fetchone()

        assert db_prediction is not None
        assert db_prediction.actual_home_score == 2
        assert db_prediction.actual_away_score == 1
        assert db_prediction.is_correct is True
        assert db_prediction.status == "completed"
        assert float(db_prediction.points_earned) == 10.0

        print("âœ… é¢„æµ‹æ›´æ–°éªŒè¯é€šè¿‡ - æ•°æ®åº“ä¸­æ•°æ®å·²æ›´æ–°")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_prediction_delete_real_database(
        self,
        prediction_repository: PredictionRepository,
        integration_db_session: AsyncSession,
        test_user: int,
        test_match: int,
    ):
        """æµ‹è¯•é¢„æµ‹åˆ é™¤ - çœŸå®æ•°æ®åº“åˆ é™¤"""
        print("\nğŸ—‘ï¸ æµ‹è¯•é¢„æµ‹åˆ é™¤ (çœŸå®æ•°æ®åº“)...")

        # å…ˆæ’å…¥æµ‹è¯•é¢„æµ‹
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text(
                    """
                    INSERT INTO predictions (user_id, match_id, predicted_home_score, predicted_away_score, confidence, status, created_at, updated_at)
                    VALUES (:user_id, :match_id, :predicted_home_score, :predicted_away_score, :confidence, :status, :created_at, :updated_at)
                    RETURNING id
                """
                ),
                {
                    "user_id": test_user,
                    "match_id": test_match,
                    "predicted_home_score": 0,
                    "predicted_away_score": 0,
                    "confidence": 0.50,
                    "status": "pending",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                },
            )
            prediction_id = result.scalar()

        print(f"ğŸ“ æ’å…¥æµ‹è¯•é¢„æµ‹ï¼ŒID: {prediction_id}")

        # éªŒè¯é¢„æµ‹ç¡®å®å­˜åœ¨
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text("SELECT COUNT(*) FROM predictions WHERE id = :prediction_id"),
                {"prediction_id": prediction_id},
            )
            count_before = result.scalar()

        assert count_before == 1, "åˆ é™¤å‰é¢„æµ‹åº”è¯¥å­˜åœ¨"

        # ä½¿ç”¨Repositoryåˆ é™¤é¢„æµ‹
        deleted_prediction = await prediction_repository.delete(prediction_id)

        assert deleted_prediction is not None, "é¢„æµ‹åˆ é™¤åº”è¯¥æˆåŠŸ"
        assert deleted_prediction.user_id == test_user
        assert deleted_prediction.match_id == test_match

        # éªŒè¯æ•°æ®åº“ä¸­é¢„æµ‹ç¡®å®è¢«åˆ é™¤äº†
        async with integration_db_session.begin():
            result = await integration_db_session.execute(
                text("SELECT COUNT(*) FROM predictions WHERE id = :prediction_id"),
                {"prediction_id": prediction_id},
            )
            count_after = result.scalar()

        assert count_after == 0, "åˆ é™¤åé¢„æµ‹åº”è¯¥ä¸å­˜åœ¨"

        print("âœ… é¢„æµ‹åˆ é™¤éªŒè¯é€šè¿‡ - æ•°æ®åº“ä¸­æ•°æ®å·²åˆ é™¤")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_prediction_repository_special_methods(
        self,
        prediction_repository: PredictionRepository,
        integration_db_session: AsyncSession,
        test_user: int,
        test_match: int,
    ):
        """æµ‹è¯•PredictionRepositoryç‰¹æ®Šæ–¹æ³•"""
        print("\nğŸ” æµ‹è¯•PredictionRepositoryç‰¹æ®Šæ–¹æ³•...")

        # æ’å…¥å¤šä¸ªæµ‹è¯•é¢„æµ‹
        test_predictions = [
            (test_user, test_match, 2, 1, 0.80),
            (test_user, test_match, 3, 1, 0.90),
            (test_user, test_match, 1, 2, 0.70),
        ]

        for i, (uid, mid, home_score, away_score, confidence) in enumerate(
            test_predictions
        ):
            async with integration_db_session.begin():
                await integration_db_session.execute(
                    text(
                        """
                        INSERT INTO predictions (user_id, match_id, predicted_home_score, predicted_away_score, confidence, status, created_at, updated_at)
                        VALUES (:user_id, :match_id, :predicted_home_score, :predicted_away_score, :confidence, :status, :created_at, :updated_at)
                    """
                    ),
                    {
                        "user_id": uid,
                        "match_id": (
                            mid + i if i > 0 else mid
                        ),  # ä¸ºä¸åŒé¢„æµ‹åˆ›å»ºä¸åŒæ¯”èµ›ID
                        "predicted_home_score": home_score,
                        "predicted_away_score": away_score,
                        "confidence": confidence,
                        "status": "pending",
                        "created_at": datetime.utcnow(),
                        "updated_at": datetime.utcnow(),
                    },
                )

        print("ğŸ“ æ’å…¥å¤šä¸ªæµ‹è¯•é¢„æµ‹")

        # æµ‹è¯•get_by_user
        user_predictions = await prediction_repository.get_by_user(test_user)
        assert (
            len(user_predictions) >= 3
        ), f"åº”è¯¥è‡³å°‘æœ‰3ä¸ªé¢„æµ‹ï¼Œå®é™…: {len(user_predictions)}"
        print(f"âœ… get_by_user æ–¹æ³•æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {len(user_predictions)} ä¸ªé¢„æµ‹")

        # æµ‹è¯•get_by_match
        match_predictions = await prediction_repository.get_by_match(test_match)
        assert (
            len(match_predictions) >= 1
        ), f"åº”è¯¥è‡³å°‘æœ‰1ä¸ªé¢„æµ‹ï¼Œå®é™…: {len(match_predictions)}"
        print(f"âœ… get_by_match æ–¹æ³•æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {len(match_predictions)} ä¸ªé¢„æµ‹")

        # æµ‹è¯•get_by_status
        pending_predictions = await prediction_repository.get_by_status("pending")
        assert (
            len(pending_predictions) >= 3
        ), f"åº”è¯¥è‡³å°‘æœ‰3ä¸ªå¾…å¤„ç†é¢„æµ‹ï¼Œå®é™…: {len(pending_predictions)}"
        print(
            f"âœ… get_by_status æ–¹æ³•æµ‹è¯•é€šè¿‡ï¼Œæ‰¾åˆ° {len(pending_predictions)} ä¸ªå¾…å¤„ç†é¢„æµ‹"
        )


class TestRepositoryTransactionIntegration:
    """Repositoryäº‹åŠ¡é›†æˆæµ‹è¯•"""

    @pytest_asyncio.fixture
    async def user_repository(
        self, integration_db_session: AsyncSession
    ) -> UserRepository:
        class TestDatabaseManager(DatabaseManager):
            def __init__(self, session: AsyncSession):
                self._session = session

            async def get_async_session(self):
                return self._session

        test_db_manager = TestDatabaseManager(integration_db_session)
        return UserRepository(test_db_manager)

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_repository_commit_transaction(
        self, user_repository: UserRepository, database_transaction_manager
    ):
        """æµ‹è¯•Repositoryäº‹åŠ¡æäº¤"""
        print("\nğŸ’¾ æµ‹è¯•Repositoryäº‹åŠ¡æäº¤...")

        transaction_result = (
            await database_transaction_manager.test_commit_transaction()
        )
        assert transaction_result, "äº‹åŠ¡æäº¤æµ‹è¯•åº”è¯¥æˆåŠŸ"

        print("âœ… Repositoryäº‹åŠ¡æäº¤æµ‹è¯•é€šè¿‡")

    @pytest.mark.asyncio
    @pytest.mark.integration
    @pytest.mark.database
    async def test_repository_rollback_transaction(
        self, user_repository: UserRepository, database_transaction_manager
    ):
        """æµ‹è¯•Repositoryäº‹åŠ¡å›æ»š"""
        print("\nğŸ”„ æµ‹è¯•Repositoryäº‹åŠ¡å›æ»š...")

        transaction_result = (
            await database_transaction_manager.test_rollback_transaction()
        )
        assert transaction_result, "äº‹åŠ¡å›æ»šæµ‹è¯•åº”è¯¥æˆåŠŸ"

        print("âœ… Repositoryäº‹åŠ¡å›æ»šæµ‹è¯•é€šè¿‡")


# é›†æˆæµ‹è¯•æ¸…ç†å¤¹å…·
@pytest_asyncio.fixture(autouse=True)
async def cleanup_test_data(integration_db_session: AsyncSession):
    """æ¸…ç†æµ‹è¯•æ•°æ®çš„å¤¹å…·"""
    yield  # æ‰§è¡Œæµ‹è¯•

    # æµ‹è¯•åæ¸…ç†
    try:
        await integration_db_session.execute(
            text(
                "DELETE FROM predictions WHERE user_id IN (SELECT id FROM users WHERE username LIKE '%test%')"
            )
        )
        await integration_db_session.execute(
            text("DELETE FROM users WHERE username LIKE '%test%'")
        )
        await integration_db_session.execute(
            text("DELETE FROM matches WHERE home_team LIKE '%Test%'")
        )
        await integration_db_session.commit()
        print("ğŸ§¹ æµ‹è¯•æ•°æ®æ¸…ç†å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ æ•°æ®æ¸…ç†å¤±è´¥: {e}")
