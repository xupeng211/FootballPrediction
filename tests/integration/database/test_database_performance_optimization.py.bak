"""
数据库性能优化单元测试

验证阶段二性能优化的实现，包括：
1. 分区表插入和查询功能
2. 物化视图刷新逻辑
3. 关键索引使用情况
4. 性能基准验证

测试覆盖：
- 分区表数据插入和查询
- 物化视图刷新机制
- 查询性能验证
- 错误处理和边界条件
"""

import asyncio
import time
from datetime import datetime
from typing import AsyncGenerator
from unittest.mock import AsyncMock, patch

import pytest
import pytest_asyncio
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from scripts.materialized_views_examples import MaterializedViewExamples
from scripts.refresh_materialized_views import MaterializedViewRefresher


def pytest_db_available():
    """检查数据库是否可用以及表结构是否存在"""
    try:
        import sqlalchemy as sa

        from src.database.connection import get_database_manager

        # 检查数据库连接
        db_manager = get_database_manager()

        # 检查关键表是否存在
        with db_manager.get_session() as session:
            result = session.execute(
                sa.text(
                    "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'matches')"
                )
            )
            matches_exists = result.scalar()

            if not matches_exists:
                return False

            # 检查分区表是否存在
            result = session.execute(
                sa.text(
                    "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'matches_2025_09')"
                )
            )
            partition_exists = result.scalar()

            return partition_exists

    except Exception:
        return False


# 跳过需要数据库的测试，如果数据库不可用
pytestmark = [
    pytest.mark.integration,
    pytest.mark.skipif(
        not pytest_db_available(), reason="Database connection not available"
    ),
]


class TestDatabasePartitioning:
    """数据库分区功能测试"""

    @pytest.mark.asyncio
    async def test_matches_partition_insertion(self, async_session: AsyncSession):
        """测试matches分区表数据插入"""

        # 测试数据
        test_matches = [
            {
                "home_team_id": 1,
                "away_team_id": 2,
                "league_id": 1,
                "season": "2025-26",
                "match_time": datetime(2025, 9, 15, 15, 0, 0),
                "match_status": "scheduled",
            },
            {
                "home_team_id": 3,
                "away_team_id": 4,
                "league_id": 1,
                "season": "2025-26",
                "match_time": datetime(2025, 10, 15, 15, 0, 0),
                "match_status": "scheduled",
            },
        ]

        # 插入测试数据到分区表
        for match_data in test_matches:
            insert_query = text(
                """
                INSERT INTO matches (home_team_id, away_team_id, league_id, season, match_time, match_status)
                VALUES (:home_team_id, :away_team_id, :league_id, :season, :match_time, :match_status)
                RETURNING id;
            """
            )

            result = await async_session.execute(insert_query, match_data)
            match_id = result.scalar()

    assert match_id is not None, "分区表插入应该返回有效的ID"

    await async_session.commit()

    # 验证数据插入到正确的分区
    september_query = text(
            """
            SELECT COUNT(*) FROM matches_2025_09
            WHERE match_time >= '2025-09-01' AND match_time < '2025-10-01';
        """
        )

    september_result = await async_session.execute(september_query)
    september_count = september_result.scalar()

    assert september_count >= 1, "9月数据应该插入到2025_09分区"

    october_query = text(
            """
            SELECT COUNT(*) FROM matches_2025_10
            WHERE match_time >= '2025-10-01' AND match_time < '2025-11-01';
        """
        )

    october_result = await async_session.execute(october_query)
    october_count = october_result.scalar()

    assert october_count >= 1, "10月数据应该插入到2025_10分区"

    @pytest.mark.asyncio
    async def test_partition_pruning_query(self, async_session: AsyncSession):
        """测试分区裁剪查询性能"""

        # 查询特定月份数据（应该触发分区裁剪）
        start_time = time.time()

        pruning_query = text(
            """
            SELECT COUNT(*) FROM matches
            WHERE match_time >= '2025-09-01' AND match_time < '2025-10-01'
              AND match_status = 'scheduled';
        """
        )

        result = await async_session.execute(pruning_query)
        count = result.scalar()

        end_time = time.time()
        query_duration = end_time - start_time

        # 验证查询性能（分区裁剪应该使查询很快）
    assert (
            query_duration < 0.1
        ), f"分区裁剪查询应该很快，实际耗时: {query_duration:.3f}秒"
    assert count >= 0, "查询应该返回有效计数"

    @pytest.mark.asyncio
    async def test_odds_partition_insertion(self, async_session: AsyncSession):
        """测试odds分区表数据插入"""

        # 插入测试赔率数据
        odds_data = {
            "match_id": 1,
            "bookmaker": "Test_Bookmaker",
            "market_type": "1x2",
            "home_odds": 2.50,
            "draw_odds": 3.20,
            "away_odds": 2.80,
            "collected_at": datetime(2025, 9, 15, 12, 0, 0),
        }

        insert_odds_query = text(
            """
            INSERT INTO odds (match_id, bookmaker, market_type, home_odds, draw_odds, away_odds, collected_at)
            VALUES (:match_id, :bookmaker, :market_type, :home_odds, :draw_odds, :away_odds, :collected_at)
            RETURNING id;
        """
        )

        result = await async_session.execute(insert_odds_query, odds_data)
        odds_id = result.scalar()

    assert odds_id is not None, "odds分区表插入应该成功"

    await async_session.commit()

    # 验证数据插入到正确分区
    verify_query = text(
        """
        SELECT COUNT(*) FROM odds_2025_09
        WHERE match_id = :match_id AND bookmaker = :bookmaker;
    """
    )

    verify_result = await async_session.execute(
        verify_query,
        {"match_id": odds_data["match_id"], "bookmaker": odds_data["bookmaker"]},
    )

    verify_count = verify_result.scalar()
    assert verify_count >= 1, "赔率数据应该插入到正确的分区"


class TestMaterializedViews:
    """物化视图功能测试"""

    @pytest.mark.asyncio
    async def test_materialized_view_refresher_initialization(self):
        """测试物化视图刷新器初始化"""

        refresher = MaterializedViewRefresher()

    assert refresher.config is not None, "数据库配置应该正确加载"
    assert len(refresher.MATERIALIZED_VIEWS) == 2, "应该定义2个物化视图"
    assert (
            "team_performance" in refresher.MATERIALIZED_VIEWS
        ), "应该包含team_performance视图"
    assert "odds_trends" in refresher.MATERIALIZED_VIEWS, "应该包含odds_trends视图"

    @pytest.mark.asyncio
    async def test_materialized_view_exists_check(self):
        """测试物化视图存在性检查"""

        refresher = MaterializedViewRefresher()

        # 模拟检查视图是否存在
        with patch.object(refresher, "_get_async_engine") as mock_engine:
            mock_conn = AsyncMock()
            mock_result = AsyncMock()
            mock_result.scalar.return_value = True  # 视图存在
            mock_conn.execute.return_value = mock_result
            mock_engine.return_value.begin.return_value.__aenter__.return_value = (
                mock_conn
            )

            result = await refresher.refresh_view("team_performance")

    assert result["success"], "视图存在时刷新应该成功"
    assert "duration" in result, "结果应该包含执行时间"
    assert "view_name" in result, "结果应该包含视图名称"

    @pytest.mark.asyncio
    async def test_materialized_view_nonexistent_handling(self):
        """测试不存在视图的处理"""

        refresher = MaterializedViewRefresher()

        # 模拟视图不存在的情况
        with patch.object(refresher, "_get_async_engine") as mock_engine:
            mock_conn = AsyncMock()
            mock_result = AsyncMock()
            mock_result.scalar.return_value = False  # 视图不存在
            mock_conn.execute.return_value = mock_result
            mock_engine.return_value.begin.return_value.__aenter__.return_value = (
                mock_conn
            )

            result = await refresher.refresh_view("team_performance")

    assert not result["success"], "视图不存在时应该返回失败"
    assert result["error"] == "物化视图不存在", "应该返回正确的错误信息"
    assert result["duration"] == 0, "失败时duration应该为0"

    @pytest.mark.asyncio
    async def test_invalid_view_key_handling(self):
        """测试无效视图键处理"""

        refresher = MaterializedViewRefresher()

        with pytest.raises(ValueError, match="不支持的物化视图"):
            await refresher.refresh_view("invalid_view")

    @pytest.mark.asyncio
    async def test_refresh_all_views(self):
        """测试刷新所有视图"""

        refresher = MaterializedViewRefresher()

        # 模拟成功刷新
        with patch.object(refresher, "refresh_view") as mock_refresh:
            mock_refresh.side_effect = [
                {
                    "success": True,
                    "view_name": "mv_team_recent_performance",
                    "duration": 15.5,
                },
                {"success": True, "view_name": "mv_odds_trends", "duration": 23.2},
            ]

            results = await refresher.refresh_all_views()

    assert len(results) == 2, "应该刷新2个视图"
    assert all(r["success"] for r in results), "所有视图刷新都应该成功"
    assert mock_refresh.call_count == 2, "应该调用2次refresh_view"

    @pytest.mark.asyncio
    async def test_get_view_info(self):
        """测试获取视图信息"""

        refresher = MaterializedViewRefresher()

        # 模拟视图信息查询
        with patch.object(refresher, "_get_async_engine") as mock_engine:
            mock_conn = AsyncMock()
            mock_result = AsyncMock()

            # 模拟pg_matviews查询结果
            mock_metadata_rows = [
                type(
                    "Row",
                    (),
                    {
                        "view_name": "mv_team_recent_performance",
                        "has_indexes": True,
                        "is_populated": True,
                    },
                )()
            ]
            mock_result.fetchall.return_value = mock_metadata_rows

            # 模拟行数查询
            mock_count_result = AsyncMock()
            mock_count_result.scalar.return_value = 42

            mock_conn.execute.side_effect = [mock_result, mock_count_result]
            mock_engine.return_value.begin.return_value.__aenter__.return_value = (
                mock_conn
            )

            info = await refresher.get_view_info()

    assert info["success"], "获取视图信息应该成功"
    assert "views" in info, "结果应该包含视图信息"
    assert len(info["views"]) >= 1, "应该返回至少一个视图的信息"


class TestMaterializedViewExamples:
    """物化视图查询示例测试"""

    @pytest.mark.asyncio
    async def test_examples_initialization(self):
        """测试示例类初始化"""

        examples = MaterializedViewExamples()
    assert examples.config is not None, "配置应该正确初始化"

    @pytest.mark.asyncio
    async def test_execute_query_mock(self):
        """测试查询执行（模拟）"""

        examples = MaterializedViewExamples()

        # 模拟查询执行
        with patch.object(examples, "_get_async_engine") as mock_engine:
            mock_conn = AsyncMock()
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = [("Team A", 5, 3), ("Team B", 4, 2)]
            mock_result.keys.return_value = ["team_name", "matches", "wins"]
            mock_conn.execute.return_value = mock_result
            mock_engine.return_value.begin.return_value.__aenter__.return_value = (
                mock_conn
            )

            test_query = "SELECT team_name, matches, wins FROM mv_team_recent_performance LIMIT 2;"
            results = await examples._execute_query(test_query)

    assert len(results) == 2, "应该返回2行结果"
    assert results[0]["team_name"] == "Team A", "第一行数据应该正确"
    assert results[1]["wins"] == 2, "第二行数据应该正确"

    @pytest.mark.asyncio
    async def test_performance_test_mock(self):
        """测试性能测试（模拟）"""

        examples = MaterializedViewExamples()

        # 模拟快速查询
        with patch.object(examples, "_execute_query") as mock_execute:
            mock_execute.return_value = [{"count": 10}]

            # 捕获print输出
            with patch("builtins.print") as mock_print:
                await examples._performance_test(
                    "测试查询", "SELECT COUNT(*) FROM test_table;"
                )

                # 验证有性能输出
                assert mock_print.call_count > 0, "应该有性能测试输出"

                # 检查是否输出了执行时间
                printed_args = [call[0] for call in mock_print.call_args_list]
                time_output_found = any(
                    "平均执行时间" in str(args) for args in printed_args
                )
                assert time_output_found, "应该输出平均执行时间"


class TestDatabaseIndexes:
    """数据库索引功能测试"""

    @pytest.mark.asyncio
    async def test_index_existence(self, async_session: AsyncSession):
        """测试关键索引是否存在"""

        # 查询数据库中的索引
        index_query = text(
            """
            SELECT indexname, tablename
            FROM pg_indexes
            WHERE schemaname = 'public'
              AND indexname IN (
                  'idx_matches_time_status',
                  'idx_matches_home_team_time',
                  'idx_odds_match_bookmaker_collected',
                  'idx_features_match_team'
              )
            ORDER BY indexname;
        """
        )

        result = await async_session.execute(index_query)
        indexes = result.fetchall()

        expected_indexes = {
            "idx_matches_time_status",
            "idx_matches_home_team_time",
            "idx_odds_match_bookmaker_collected",
            "idx_features_match_team",
        }

        found_indexes = {row.indexname for row in indexes}

        # 验证关键索引存在（可能因为分区表重建而不存在，这是正常的）
        if found_indexes:
            assert found_indexes.issubset(
                expected_indexes
            ), "所有找到的索引都应该在预期列表中"

    @pytest.mark.asyncio
    async def test_index_usage_simulation(self, async_session: AsyncSession):
        """测试索引使用情况（模拟查询）"""

        # 执行应该使用索引的查询
        test_queries = [
            # 时间范围查询（应该使用 idx_matches_time_status）
            """
            SELECT COUNT(*) FROM matches
            WHERE match_time >= CURRENT_DATE - INTERVAL '7 days'
              AND match_status = 'finished';
            """,
            # 球队历史查询（应该使用 idx_matches_home_team_time）
            """
            SELECT COUNT(*) FROM matches
            WHERE home_team_id = 1
              AND match_time >= CURRENT_DATE - INTERVAL '30 days';
            """,
        ]

        for query in test_queries:
            start_time = time.time()
            result = await async_session.execute(text(query))
            count = result.scalar()
            end_time = time.time()

            query_duration = end_time - start_time

            # 验证查询性能合理（有索引的查询应该很快）
            assert (
                query_duration < 1.0
            ), f"索引查询应该很快，实际耗时: {query_duration:.3f}秒"
            assert count >= 0, "查询应该返回有效计数"


class TestPerformanceOptimizationIntegration:
    """性能优化集成测试"""

    @pytest.mark.asyncio
    async def test_end_to_end_performance_optimization(
        self, async_session: AsyncSession
    ):
        """端到端性能优化测试"""

        # 1. 测试分区表插入
        test_match = {
            "home_team_id": 1,
            "away_team_id": 2,
            "league_id": 1,
            "season": "2025-26",
            "match_time": datetime.now(),
            "match_status": "scheduled",
        }

        insert_query = text(
            """
            INSERT INTO matches (home_team_id, away_team_id, league_id, season, match_time, match_status)
            VALUES (:home_team_id, :away_team_id, :league_id, :season, :match_time, :match_status)
            RETURNING id;
        """
        )

        result = await async_session.execute(insert_query, test_match)
        match_id = result.scalar()
        await async_session.commit()

    assert match_id is not None, "分区表插入应该成功"

        # 2. 测试查询性能
        start_time = time.time()

        performance_query = text(
            """
            SELECT COUNT(*) FROM matches
            WHERE match_time >= CURRENT_DATE - INTERVAL '1 day';
        """
        )

        result = await async_session.execute(performance_query)
        count = result.scalar()

        end_time = time.time()
        query_duration = end_time - start_time

        assert (
            query_duration < 0.5
        ), f"优化后查询应该很快，实际耗时: {query_duration:.3f}秒"
        assert count >= 0, "查询应该返回有效结果"

        # 3. 测试物化视图刷新（模拟）
        refresher = MaterializedViewRefresher()

        with patch.object(refresher, "_get_async_engine") as mock_engine:
            mock_conn = AsyncMock()
            mock_result = AsyncMock()
            mock_result.scalar.side_effect = [
                True,
                10,
                12,
            ]  # exists, count_before, count_after
            mock_conn.execute.return_value = mock_result
            mock_engine.return_value.begin.return_value.__aenter__.return_value = (
                mock_conn
            )

            refresh_result = await refresher.refresh_view("team_performance")

        assert refresh_result["success"], "物化视图刷新应该成功"
        assert (
            refresh_result["rows_after"] >= refresh_result["rows_before"]
        ), "刷新后行数应该合理"

    @pytest.mark.asyncio
    async def test_error_handling_and_edge_cases(self):
        """测试错误处理和边界情况"""

        refresher = MaterializedViewRefresher()

        # 测试网络错误处理
        with patch.object(refresher, "_get_async_engine") as mock_engine:
            mock_engine.side_effect = Exception("数据库连接失败")

            result = await refresher.refresh_view("team_performance")

          assert not result["success"], "连接失败时应该返回失败"
        assert "数据库连接失败" in result["error"], "应该包含具体错误信息"

        # 测试无效参数
        with pytest.raises(ValueError):
            await refresher.refresh_view("nonexistent_view")

    @pytest.mark.asyncio
    async def test_concurrent_operations_simulation(self):
        """测试并发操作模拟"""

        refresher = MaterializedViewRefresher()

        # 模拟并发刷新
        with patch.object(refresher, "refresh_view") as mock_refresh:
            mock_refresh.return_value = {
                "success": True,
                "duration": 10.0,
                "view_name": "test_view",
            }

            # 模拟并发执行
            tasks = [
                refresher.refresh_view("team_performance"),
                refresher.refresh_view("odds_trends"),
            ]

            results = await asyncio.gather(*tasks)

        assert len(results) == 2, "应该返回2个结果"
        assert all(r["success"] for r in results), "所有并发操作都应该成功"


@pytest_asyncio.fixture
async def async_session() -> AsyncGenerator[AsyncSession, None]:
    """提供异步数据库会话的fixture"""
    from src.database.connection import DatabaseManager

    db_manager = DatabaseManager()
    if not hasattr(db_manager, "_async_engine") or db_manager._async_engine is None:
        db_manager.initialize()
    async with db_manager.get_async_session() as session:
        yield session


# 性能基准测试标记
@pytest.mark.performance
class TestPerformanceBenchmarks:
    """性能基准测试"""

    @pytest.mark.asyncio
    async def test_query_performance_benchmarks(self, async_session: AsyncSession):
        """查询性能基准测试"""

        # 定义基准查询
        benchmark_queries = [
            {
                "name": "分区表时间范围查询",
                "query": """
                    SELECT COUNT(*) FROM matches
                    WHERE match_time >= CURRENT_DATE - INTERVAL '30 days';
                """,
                "expected_max_duration": 0.1,  # 100ms
            },
            {
                "name": "复合索引查询",
                "query": """
                    SELECT COUNT(*) FROM matches
                    WHERE home_team_id = 1 AND match_time >= CURRENT_DATE - INTERVAL '7 days';
                """,
                "expected_max_duration": 0.05,  # 50ms
            },
        ]

        for benchmark in benchmark_queries:
            start_time = time.time()

            result = await async_session.execute(text(str(benchmark["query"])))  # type: ignore[arg-type]
            count = result.scalar()

            end_time = time.time()
            duration = end_time - start_time

            print(f"\n{benchmark['name']}: {duration*1000:.2f}ms")

            # 性能断言（在测试环境中可能不准确，仅作参考）
            # assert duration <= benchmark['expected_max_duration'], \
            #     f"{benchmark['name']} 超过性能基准: {duration:.3f}s > {benchmark['expected_max_duration']}s"

            assert count >= 0, f"{benchmark['name']} 应该返回有效计数"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
