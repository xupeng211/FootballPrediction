#!/usr/bin/env python3
"""
ç¬¬ä¸‰é˜¶æ®µç®€åŒ–æµ‹è¯•è„šæœ¬
Stage 3 Simple Test Script - Database Integration and Caching
"""

import asyncio
import logging
import os
import sys
from datetime import datetime
from typing import Any

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
sys.path.insert(0, "/home/user/projects/FootballPrediction")

# è®¾ç½®ç¯å¢ƒå˜é‡
os.environ["FOOTBALL_DATA_API_KEY"] = "ed809154dc1f422da46a18d8961a98a0"

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

logger = logging.getLogger(__name__)

# å°è¯•å¯¼å…¥æ¨¡å—ï¼Œå¤±è´¥æ—¶ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
try:
    from test_stage2_fixed import SimpleDataCollector
except ImportError:
    logger.error("æ— æ³•å¯¼å…¥åŸºç¡€æ•°æ®é‡‡é›†å™¨")
    sys.exit(1)


class SimpleCacheManager:
    """ç®€åŒ–çš„ç¼“å­˜ç®¡ç†å™¨"""

    def __init__(self):
        self.cache = {}
        self.cache_timestamps = {}

    def set_cache(self, key: str, value: Any, ttl_seconds: int = 3600) -> bool:
        """è®¾ç½®ç¼“å­˜"""
        try:
            self.cache[key] = value
            self.cache_timestamps[key] = {
                "created_at": datetime.utcnow(),
                "ttl_seconds": ttl_seconds,
            }
            return True
        except Exception as e:
            logger.error(f"è®¾ç½®ç¼“å­˜å¤±è´¥: {e}")
            return False

    def get_cache(self, key: str) -> Any:
        """è·å–ç¼“å­˜"""
        try:
            if key not in self.cache:
                return None

            # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            timestamp_info = self.cache_timestamps.get(key)
            if timestamp_info:
                age = (datetime.utcnow() - timestamp_info["created_at"]).total_seconds()
                if age > timestamp_info["ttl_seconds"]:
                    del self.cache[key]
                    del self.cache_timestamps[key]
                    return None

            return self.cache.get(key)
        except Exception as e:
            logger.error(f"è·å–ç¼“å­˜å¤±è´¥: {e}")
            return None

    def delete_cache(self, key: str) -> bool:
        """åˆ é™¤ç¼“å­˜"""
        try:
            if key in self.cache:
                del self.cache[key]
            if key in self.cache_timestamps:
                del self.cache_timestamps[key]
            return True
        except Exception as e:
            logger.error(f"åˆ é™¤ç¼“å­˜å¤±è´¥: {e}")
            return False

    def clear_all(self) -> bool:
        """æ¸…ç©ºæ‰€æœ‰ç¼“å­˜"""
        try:
            self.cache.clear()
            self.cache_timestamps.clear()
            return True
        except Exception as e:
            logger.error(f"æ¸…ç©ºç¼“å­˜å¤±è´¥: {e}")
            return False


class Stage3SimpleTester:
    """ç¬¬ä¸‰é˜¶æ®µç®€åŒ–æµ‹è¯•å™¨"""

    def __init__(self):
        self.cache_manager = SimpleCacheManager()
        self.test_results = {
            "total_tests": 0,
            "passed_tests": 0,
            "failed_tests": 0,
            "errors": [],
        }

    async def test_basic_caching(self) -> bool:
        """æµ‹è¯•åŸºç¡€ç¼“å­˜åŠŸèƒ½"""
        try:
            logger.info("æµ‹è¯•åŸºç¡€ç¼“å­˜åŠŸèƒ½...")

            # æµ‹è¯•è®¾ç½®å’Œè·å–ç¼“å­˜
            test_data = {
                "external_id": "2021",
                "name": "Premier League",
                "code": "PL",
                "type": "LEAGUE",
            }

            # ç¼“å­˜æ•°æ®
            success = self.cache_manager.set_cache(
                "league:2021", test_data, ttl_seconds=60
            )
            if not success:
                raise Exception("ç¼“å­˜æ•°æ®å¤±è´¥")

            # è·å–ç¼“å­˜æ•°æ®
            cached_data = self.cache_manager.get_cache("league:2021")
            if not cached_data or cached_data.get("name") != "Premier League":
                raise Exception("è·å–ç¼“å­˜æ•°æ®å¤±è´¥")

            logger.info("  âœ… åŸºç¡€ç¼“å­˜è®¾ç½®å’Œè·å–æ­£å¸¸")

            # æµ‹è¯•ç¼“å­˜è¿‡æœŸ
            self.cache_manager.set_cache("temp_data", "test_value", ttl_seconds=1)
            await asyncio.sleep(2)  # ç­‰å¾…è¿‡æœŸ
            expired_data = self.cache_manager.get_cache("temp_data")
            if expired_data is not None:
                raise Exception("ç¼“å­˜è¿‡æœŸæœºåˆ¶å¤±æ•ˆ")

            logger.info("  âœ… ç¼“å­˜è¿‡æœŸæœºåˆ¶æ­£å¸¸")

            # æµ‹è¯•ç¼“å­˜åˆ é™¤
            self.cache_manager.set_cache("delete_test", "value")
            delete_success = self.cache_manager.delete_cache("delete_test")
            if not delete_success:
                raise Exception("åˆ é™¤ç¼“å­˜å¤±è´¥")

            deleted_data = self.cache_manager.get_cache("delete_test")
            if deleted_data is not None:
                raise Exception("åˆ é™¤ç¼“å­˜åä»èƒ½è·å–æ•°æ®")

            logger.info("  âœ… ç¼“å­˜åˆ é™¤åŠŸèƒ½æ­£å¸¸")

            return True

        except Exception as e:
            logger.error(f"  âŒ åŸºç¡€ç¼“å­˜åŠŸèƒ½æµ‹è¯•å¤±è´¥: {e}")
            return False

    async def test_data_structures(self) -> bool:
        """æµ‹è¯•æ•°æ®ç»“æ„"""
        try:
            logger.info("æµ‹è¯•æ•°æ®ç»“æ„...")

            # æµ‹è¯•è”èµ›æ•°æ®ç»“æ„
            league_structure = {
                "external_id": str,
                "name": str,
                "code": str,
                "type": str,
                "area": dict,
                "season": dict,
                "last_updated": str,
            }

            # æµ‹è¯•çƒé˜Ÿæ•°æ®ç»“æ„
            team_structure = {
                "external_id": str,
                "name": str,
                "short_name": str,
                "tla": str,
                "crest": str,
                "address": str,
                "website": str,
                "founded": int,
                "area": dict,
            }

            # æµ‹è¯•ç§¯åˆ†æ¦œæ•°æ®ç»“æ„
            standings_structure = {
                "position": int,
                "team": dict,
                "played_games": int,
                "won": int,
                "draw": int,
                "lost": int,
                "points": int,
                "goals_for": int,
                "goals_against": int,
                "goal_difference": int,
            }

            # éªŒè¯æ•°æ®ç»“æ„å®Œæ•´æ€§
            required_structures = [
                "league_structure",
                "team_structure",
                "standings_structure",
            ]
            for structure_name in required_structures:
                structure = locals().get(structure_name)
                if not structure:
                    raise Exception(f"æ•°æ®ç»“æ„å®šä¹‰ç¼ºå¤±: {structure_name}")

            logger.info("  âœ… æ•°æ®ç»“æ„å®šä¹‰å®Œæ•´")

            # æµ‹è¯•æ•°æ®è½¬æ¢
            sample_league = {
                "external_id": "2021",
                "name": "Premier League",
                "code": "PL",
                "type": "LEAGUE",
                "area": {"name": "England", "code": "ENG"},
                "season": {"current_matchday": 12},
                "last_updated": datetime.utcnow().isoformat(),
            }

            # ç¼“å­˜å¹¶éªŒè¯æ•°æ®è½¬æ¢
            self.cache_manager.set_cache("test_league", sample_league)
            cached_league = self.cache_manager.get_cache("test_league")

            if not cached_league or cached_league.get("name") != "Premier League":
                raise Exception("æ•°æ®è½¬æ¢å¤±è´¥")

            logger.info("  âœ… æ•°æ®è½¬æ¢å’Œç¼“å­˜æ­£å¸¸")

            return True

        except Exception as e:
            logger.error(f"  âŒ æ•°æ®ç»“æ„æµ‹è¯•å¤±è´¥: {e}")
            return False

def _test_api_data_integration_handle_error():
            logger.info("æµ‹è¯•APIæ•°æ®é›†æˆ...")

            async with SimpleDataCollector() as collector:
                # æµ‹è¯•è”èµ›æ•°æ®é‡‡é›†å’Œç¼“å­˜
                competitions_data = await collector._make_request_with_retry(
                    "competitions"
                )

def _test_api_data_integration_handle_error():
            logger.info("æµ‹è¯•ç¼“å­˜æ€§èƒ½...")

            # å‡†å¤‡æµ‹è¯•æ•°æ®
            test_data = [
                {"id": i, "name": f"Team {i}", "points": i * 3} for i in range(1000)
            ]

            # æµ‹è¯•æ‰¹é‡å†™å…¥æ€§èƒ½
            start_time = datetime.utcnow()

def _test_api_data_integration_iterate_items():
    for i in range(1000):
        data = {"id": i, "name": f"Team {i}", "performance": i * 0.1}
        self.cache_manager.set_cache(f"team:{i}", data, ttl_seconds=3600)

    write_time = (datetime.utcnow() - start_time).total_seconds()
    logger.info(f"  âœ… æ‰¹é‡å†™å…¥1000æ¡æ•°æ®è€—æ—¶: {write_time:.3f}ç§’")

            # æµ‹è¯•æ‰¹é‡è¯»å–æ€§èƒ½
            start_time = datetime.utcnow()
            successful_reads = 0

def _test_api_data_integration_check_condition():
                    successful_reads += 1

            read_time = (datetime.utcnow() - start_time).total_seconds()
            logger.info(f"  âœ… æ‰¹é‡è¯»å–1000æ¡æ•°æ®è€—æ—¶: {read_time:.3f}ç§’")
            logger.info(
                f"  âœ… è¯»å–æˆåŠŸç‡: {successful_reads}/1000 ({successful_reads/10:.1f}%)"
            )

            # æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ
            cache_size = len(self.cache_manager.cache)
            logger.info(f"  âœ… ç¼“å­˜ä¸­åŒ…å« {cache_size} æ¡æ•°æ®")


def _test_api_data_integration_check_condition():
                logger.warning(f"  âš ï¸ å†™å…¥æ€§èƒ½è¾ƒæ…¢: {write_time:.3f}ç§’")


def _test_api_data_integration_check_condition():
                logger.warning(f"  âš ï¸ è¯»å–æ€§èƒ½è¾ƒæ…¢: {read_time:.3f}ç§’")

            return True

def _test_api_data_integration_handle_error():
            logger.info("æµ‹è¯•é”™è¯¯å¤„ç†...")

            # æµ‹è¯•æ— æ•ˆæ•°æ®ç±»å‹ç¼“å­˜
            invalid_data = object()  # ä¸å¯åºåˆ—åŒ–çš„å¯¹è±¡
            self.cache_manager.set_cache("invalid_test", invalid_data)
            # åº”è¯¥èƒ½å¤Ÿç¼“å­˜ï¼Œå› ä¸ºä½¿ç”¨çš„æ˜¯å†…å­˜ç¼“å­˜

            # æµ‹è¯•ç©ºé”®å€¼å¤„ç†
            empty_success = self.cache_manager.set_cache("", "test_value")

def _test_api_data_integration_check_condition():
                logger.warning("  âš ï¸ ç©ºé”®å€¼å¤„ç†å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•Noneå€¼ç¼“å­˜
            none_success = self.cache_manager.set_cache("none_test", None)

def _test_api_data_integration_check_condition():
                logger.warning("  âš ï¸ Noneå€¼ç¼“å­˜å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•è¶…é•¿é”®å€¼å¤„ç†
            long_key = "x" * 1000
            long_success = self.cache_manager.set_cache(long_key, "test_value")

def _test_api_data_integration_check_condition():
                logger.warning("  âš ï¸ è¶…é•¿é”®å€¼å¤„ç†å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•å¹¶å‘è®¿é—®
            async def concurrent_access():

def _test_api_data_integration_iterate_items():
                    self.cache_manager.set_cache(f"concurrent_{i}", f"value_{i}")
                    cached = self.cache_manager.get_cache(f"concurrent_{i}")

def _test_api_data_integration_iterate_items():
            print(f"\nğŸ” æ‰§è¡Œ {test_name}æµ‹è¯•...")
            self.test_results["total_tests"] += 1


def _test_api_data_integration_check_condition():
                    print(f"âœ… {test_name}æµ‹è¯•é€šè¿‡")
                    self.test_results["passed_tests"] += 1
                else:
                    print(f"âŒ {test_name}æµ‹è¯•å¤±è´¥")
                    self.test_results["failed_tests"] += 1
            except Exception as e:
                print(f"âŒ {test_name}æµ‹è¯•å¼‚å¸¸: {e}")
                self.test_results["failed_tests"] += 1
                self.test_results["errors"].append(f"{test_name}: {e}")

        end_time = datetime.now()
        duration = end_time - start_time

        # æ¸…ç†æµ‹è¯•æ•°æ®

def _test_api_data_integration_handle_error():
            self.cache_manager.clear_all()
            logger.info("âœ… æµ‹è¯•æ•°æ®æ¸…ç†å®Œæˆ")
        except Exception as e:
            logger.warning(f"âš ï¸ æµ‹è¯•æ•°æ®æ¸…ç†å¤±è´¥: {e}")

        print("\n" + "=" * 50)
        print("ğŸ“Š ç¬¬ä¸‰é˜¶æ®µç®€åŒ–æµ‹è¯•å®Œæˆ!")
        print(f"   æ€»è®¡: {self.test_results['total_tests']}")
        print(f"   é€šè¿‡: {self.test_results['passed_tests']}")
        print(f"   å¤±è´¥: {self.test_results['failed_tests']}")
        print(f"   è€—æ—¶: {duration.total_seconds():.2f} ç§’")


def _test_api_data_integration_iterate_items():
                print(f"   - {error}")

        success_rate = 0

def _test_api_data_integration_check_condition():
            success_rate = (
                self.test_results["passed_tests"] / self.test_results["total_tests"]
            ) * 100

        print(f"\nğŸ¯ æˆåŠŸç‡: {success_rate:.1f}%")


def _test_api_data_integration_check_condition():
            print("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼")
            print("âœ… åŸºç¡€ç¼“å­˜åŠŸèƒ½æ­£å¸¸")
            print("âœ… æ•°æ®ç»“æ„å®šä¹‰å®Œæ•´")
            print("âœ… APIæ•°æ®é›†æˆæˆåŠŸ")
            print("âœ… ç¼“å­˜æ€§èƒ½ç¬¦åˆé¢„æœŸ")
            print("âœ… é”™è¯¯å¤„ç†æœºåˆ¶æœ‰æ•ˆ")
            print("ğŸš€ ç¬¬ä¸‰é˜¶æ®µç®€åŒ–éªŒè¯å®Œæˆï¼")
            return True

def _test_api_data_integration_handle_error():
        # è¿è¡Œæ‰€æœ‰æµ‹è¯•
        success = await tester.run_all_tests()

        print(f"\né€€å‡ºç : {0 if success else 1}")
        return success

def _test_api_data_integration_check_condition():
    success = asyncio.run(main())
    sys.exit(0 if success else 1)


    async def test_api_data_integration(self) -> bool:
        """æµ‹è¯•APIæ•°æ®é›†æˆ"""
        _test_api_data_integration_handle_error()
            logger.info("æµ‹è¯•APIæ•°æ®é›†æˆ...")

            async with SimpleDataCollector() as collector:
                # æµ‹è¯•è”èµ›æ•°æ®é‡‡é›†å’Œç¼“å­˜
                competitions_data = await collector._make_request_with_retry(
                    "competitions"
                )
                if not competitions_data or "competitions" not in competitions_data:
                    raise Exception("APIæ•°æ®é‡‡é›†å¤±è´¥")

                competitions = competitions_data["competitions"]
                if len(competitions) == 0:
                    raise Exception("APIè¿”å›ç©ºæ•°æ®")

                # ç¼“å­˜è”èµ›æ•°æ®
                cache_key = "api:competitions"
                cache_success = self.cache_manager.set_cache(
                    cache_key, competitions, ttl_seconds=300
                )
                if not cache_success:
                    raise Exception("ç¼“å­˜APIæ•°æ®å¤±è´¥")

                # éªŒè¯ç¼“å­˜æ•°æ®
                cached_competitions = self.cache_manager.get_cache(cache_key)
                if not cached_competitions or len(cached_competitions) == 0:
                    raise Exception("ç¼“å­˜æ•°æ®éªŒè¯å¤±è´¥")

                logger.info(f"  âœ… APIæ•°æ®é‡‡é›†å’Œç¼“å­˜æˆåŠŸ: {len(competitions)} ä¸ªè”èµ›")

                # æµ‹è¯•çƒé˜Ÿæ•°æ®é‡‡é›†å’Œç¼“å­˜
                teams_data = await collector._make_request_with_retry(
                    "competitions/2021/teams"
                )
                if not teams_data or "teams" not in teams_data:
                    raise Exception("çƒé˜Ÿæ•°æ®é‡‡é›†å¤±è´¥")

                teams = teams_data["teams"]
                if len(teams) == 0:
                    raise Exception("çƒé˜Ÿæ•°æ®ä¸ºç©º")

                # ç¼“å­˜çƒé˜Ÿæ•°æ®
                teams_cache_key = "api:teams:2021"
                cache_success = self.cache_manager.set_cache(
                    teams_cache_key, teams, ttl_seconds=600
                )
                if not cache_success:
                    raise Exception("ç¼“å­˜çƒé˜Ÿæ•°æ®å¤±è´¥")

                logger.info(f"  âœ… çƒé˜Ÿæ•°æ®é‡‡é›†å’Œç¼“å­˜æˆåŠŸ: {len(teams)} æ”¯çƒé˜Ÿ")

                # æµ‹è¯•ç§¯åˆ†æ¦œæ•°æ®é‡‡é›†å’Œç¼“å­˜
                standings_data = await collector._make_request_with_retry(
                    "competitions/2021/standings"
                )
                if not standings_data or "standings" not in standings_data:
                    raise Exception("ç§¯åˆ†æ¦œæ•°æ®é‡‡é›†å¤±è´¥")

                standings = standings_data["standings"]
                if len(standings) == 0:
                    raise Exception("ç§¯åˆ†æ¦œæ•°æ®ä¸ºç©º")

                # ç¼“å­˜ç§¯åˆ†æ¦œæ•°æ®
                standings_cache_key = "api:standings:2021"
                cache_success = self.cache_manager.set_cache(
                    standings_cache_key, standings, ttl_seconds=1800
                )
                if not cache_success:
                    raise Exception("ç¼“å­˜ç§¯åˆ†æ¦œæ•°æ®å¤±è´¥")

                logger.info(
                    f"  âœ… ç§¯åˆ†æ¦œæ•°æ®é‡‡é›†å’Œç¼“å­˜æˆåŠŸ: {len(standings[0].get('table', []))} æ”¯çƒé˜Ÿ"
                )

                return True

        except Exception as e:
            logger.error(f"  âŒ APIæ•°æ®é›†æˆæµ‹è¯•å¤±è´¥: {e}")
            return False

    async def test_cache_performance(self) -> bool:
        """æµ‹è¯•ç¼“å­˜æ€§èƒ½"""
        _test_api_data_integration_handle_error()
            logger.info("æµ‹è¯•ç¼“å­˜æ€§èƒ½...")

            # å‡†å¤‡æµ‹è¯•æ•°æ®
            test_data = [
                {"id": i, "name": f"Team {i}", "points": i * 3} for i in range(1000)
            ]

            # æµ‹è¯•æ‰¹é‡å†™å…¥æ€§èƒ½
            start_time = datetime.utcnow()
            _test_api_data_integration_iterate_items()
                self.cache_manager.set_cache(f"team:{i}", data, ttl_seconds=3600)

            write_time = (datetime.utcnow() - start_time).total_seconds()
            logger.info(f"  âœ… æ‰¹é‡å†™å…¥1000æ¡æ•°æ®è€—æ—¶: {write_time:.3f}ç§’")

            # æµ‹è¯•æ‰¹é‡è¯»å–æ€§èƒ½
            start_time = datetime.utcnow()
            successful_reads = 0
            for i in range(1000):
                cached_data = self.cache_manager.get_cache(f"team:{i}")
                _test_api_data_integration_check_condition()
                    successful_reads += 1

            read_time = (datetime.utcnow() - start_time).total_seconds()
            logger.info(f"  âœ… æ‰¹é‡è¯»å–1000æ¡æ•°æ®è€—æ—¶: {read_time:.3f}ç§’")
            logger.info(
                f"  âœ… è¯»å–æˆåŠŸç‡: {successful_reads}/1000 ({successful_reads/10:.1f}%)"
            )

            # æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ
            cache_size = len(self.cache_manager.cache)
            logger.info(f"  âœ… ç¼“å­˜ä¸­åŒ…å« {cache_size} æ¡æ•°æ®")

            _test_api_data_integration_check_condition()
                logger.warning(f"  âš ï¸ å†™å…¥æ€§èƒ½è¾ƒæ…¢: {write_time:.3f}ç§’")

            _test_api_data_integration_check_condition()
                logger.warning(f"  âš ï¸ è¯»å–æ€§èƒ½è¾ƒæ…¢: {read_time:.3f}ç§’")

            return True

        except Exception as e:
            logger.error(f"  âŒ ç¼“å­˜æ€§èƒ½æµ‹è¯•å¤±è´¥: {e}")
            return False

    async def test_error_handling(self) -> bool:
        """æµ‹è¯•é”™è¯¯å¤„ç†"""
        _test_api_data_integration_handle_error()
            logger.info("æµ‹è¯•é”™è¯¯å¤„ç†...")

            # æµ‹è¯•æ— æ•ˆæ•°æ®ç±»å‹ç¼“å­˜
            invalid_data = object()  # ä¸å¯åºåˆ—åŒ–çš„å¯¹è±¡
            self.cache_manager.set_cache("invalid_test", invalid_data)
            # åº”è¯¥èƒ½å¤Ÿç¼“å­˜ï¼Œå› ä¸ºä½¿ç”¨çš„æ˜¯å†…å­˜ç¼“å­˜

            # æµ‹è¯•ç©ºé”®å€¼å¤„ç†
            empty_success = self.cache_manager.set_cache("", "test_value")
            _test_api_data_integration_check_condition()
                logger.warning("  âš ï¸ ç©ºé”®å€¼å¤„ç†å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•Noneå€¼ç¼“å­˜
            none_success = self.cache_manager.set_cache("none_test", None)
            _test_api_data_integration_check_condition()
                logger.warning("  âš ï¸ Noneå€¼ç¼“å­˜å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•è¶…é•¿é”®å€¼å¤„ç†
            long_key = "x" * 1000
            long_success = self.cache_manager.set_cache(long_key, "test_value")
            _test_api_data_integration_check_condition()
                logger.warning("  âš ï¸ è¶…é•¿é”®å€¼å¤„ç†å¯èƒ½æœ‰é—®é¢˜")

            # æµ‹è¯•å¹¶å‘è®¿é—®
            async def concurrent_access():
                _test_api_data_integration_iterate_items()
                    self.cache_manager.set_cache(f"concurrent_{i}", f"value_{i}")
                    cached = self.cache_manager.get_cache(f"concurrent_{i}")
                    if cached != f"value_{i}":
                        return False
                return True

            tasks = [concurrent_access() for _ in range(5)]
            results = await asyncio.gather(*tasks, return_exceptions=True)

            successful_concurrent = sum(1 for result in results if result is True)
            logger.info(f"  âœ… å¹¶å‘è®¿é—®æµ‹è¯•: {successful_concurrent}/5 æˆåŠŸ")

            return successful_concurrent >= 4  # è‡³å°‘80%çš„å¹¶å‘æµ‹è¯•æˆåŠŸ

        except Exception as e:
            logger.error(f"  âŒ é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: {e}")
            return False

    async def run_all_tests(self) -> bool:
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        print("ğŸš€ å¼€å§‹ç¬¬ä¸‰é˜¶æ®µç®€åŒ–æµ‹è¯•")
        print("=" * 50)

        start_time = datetime.now()

        tests = [
            ("åŸºç¡€ç¼“å­˜åŠŸèƒ½", self.test_basic_caching),
            ("æ•°æ®ç»“æ„", self.test_data_structures),
            ("APIæ•°æ®é›†æˆ", self.test_api_data_integration),
            ("ç¼“å­˜æ€§èƒ½", self.test_cache_performance),
            ("é”™è¯¯å¤„ç†", self.test_error_handling),
        ]

        _test_api_data_integration_iterate_items()
            print(f"\nğŸ” æ‰§è¡Œ {test_name}æµ‹è¯•...")
            self.test_results["total_tests"] += 1

            try:
                _test_api_data_integration_check_condition()
                    print(f"âœ… {test_name}æµ‹è¯•é€šè¿‡")
                    self.test_results["passed_tests"] += 1
                else:
                    print(f"âŒ {test_name}æµ‹è¯•å¤±è´¥")
                    self.test_results["failed_tests"] += 1
            except Exception as e:
                print(f"âŒ {test_name}æµ‹è¯•å¼‚å¸¸: {e}")
                self.test_results["failed_tests"] += 1
                self.test_results["errors"].append(f"{test_name}: {e}")

        end_time = datetime.now()
        duration = end_time - start_time

        # æ¸…ç†æµ‹è¯•æ•°æ®
        _test_api_data_integration_handle_error()
            self.cache_manager.clear_all()
            logger.info("âœ… æµ‹è¯•æ•°æ®æ¸…ç†å®Œæˆ")
        except Exception as e:
            logger.warning(f"âš ï¸ æµ‹è¯•æ•°æ®æ¸…ç†å¤±è´¥: {e}")

        print("\n" + "=" * 50)
        print("ğŸ“Š ç¬¬ä¸‰é˜¶æ®µç®€åŒ–æµ‹è¯•å®Œæˆ!")
        print(f"   æ€»è®¡: {self.test_results['total_tests']}")
        print(f"   é€šè¿‡: {self.test_results['passed_tests']}")
        print(f"   å¤±è´¥: {self.test_results['failed_tests']}")
        print(f"   è€—æ—¶: {duration.total_seconds():.2f} ç§’")

        if self.test_results["errors"]:
            print("\nâŒ é”™è¯¯è¯¦æƒ…:")
            _test_api_data_integration_iterate_items()
                print(f"   - {error}")

        success_rate = 0
        _test_api_data_integration_check_condition()
            success_rate = (
                self.test_results["passed_tests"] / self.test_results["total_tests"]
            ) * 100

        print(f"\nğŸ¯ æˆåŠŸç‡: {success_rate:.1f}%")

        _test_api_data_integration_check_condition()
            print("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼")
            print("âœ… åŸºç¡€ç¼“å­˜åŠŸèƒ½æ­£å¸¸")
            print("âœ… æ•°æ®ç»“æ„å®šä¹‰å®Œæ•´")
            print("âœ… APIæ•°æ®é›†æˆæˆåŠŸ")
            print("âœ… ç¼“å­˜æ€§èƒ½ç¬¦åˆé¢„æœŸ")
            print("âœ… é”™è¯¯å¤„ç†æœºåˆ¶æœ‰æ•ˆ")
            print("ğŸš€ ç¬¬ä¸‰é˜¶æ®µç®€åŒ–éªŒè¯å®Œæˆï¼")
            return True
        else:
            print("âš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®ç°")
            return False


async def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    tester = Stage3SimpleTester()

    _test_api_data_integration_handle_error()
        # è¿è¡Œæ‰€æœ‰æµ‹è¯•
        success = await tester.run_all_tests()

        print(f"\né€€å‡ºç : {0 if success else 1}")
        return success

    except Exception as e:
        logger.error(f"æµ‹è¯•æ‰§è¡Œå¤±è´¥: {e}")
        print(f"\nâŒ æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {e}")
        return False


_test_api_data_integration_check_condition()
    success = asyncio.run(main())
    sys.exit(0 if success else 1)
