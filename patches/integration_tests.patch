diff --git a/src/database/compat.py b/src/database/compat.py
new file mode 100644
index 000000000..b4f731bf2
--- /dev/null
+++ b/src/database/compat.py
@@ -0,0 +1,202 @@
+"""
+数据库兼容适配器（临时过渡用）
+Database Compatibility Adapter (Temporary Migration Helper)
+
+⚠️ 注意：这是临时适配器，用于逐步迁移到异步接口
+⚠️ WARNING: This is a temporary adapter for gradual migration to async interfaces
+
+使用方法：
+1. 短期：直接替换 import 语句
+   from src.database.compat import fetch_all_sync, fetch_one_sync, execute_sync
+
+2. 中期：逐步将函数改为 async
+   async def my_function():
+       result = await fetch_all(query, params)
+
+3. 长期：完全迁移到 async_manager.py
+   from src.database.async_manager import fetch_all
+"""
+
+import asyncio
+import logging
+from typing import Any, Optional, Dict, List
+from sqlalchemy import text
+
+from .async_manager import fetch_all, fetch_one, execute
+
+logger = logging.getLogger(__name__)
+
+
+def fetch_all_sync(query, params: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
+    """
+    同步版本的 fetch_all（适配器）
+
+    Args:
+        query: SQL查询语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        查询结果列表
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 fetch_all_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, fetch_all(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(fetch_all(query, params))
+
+
+def fetch_one_sync(query, params: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, Any]]:
+    """
+    同步版本的 fetch_one（适配器）
+
+    Args:
+        query: SQL查询语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        单个查询结果字典或None
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 fetch_one_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, fetch_one(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(fetch_one(query, params))
+
+
+def execute_sync(query, params: Optional[Dict[str, Any]] = None) -> Any:
+    """
+    同步版本的 execute（适配器）
+
+    Args:
+        query: SQL语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        执行结果
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 execute_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, execute(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(execute(query, params))
+
+
+# ============================================================================
+# 向后兼容的包装函数（用于最常见的场景）
+# ============================================================================
+
+class DatabaseCompatManager:
+    """
+    数据库兼容管理器
+
+    提供与旧 DatabaseManager 类似的接口，但内部使用新的异步实现
+    临时用于减少迁移风险
+    """
+
+    def __init__(self):
+        """初始化兼容管理器"""
+        logger.warning("⚠️ 使用 DatabaseCompatManager，建议迁移到 AsyncDatabaseManager")
+
+    def get_session(self):
+        """获取数据库会话（同步接口 - 临时兼容）"""
+        logger.warning("⚠️ get_session() 同步接口已弃用，请改为异步实现")
+        # 返回一个兼容的会话包装器
+        return SyncSessionWrapper()
+
+
+class SyncSessionWrapper:
+    """
+    同步会话包装器（临时兼容用）
+
+    提供类似旧版同步会话的接口，但内部使用异步实现
+    """
+
+    def __init__(self):
+        self._closed = False
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+
+    def execute(self, query, params=None):
+        """执行查询（同步包装）"""
+        if isinstance(query, str):
+            query = text(query)
+        return execute_sync(query, params)
+
+    def fetchall(self, query, params=None):
+        """获取所有结果（同步包装）"""
+        return fetch_all_sync(query, params)
+
+    def fetchone(self, query, params=None):
+        """获取单个结果（同步包装）"""
+        return fetch_one_sync(query, params)
+
+    def close(self):
+        """关闭会话"""
+        self._closed = True
+        logger.debug("SyncSessionWrapper 已关闭")
+
+    def commit(self):
+        """提交事务（兼容方法）"""
+        logger.debug("SyncSessionWrapper commit (兼容方法)")
+
+    def rollback(self):
+        """回滚事务（兼容方法）"""
+        logger.debug("SyncSessionWrapper rollback (兼容方法)")
+
+
+# 导出接口
+__all__ = [
+    # 主要适配器函数
+    "fetch_all_sync",
+    "fetch_one_sync",
+    "execute_sync",
+    # 兼容管理器类
+    "DatabaseCompatManager",
+    "SyncSessionWrapper",
+]
\ No newline at end of file
diff --git a/tests/integration/test_db_integration.py b/tests/integration/test_db_integration.py
new file mode 100644
index 000000000..02c0a5141
--- /dev/null
+++ b/tests/integration/test_db_integration.py
@@ -0,0 +1,571 @@
+"""
+数据库集成测试
+Database Integration Tests
+
+测试新的异步数据库接口与实际PostgreSQL数据库的集成
+使用Docker Compose环境运行
+"""
+
+import pytest
+import asyncio
+import os
+from typing import Dict, Any, Optional
+from sqlalchemy import text, create_engine, MetaData
+from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
+from unittest.mock import patch
+
+from src.database.async_manager import (
+    initialize_database,
+    get_database_manager,
+    get_db_session,
+    fetch_all,
+    fetch_one,
+    execute,
+    AsyncDatabaseManager
+)
+
+
+class TestDatabaseIntegration:
+    """数据库集成测试类"""
+
+    @pytest.fixture(scope="class", autouse=True)
+    async def setup_database(self):
+        """设置集成测试数据库环境"""
+        # 检查环境变量
+        db_url = os.getenv("DATABASE_URL")
+        if not db_url:
+            pytest.skip("DATABASE_URL 环境变量未设置，跳过集成测试")
+
+        # 如果是同步URL，转换为异步URL
+        if "postgresql://" in db_url and "+asyncpg" not in db_url:
+            db_url = db_url.replace("postgresql://", "postgresql+asyncpg://")
+
+        # 初始化数据库
+        initialize_database(db_url)
+
+        # 创建测试表
+        await self._create_test_tables()
+
+        yield db_url
+
+        # 清理
+        await self._cleanup_test_tables()
+
+    async def _create_test_tables(self):
+        """创建测试表"""
+        async with get_db_session() as session:
+            # 创建测试用户表
+            await session.execute(text("""
+                CREATE TABLE IF NOT EXISTS integration_test_users (
+                    id SERIAL PRIMARY KEY,
+                    username VARCHAR(50) UNIQUE NOT NULL,
+                    email VARCHAR(100) UNIQUE NOT NULL,
+                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+                    is_active BOOLEAN DEFAULT TRUE
+                )
+            """))
+
+            # 创建测试比赛表
+            await session.execute(text("""
+                CREATE TABLE IF NOT EXISTS integration_test_matches (
+                    id SERIAL PRIMARY KEY,
+                    home_team VARCHAR(100) NOT NULL,
+                    away_team VARCHAR(100) NOT NULL,
+                    match_date TIMESTAMP,
+                    competition VARCHAR(50),
+                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
+                )
+            """))
+
+            # 创建测试预测表
+            await session.execute(text("""
+                CREATE TABLE IF NOT EXISTS integration_test_predictions (
+                    id SERIAL PRIMARY KEY,
+                    match_id INTEGER REFERENCES integration_test_matches(id),
+                    predicted_home_score INTEGER,
+                    predicted_away_score INTEGER,
+                    confidence DECIMAL(5,4),
+                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
+                )
+            """))
+
+            await session.commit()
+
+    async def _cleanup_test_tables(self):
+        """清理测试表"""
+        try:
+            async with get_db_session() as session:
+                # 按依赖关系删除表
+                await session.execute(text("DROP TABLE IF EXISTS integration_test_predictions CASCADE"))
+                await session.execute(text("DROP TABLE IF EXISTS integration_test_matches CASCADE"))
+                await session.execute(text("DROP TABLE IF EXISTS integration_test_users CASCADE"))
+                await session.commit()
+        except Exception as e:
+            print(f"清理测试表时出错: {e}")
+
+    async def test_database_connection(self, setup_database):
+        """测试数据库连接"""
+        manager = get_database_manager()
+
+        # 检查管理器是否已初始化
+        assert manager.is_initialized, "数据库管理器应该已初始化"
+
+        # 检查连接健康状态
+        status = await manager.check_connection()
+        assert status["status"] == "healthy", f"数据库连接应该健康: {status}"
+        assert status["response_time_ms"] is not None, "应该有响应时间"
+
+    async def test_session_context_manager(self, setup_database):
+        """测试会话上下文管理器"""
+        async with get_db_session() as session:
+            assert isinstance(session, AsyncSession), "应该返回AsyncSession实例"
+            assert session.is_active, "会话应该是活跃状态"
+
+            # 执行简单查询
+            result = await session.execute(text("SELECT 1 as test_value"))
+            row = result.fetchone()
+            assert row["test_value"] == 1, "基本查询应该工作"
+
+        # 会话应该自动关闭
+        assert not session.is_active, "会话应该已关闭"
+
+    async def test_crud_operations(self, setup_database):
+        """测试CRUD操作"""
+        # 创建用户
+        await execute(
+            text("""
+                INSERT INTO integration_test_users (username, email, is_active)
+                VALUES (:username, :email, :is_active)
+                RETURNING id, username, email
+            """),
+            {
+                "username": "testuser1",
+                "email": "testuser1@example.com",
+                "is_active": True
+            }
+        )
+
+        # 读取用户
+        user = await fetch_one(
+            text("SELECT * FROM integration_test_users WHERE username = :username"),
+            {"username": "testuser1"}
+        )
+
+        assert user is not None, "用户应该被创建"
+        assert user["username"] == "testuser1", "用户名应该正确"
+        assert user["email"] == "testuser1@example.com", "邮箱应该正确"
+        assert user["is_active"] is True, "状态应该正确"
+
+        # 更新用户
+        await execute(
+            text("UPDATE integration_test_users SET email = :new_email WHERE username = :username"),
+            {"username": "testuser1", "new_email": "updated@example.com"}
+        )
+
+        # 验证更新
+        updated_user = await fetch_one(
+            text("SELECT * FROM integration_test_users WHERE username = :username"),
+            {"username": "testuser1"}
+        )
+        assert updated_user["email"] == "updated@example.com", "邮箱应该已更新"
+
+        # 删除用户
+        await execute(
+            text("DELETE FROM integration_test_users WHERE username = :username"),
+            {"username": "testuser1"}
+        )
+
+        # 验证删除
+        deleted_user = await fetch_one(
+            text("SELECT * FROM integration_test_users WHERE username = :username"),
+            {"username": "testuser1"}
+        )
+        assert deleted_user is None, "用户应该被删除"
+
+    async def test_batch_operations(self, setup_database):
+        """测试批量操作"""
+        # 批量插入用户
+        users_data = [
+            {"username": f"user{i}", "email": f"user{i}@example.com", "is_active": i % 2 == 0}
+            for i in range(1, 6)
+        ]
+
+        await execute(
+            text("""
+                INSERT INTO integration_test_users (username, email, is_active)
+                VALUES (:username, :email, :is_active)
+            """),
+            users_data
+        )
+
+        # 验证批量插入
+        all_users = await fetch_all(
+            text("SELECT * FROM integration_test_users WHERE username LIKE 'user%' ORDER BY username")
+        )
+
+        assert len(all_users) == 5, "应该插入5个用户"
+        assert all_users[0]["username"] == "user1", "用户应该按顺序插入"
+
+        # 验证数据完整性
+        active_users = await fetch_all(
+            text("SELECT COUNT(*) as count FROM integration_test_users WHERE is_active = TRUE AND username LIKE 'user%'")
+        )
+        assert active_users[0]["count"] == 2, "应该有2个活跃用户"
+
+    async def test_transaction_isolation(self, setup_database):
+        """测试事务隔离"""
+        # 创建测试匹配
+        await execute(
+            text("""
+                INSERT INTO integration_test_matches (home_team, away_team, competition)
+                VALUES ('Team A', 'Team B', 'Premier League')
+                RETURNING id
+            """)
+        )
+
+        # 获取匹配ID
+        match = await fetch_one(
+            text("SELECT id FROM integration_test_matches WHERE home_team = 'Team A'")
+        )
+        match_id = match["id"]
+
+        # 测试成功事务
+        async with get_db_session() as session:
+            try:
+                await session.execute(
+                    text("""
+                        INSERT INTO integration_test_predictions
+                        (match_id, predicted_home_score, predicted_away_score, confidence)
+                        VALUES (:match_id, :home_score, :away_score, :confidence)
+                    """),
+                    {
+                        "match_id": match_id,
+                        "home_score": 2,
+                        "away_score": 1,
+                        "confidence": 0.85
+                    }
+                )
+                await session.commit()
+            except Exception as e:
+                await session.rollback()
+                raise
+
+        # 验证事务提交
+        prediction = await fetch_one(
+            text("SELECT * FROM integration_test_predictions WHERE match_id = :match_id"),
+            {"match_id": match_id}
+        )
+        assert prediction is not None, "预测应该被提交"
+        assert prediction["predicted_home_score"] == 2, "预测应该正确"
+
+        # 测试回滚事务
+        async with get_db_session() as session:
+            try:
+                await session.execute(
+                    text("""
+                        INSERT INTO integration_test_predictions
+                        (match_id, predicted_home_score, predicted_away_score, confidence)
+                        VALUES (:match_id, :home_score, :away_score, :confidence)
+                    """),
+                    {
+                        "match_id": match_id,
+                        "home_score": 1,
+                        "away_score": 2,
+                        "confidence": 0.75
+                    }
+                )
+
+                # 故意引发错误
+                raise Exception("测试事务回滚")
+            except Exception:
+                await session.rollback()
+                # 期望的回滚
+
+        # 验证回滚
+        predictions = await fetch_all(
+            text("SELECT * FROM integration_test_predictions WHERE match_id = :match_id AND predicted_home_score = 1"),
+            {"match_id": match_id}
+        )
+        assert len(predictions) == 0, "回滚的预测不应该存在"
+
+    async def test_complex_join_query(self, setup_database):
+        """测试复杂连接查询"""
+        # 插入测试数据
+        # 插入匹配
+        await execute(
+            text("""
+                INSERT INTO integration_test_matches (home_team, away_team, competition) VALUES
+                ('Manchester United', 'Liverpool', 'Premier League'),
+                ('Chelsea', 'Arsenal', 'Premier League'),
+                ('Barcelona', 'Real Madrid', 'La Liga')
+            """)
+        )
+
+        # 插入预测
+        await execute(
+            text("""
+                INSERT INTO integration_test_predictions (match_id, predicted_home_score, predicted_away_score, confidence)
+                SELECT id, 2, 1, 0.85 FROM integration_test_matches WHERE home_team = 'Manchester United'
+                UNION ALL
+                SELECT id, 1, 1, 0.60 FROM integration_test_matches WHERE home_team = 'Chelsea'
+                UNION ALL
+                SELECT id, 3, 2, 0.75 FROM integration_test_matches WHERE home_team = 'Barcelona'
+            """)
+        )
+
+        # 复杂连接查询
+        results = await fetch_all(text("""
+            SELECT
+                m.home_team,
+                m.away_team,
+                m.competition,
+                p.predicted_home_score,
+                p.predicted_away_score,
+                p.confidence,
+                p.created_at as prediction_time
+            FROM integration_test_matches m
+            JOIN integration_test_predictions p ON m.id = p.match_id
+            ORDER BY p.confidence DESC
+        """))
+
+        assert len(results) == 3, "应该有3个预测结果"
+        assert results[0]["confidence"] == 0.85, "最高置信度应该是0.85"
+        assert results[0]["home_team"] == "Manchester United", "最高置信度的预测应该是曼联"
+
+    async def test_performance_benchmarks(self, setup_database):
+        """测试性能基准"""
+        import time
+
+        # 测试插入性能
+        start_time = time.time()
+
+        batch_data = [
+            {"username": f"perf_user_{i}", "email": f"perf_user_{i}@example.com", "is_active": True}
+            for i in range(100)
+        ]
+
+        await execute(
+            text("INSERT INTO integration_test_users (username, email, is_active) VALUES (:username, :email, :is_active)"),
+            batch_data
+        )
+
+        insert_time = time.time() - start_time
+
+        # 测试查询性能
+        start_time = time.time()
+
+        results = await fetch_all(text("""
+            SELECT * FROM integration_test_users
+            WHERE username LIKE 'perf_user_%'
+            ORDER BY id
+        """))
+
+        query_time = time.time() - start_time
+
+        # 性能断言
+        assert len(results) == 100, "应该插入100条记录"
+        assert insert_time < 5.0, f"批量插入应该在5秒内完成，实际耗时: {insert_time:.2f}秒"
+        assert query_time < 1.0, f"查询应该在1秒内完成，实际耗时: {query_time:.2f}秒"
+
+    async def test_connection_pool(self, setup_database):
+        """测试连接池"""
+        manager = get_database_manager()
+        engine = manager.engine
+
+        # 获取连接池状态（如果支持）
+        if hasattr(engine.pool, 'size'):
+            pool_size = engine.pool.size()
+            assert pool_size > 0, "连接池应该有可用连接"
+
+    async def test_database_schema_validation(self, setup_database):
+        """测试数据库模式验证"""
+        async with get_db_session() as session:
+            # 检查表是否存在
+            tables = await fetch_all(text("""
+                SELECT table_name
+                FROM information_schema.tables
+                WHERE table_schema = 'public'
+                AND table_name LIKE 'integration_test_%'
+                ORDER BY table_name
+            """))
+
+            expected_tables = {
+                'integration_test_matches',
+                'integration_test_predictions',
+                'integration_test_users'
+            }
+
+            found_tables = {table['table_name'] for table in tables}
+            assert expected_tables.issubset(found_tables), f"应该包含所有测试表，找到: {found_tables}"
+
+            # 检查表结构
+            users_columns = await fetch_all(text("""
+                SELECT column_name, data_type, is_nullable
+                FROM information_schema.columns
+                WHERE table_name = 'integration_test_users'
+                ORDER BY ordinal_position
+            """))
+
+            expected_columns = {'id', 'username', 'email', 'created_at', 'is_active'}
+            found_columns = {col['column_name'] for col in users_columns}
+            assert expected_columns.issubset(found_columns), f"用户表应该包含所有期望的列，找到: {found_columns}"
+
+
+class TestRealWorldScenarios:
+    """真实世界场景测试"""
+
+    async def test_football_prediction_workflow(self, setup_database):
+        """测试足球预测工作流"""
+        # 1. 创建比赛数据
+        await execute(
+            text("""
+                INSERT INTO integration_test_matches (home_team, away_team, competition, match_date)
+                VALUES
+                ('Real Madrid', 'Barcelona', 'La Liga', '2024-01-15 20:00:00'),
+                ('Manchester City', 'Liverpool', 'Premier League', '2024-01-16 15:00:00'),
+                ('Bayern Munich', 'Borussia Dortmund', 'Bundesliga', '2024-01-17 18:30:00')
+                RETURNING id, home_team, away_team
+            """)
+        )
+
+        # 2. 创建预测数据（模拟预测算法）
+        matches = await fetch_all(
+            text("SELECT id, home_team, away_team FROM integration_test_matches ORDER BY id")
+        )
+
+        predictions = []
+        for match in matches:
+            # 模拟预测逻辑
+            predicted_home = 2
+            predicted_away = 1
+            confidence = 0.75 + (len(match['home_team']) % 3) * 0.1  # 模拟置信度变化
+
+            await execute(
+                text("""
+                    INSERT INTO integration_test_predictions
+                    (match_id, predicted_home_score, predicted_away_score, confidence)
+                    VALUES (:match_id, :home_score, :away_score, :confidence)
+                """),
+                {
+                    "match_id": match["id"],
+                    "home_score": predicted_home,
+                    "away_score": predicted_away,
+                    "confidence": min(confidence, 0.95)  # 确保不超过0.95
+                }
+            )
+            predictions.append({
+                "match_id": match["id"],
+                "predicted_home_score": predicted_home,
+                "predicted_away_score": predicted_away,
+                "confidence": min(confidence, 0.95)
+            })
+
+        # 3. 验证预测结果
+        stored_predictions = await fetch_all(
+            text("""
+                SELECT m.home_team, m.away_team, p.predicted_home_score, p.predicted_away_score, p.confidence
+                FROM integration_test_matches m
+                JOIN integration_test_predictions p ON m.id = p.match_id
+                ORDER BY p.confidence DESC
+            """)
+        )
+
+        assert len(stored_predictions) == 3, "应该有3个预测记录"
+        assert stored_predictions[0]["confidence"] >= 0.85, "最高置信度应该≥0.85"
+
+        # 4. 模拟预测分析
+        avg_confidence = sum(p["confidence"] for p in predictions) / len(predictions)
+        home_wins = sum(1 for p in predictions if p["predicted_home_score"] > p["predicted_away_score"])
+
+        assert 0.7 <= avg_confidence <= 0.9, "平均置信度应该在合理范围"
+        assert home_wins > 0, "应该有主队获胜的预测"
+
+    async def test_data_migration_scenario(self, setup_database):
+        """测试数据迁移场景"""
+        # 1. 模拟旧表结构
+        await execute(text("""
+            CREATE TABLE IF NOT EXISTS old_users (
+                id SERIAL PRIMARY KEY,
+                name VARCHAR(100),
+                contact_info TEXT
+            )
+        """))
+
+        # 2. 插入旧数据
+        await execute(
+            text("""
+                INSERT INTO old_users (name, contact_info) VALUES
+                ('Alice', 'alice@old.com'),
+                ('Bob', 'bob@old.com'),
+                ('Charlie', 'charlie@old.com')
+            """)
+        )
+
+        # 3. 数据迁移 - 从旧表迁移到新表
+        await execute(text("""
+            INSERT INTO integration_test_users (username, email, is_active)
+            SELECT
+                LOWER(REPLACE(name, ' ', '_')),
+                contact_info,
+                TRUE
+            FROM old_users
+            WHERE contact_info LIKE '%@%'
+        """))
+
+        # 4. 验证迁移结果
+        migrated_users = await fetch_all(text("""
+            SELECT username, email, is_active
+            FROM integration_test_users
+            WHERE username IN ('alice', 'bob', 'charlie')
+            ORDER BY username
+        """))
+
+        assert len(migrated_users) == 3, "应该迁移3个用户"
+        assert migrated_users[0]["username"] == "alice", "用户名应该正确转换"
+        assert migrated_users[0]["email"] == "alice@old.com", "邮箱应该正确迁移"
+
+        # 5. 清理旧表（模拟迁移完成）
+        await execute(text("DROP TABLE old_users"))
+
+    async def test_concurrent_operations(self, setup_database):
+        """测试并发操作"""
+        import asyncio
+
+        async def insert_user_batch(start_id: int, count: int):
+            """批量插入用户的并发任务"""
+            users = [
+                {"username": f"concurrent_user_{start_id + i}",
+                 "email": f"concurrent_user_{start_id + i}@example.com",
+                 "is_active": True}
+                for i in range(count)
+            ]
+
+            await execute(
+                text("INSERT INTO integration_test_users (username, email, is_active) VALUES (:username, :email, :is_active)"),
+                users
+            )
+
+        # 并发执行多个批量插入任务
+        tasks = [
+            insert_user_batch(0, 20),
+            insert_user_batch(20, 20),
+            insert_user_batch(40, 20),
+            insert_user_batch(60, 20)
+        ]
+
+        await asyncio.gather(*tasks)
+
+        # 验证并发插入结果
+        total_users = await fetch_one(text("""
+            SELECT COUNT(*) as count
+            FROM integration_test_users
+            WHERE username LIKE 'concurrent_user_%'
+        """))
+
+        assert total_users["count"] == 80, "并发插入应该成功创建80个用户"
+
+
+# 测试标记
+pytest.mark.integration = pytest.mark.integration
+pytest.mark.database = pytest.mark.database
+pytest.mark.asyncio = pytest.mark.asyncio
\ No newline at end of file
diff --git a/tests/unit/test_async_manager.py b/tests/unit/test_async_manager.py
new file mode 100644
index 000000000..0ed271f0e
--- /dev/null
+++ b/tests/unit/test_async_manager.py
@@ -0,0 +1,460 @@
+"""
+异步数据库管理器单元测试
+Unit Tests for Async Database Manager
+
+测试新的异步数据库接口的正确性、性能和边界情况
+"""
+
+import pytest
+import asyncio
+from unittest.mock import AsyncMock, MagicMock, patch
+from sqlalchemy import text, create_engine
+from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
+from typing import Dict, Any, Optional
+
+from src.database.async_manager import (
+    AsyncDatabaseManager,
+    initialize_database,
+    get_database_manager,
+    get_db_session,
+    fetch_all,
+    fetch_one,
+    execute,
+    DatabaseRole
+)
+
+
+class TestAsyncDatabaseManager:
+    """异步数据库管理器测试类"""
+
+    @pytest.fixture
+    async def test_db_url(self):
+        """测试数据库URL"""
+        return "sqlite+aiosqlite:///:memory:"
+
+    @pytest.fixture
+    async def postgres_db_url(self):
+        """PostgreSQL测试数据库URL（用于连接池测试）"""
+        return "postgresql+asyncpg://postgres:postgres@localhost:5432/test_football_prediction"
+
+    @pytest.fixture
+    async def db_manager(self, test_db_url):
+        """创建测试数据库管理器实例"""
+        manager = AsyncDatabaseManager()
+        # SQLite不支持连接池参数，使用简单配置
+        manager.initialize(test_db_url, echo=False, pool_size=None)
+        yield manager
+        # 清理
+        await manager.close()
+
+    async def test_singleton_pattern(self, test_db_url):
+        """测试单例模式"""
+        manager1 = AsyncDatabaseManager()
+        manager2 = AsyncDatabaseManager()
+
+        assert manager1 is manager2, "应该返回同一个实例"
+
+        # 初始化后应该是同一个实例
+        manager1.initialize(test_db_url)
+        manager3 = AsyncDatabaseManager()
+        assert manager1 is manager3, "初始化后仍应该是同一个实例"
+
+    async def test_initialization(self, test_db_url):
+        """测试初始化"""
+        manager = AsyncDatabaseManager()
+
+        # 初始化前
+        assert not manager.is_initialized, "初始化前应该是未初始化状态"
+
+        # 初始化
+        manager.initialize(test_db_url)
+
+        # 初始化后
+        assert manager.is_initialized, "初始化后应该是已初始化状态"
+        assert manager.engine is not None, "引擎应该存在"
+        assert manager.session_factory is not None, "会话工厂应该存在"
+
+    async def test_duplicate_initialization_warning(self, test_db_url, caplog):
+        """测试重复初始化警告"""
+        manager = AsyncDatabaseManager()
+        manager.initialize(test_db_url)
+
+        # 第二次初始化应该产生警告
+        with caplog.at_level("WARNING"):
+            manager.initialize(test_db_url)
+
+        assert "已经初始化" in caplog.text, "应该记录重复初始化警告"
+
+    async def test_connection_check(self, db_manager):
+        """测试连接检查"""
+        # 健康连接
+        status = await db_manager.check_connection()
+        assert status["status"] == "healthy", "连接应该是健康的"
+        assert status["response_time_ms"] is not None, "应该有响应时间"
+        assert status["database_url"] is not None, "应该有数据库URL"
+
+    async def test_connection_check_uninitialized(self):
+        """测试未初始化连接检查"""
+        manager = AsyncDatabaseManager()
+
+        status = await manager.check_connection()
+        assert status["status"] == "error", "未初始化应该是错误状态"
+        assert "未初始化" in status["message"], "错误消息应该包含未初始化"
+
+    async def test_url_conversion(self):
+        """测试URL自动转换"""
+        manager = AsyncDatabaseManager()
+
+        # 测试 postgresql → postgresql+asyncpg
+        manager.initialize("postgresql://user:pass@localhost/db")
+        assert "+asyncpg" in manager._database_url, "应该自动转换为异步URL"
+
+        # 测试 sqlite → sqlite+aiosqlite
+        manager = AsyncDatabaseManager()  # 重置
+        manager.initialize("sqlite:///test.db")
+        assert "+aiosqlite" in manager._database_url, "应该自动转换为异步SQLite URL"
+
+    async def test_engine_configuration(self, test_db_url):
+        """测试引擎配置"""
+        manager = AsyncDatabaseManager()
+
+        custom_config = {
+            "pool_size": 5,
+            "max_overflow": 10,
+            "echo": True
+        }
+
+        manager.initialize(test_db_url, **custom_config)
+
+        # 验证配置是否应用（通过引擎属性检查）
+        engine = manager.engine
+        assert engine.pool.size() == 5, "连接池大小应该正确设置"
+        # 注意：其他配置可能需要通过其他方式验证
+
+
+class TestGlobalFunctions:
+    """全局函数测试类"""
+
+    @pytest.fixture
+    async def setup_database(self):
+        """设置测试数据库"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+    async def test_initialize_database(self, setup_database):
+        """测试全局初始化函数"""
+        manager = get_database_manager()
+        assert manager.is_initialized, "全局初始化应该成功"
+
+    async def test_get_database_manager_uninitialized(self):
+        """测试未初始化时获取管理器"""
+        # 创建新的管理器实例（未初始化）
+        from src.database.async_manager import _db_manager
+        _db_manager._initialized = False
+
+        with pytest.raises(RuntimeError, match="未初始化"):
+            get_database_manager()
+
+    async def test_get_db_session_context_manager(self, setup_database):
+        """测试数据库会话上下文管理器"""
+        async with get_db_session() as session:
+            assert isinstance(session, AsyncSession), "应该返回AsyncSession实例"
+            assert session.is_active, "会话应该是活跃状态"
+
+        # 会话应该自动关闭
+        assert not session.is_active, "会话应该已关闭"
+
+    async def test_get_db_session_error_handling(self, setup_database):
+        """测试会话错误处理"""
+        with patch('src.database.async_manager.get_database_manager') as mock_get_manager:
+            mock_session = AsyncMock()
+            mock_session.execute.side_effect = Exception("Test error")
+
+            mock_manager = AsyncMock()
+            mock_manager.session_factory.return_value.__aenter__.return_value = mock_session
+            mock_get_manager.return_value = mock_manager
+
+            with pytest.raises(Exception, match="Test error"):
+                async with get_db_session() as session:
+                    await session.execute(text("SELECT 1"))
+
+            # 验证回滚被调用
+            mock_session.rollback.assert_called_once()
+
+
+class TestConvenienceMethods:
+    """便捷方法测试类"""
+
+    @pytest.fixture
+    async def test_db_with_data(self):
+        """创建包含测试数据的数据库"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_users (
+                    id INTEGER PRIMARY KEY,
+                    name TEXT NOT NULL,
+                    email TEXT UNIQUE
+                )
+            """))
+            await session.commit()
+
+        yield test_url
+
+    async def test_fetch_all_success(self, test_db_with_data):
+        """测试 fetch_all 成功案例"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com'),
+                ('Bob', 'bob@test.com')
+            """))
+            await session.commit()
+
+        # 测试 fetch_all
+        results = await fetch_all(text("SELECT * FROM test_users"))
+
+        assert len(results) == 2, "应该返回2条记录"
+        assert results[0]["name"] == "Alice", "第一条记录应该是Alice"
+        assert results[1]["name"] == "Bob", "第二条记录应该是Bob"
+
+    async def test_fetch_all_with_params(self, test_db_with_data):
+        """测试 fetch_all 带参数"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com'),
+                ('Bob', 'bob@test.com')
+            """))
+            await session.commit()
+
+        # 测试带参数的查询
+        results = await fetch_all(
+            text("SELECT * FROM test_users WHERE name = :name"),
+            {"name": "Alice"}
+        )
+
+        assert len(results) == 1, "应该返回1条记录"
+        assert results[0]["email"] == "alice@test.com", "邮箱应该正确"
+
+    async def test_fetch_all_empty_result(self, test_db_with_data):
+        """测试 fetch_all 空结果"""
+        results = await fetch_all(text("SELECT * FROM test_users WHERE 1=0"))
+        assert results == [], "空表查询应该返回空列表"
+
+    async def test_fetch_one_success(self, test_db_with_data):
+        """测试 fetch_one 成功案例"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com')
+            """))
+            await session.commit()
+
+        # 测试 fetch_one
+        result = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Alice'"))
+
+        assert result is not None, "应该返回结果"
+        assert result["name"] == "Alice", "名称应该是Alice"
+        assert result["email"] == "alice@test.com", "邮箱应该正确"
+
+    async def test_fetch_one_not_found(self, test_db_with_data):
+        """测试 fetch_one 未找到"""
+        result = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Nonexistent'"))
+        assert result is None, "未找到应该返回None"
+
+    async def test_execute_insert(self, test_db_with_data):
+        """测试 execute 插入操作"""
+        result = await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Charlie", "email": "charlie@test.com"}
+        )
+
+        # 验证插入成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Charlie'"))
+        assert user is not None, "用户应该被插入"
+        assert user["email"] == "charlie@test.com", "邮箱应该正确"
+
+    async def test_execute_update(self, test_db_with_data):
+        """测试 execute 更新操作"""
+        # 插入初始数据
+        await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Dave", "email": "dave@old.com"}
+        )
+
+        # 更新数据
+        await execute(
+            text("UPDATE test_users SET email = :new_email WHERE name = :name"),
+            {"name": "Dave", "new_email": "dave@new.com"}
+        )
+
+        # 验证更新成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Dave'"))
+        assert user["email"] == "dave@new.com", "邮箱应该被更新"
+
+    async def test_execute_delete(self, test_db_with_data):
+        """测试 execute 删除操作"""
+        # 插入初始数据
+        await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Eve", "email": "eve@test.com"}
+        )
+
+        # 删除数据
+        await execute(text("DELETE FROM test_users WHERE name = 'Eve'"))
+
+        # 验证删除成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Eve'"))
+        assert user is None, "用户应该被删除"
+
+    async def test_string_queries(self, test_db_with_data):
+        """测试字符串SQL查询"""
+        # 插入测试数据
+        await execute(
+            "INSERT INTO test_users (name, email) VALUES (?, ?)",
+            {"name": "Frank", "email": "frank@test.com"}
+        )
+
+        # 使用字符串查询
+        result = await fetch_one("SELECT * FROM test_users WHERE name = 'Frank'")
+        assert result is not None, "应该找到Frank"
+        assert result["email"] == "frank@test.com", "邮箱应该正确"
+
+
+class TestErrorHandling:
+    """错误处理测试类"""
+
+    async def test_database_connection_error(self):
+        """测试数据库连接错误"""
+        with pytest.raises(Exception):
+            # 使用无效的数据库URL
+            manager = AsyncDatabaseManager()
+            manager.initialize("sqlite+aiosqlite:///invalid/path/test.db")
+            await manager.check_connection()
+
+    async def test_sql_syntax_error(self):
+        """测试SQL语法错误"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        with pytest.raises(Exception):
+            await fetch_one(text("INVALID SQL QUERY"))
+
+    async def test_constraint_violation(self):
+        """测试约束违反"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建带唯一约束的表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_unique (
+                    id INTEGER PRIMARY KEY,
+                    email TEXT UNIQUE NOT NULL
+                )
+            """))
+            await session.commit()
+
+        # 插入第一条记录
+        await execute(
+            text("INSERT INTO test_unique (email) VALUES (:email)"),
+            {"email": "test@example.com"}
+        )
+
+        # 尝试插入重复记录应该失败
+        with pytest.raises(Exception):
+            await execute(
+                text("INSERT INTO test_unique (email) VALUES (:email)"),
+                {"email": "test@example.com"}
+            )
+
+
+class TestPerformance:
+    """性能测试类"""
+
+    async def test_concurrent_access(self):
+        """测试并发访问"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_concurrent (
+                    id INTEGER PRIMARY KEY,
+                    value TEXT
+                )
+            """))
+            await session.commit()
+
+        # 并发插入测试
+        async def insert_record(record_id):
+            await execute(
+                text("INSERT INTO test_concurrent (id, value) VALUES (:id, :value)"),
+                {"id": record_id, "value": f"record_{record_id}"}
+            )
+
+        # 并发执行插入
+        tasks = [insert_record(i) for i in range(10)]
+        await asyncio.gather(*tasks)
+
+        # 验证所有记录都被插入
+        results = await fetch_all(text("SELECT COUNT(*) as count FROM test_concurrent"))
+        assert results[0]["count"] == 10, "应该插入10条记录"
+
+    async def test_batch_operation_performance(self):
+        """测试批量操作性能"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_batch (
+                    id INTEGER PRIMARY KEY,
+                    name TEXT,
+                    value INTEGER
+                )
+            """))
+            await session.commit()
+
+        # 准备批量数据
+        batch_data = [
+            {"id": i, "name": f"item_{i}", "value": i * 10}
+            for i in range(100)
+        ]
+
+        # 测试批量插入性能
+        import time
+        start_time = time.time()
+
+        await execute(
+            text("""
+                INSERT INTO test_batch (id, name, value)
+                VALUES (:id, :name, :value)
+            """),
+            batch_data
+        )
+
+        end_time = time.time()
+        duration = end_time - start_time
+
+        # 验证结果
+        results = await fetch_all(text("SELECT COUNT(*) as count FROM test_batch"))
+        assert results[0]["count"] == 100, "应该插入100条记录"
+
+        # 性能断言（批量操作应该很快）
+        assert duration < 5.0, f"批量操作应该很快，但耗时: {duration:.2f}秒"
+
+
+# 测试标记
+pytest.mark.unit = pytest.mark.unit
+pytest.mark.asyncio = pytest.mark.asyncio
+pytest.mark.database = pytest.mark.database
\ No newline at end of file
