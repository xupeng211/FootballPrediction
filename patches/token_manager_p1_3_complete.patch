--- a/.dev/null
+++ b/src/collectors/auth/token_manager.py
@@ -0,0 +1,702 @@
+"""
+åŠ¨æ€è®¤è¯æ¨¡å— - Token Manager
+Dynamic Authentication Module - Token Manager
+
+è¯¥æ¨¡å—å®ç°äº†åŠ¨æ€è®¤è¯ç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒï¼š
+1. å¤šç§è®¤è¯æä¾›è€… (AuthProvider Protocol)
+2. Token ç¼“å­˜å’Œè‡ªåŠ¨åˆ·æ–°æœºåˆ¶
+3. FotMob è®¤è¯å®ç°
+4. TTL è¿‡æœŸå¤„ç†
+5. çº¿ç¨‹å®‰å…¨çš„å¹¶å‘è®¿é—®
+
+ä½œè€…: Lead Collector Engineer
+åˆ›å»ºæ—¶é—´: 2025-12-06
+ç‰ˆæœ¬: 1.0.0
+"""
+
+import asyncio
+import re
+import time
+from abc import abstractmethod
+from dataclasses import dataclass, field
+from enum import Enum
+from typing import Any, Dict, Optional, Protocol, runtime_checkable
+
+import aiohttp
+
+
+class TokenType(Enum):
+    """Token ç±»å‹"""
+    BEARER = "bearer"
+    API_KEY = "api_key"
+    CUSTOM_HEADER = "custom_header"
+
+
+@dataclass
+class Token:
+    """
+    è®¤è¯ä»¤ç‰Œæ•°æ®ç±»
+
+    Attributes:
+        value: ä»¤ç‰Œå€¼
+        token_type: ä»¤ç‰Œç±»å‹
+        headers: å…³è”çš„HTTPå¤´éƒ¨
+        expires_at: è¿‡æœŸæ—¶é—´æˆ³
+        created_at: åˆ›å»ºæ—¶é—´æˆ³
+        usage_count: ä½¿ç”¨æ¬¡æ•°
+        provider: æä¾›è€…åç§°
+    """
+    value: str
+    token_type: TokenType
+    headers: Dict[str, str] = field(default_factory=dict)
+    expires_at: Optional[float] = None
+    created_at: float = field(default_factory=time.monotonic)
+    usage_count: int = 0
+    provider: str = "unknown"
+
+    def __post_init__(self) -> None:
+        """åˆå§‹åŒ–åå¤„ç†"""
+        if isinstance(self.token_type, str):
+            self.token_type = TokenType(self.token_type.lower())
+
+    @property
+    def is_expired(self) -> bool:
+        """æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦è¿‡æœŸ"""
+        if self.expires_at is None:
+            return False
+        return time.monotonic() >= self.expires_at
+
+    @property
+    def is_valid(self) -> bool:
+        """æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦æœ‰æ•ˆï¼ˆæœªè¿‡æœŸä¸”å€¼ä¸ä¸ºç©ºï¼‰"""
+        return not self.is_expired and bool(self.value)
+
+    @property
+    def ttl(self) -> Optional[float]:
+        """è·å–å‰©ä½™ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰"""
+        if self.expires_at is None:
+            return None
+        return max(0.0, self.expires_at - time.monotonic())
+
+    def record_usage(self) -> None:
+        """è®°å½•ä»¤ç‰Œä½¿ç”¨"""
+        self.usage_count += 1
+
+    def to_dict(self) -> Dict[str, Any]:
+        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
+        return {
+            'value': self.value[:20] + "..." if len(self.value) > 20 else self.value,  # éšè—å®Œæ•´token
+            'token_type': self.token_type.value,
+            'headers': self.headers,
+            'expires_at': self.expires_at,
+            'created_at': self.created_at,
+            'usage_count': self.usage_count,
+            'provider': self.provider,
+            'is_expired': self.is_expired,
+            'is_valid': self.is_valid,
+            'ttl': self.ttl,
+        }
+
+    def __str__(self) -> str:
+        return f"Token({self.provider}, {self.token_type.value}, valid={self.is_valid})"
+
+    def __repr__(self) -> str:
+        return self.__str__()
+
+
+@runtime_checkable
+class AuthProvider(Protocol):
+    """
+    è®¤è¯æä¾›è€…åè®®
+
+    å®šä¹‰äº†è·å–è®¤è¯ä»¤ç‰Œçš„æ ‡å‡†æ¥å£
+    """
+
+    @abstractmethod
+    async def get_token(self) -> Token:
+        """
+        è·å–è®¤è¯ä»¤ç‰Œ
+
+        Returns:
+            Token: è®¤è¯ä»¤ç‰Œå¯¹è±¡
+
+        Raises:
+            AuthenticationError: è®¤è¯å¤±è´¥
+        """
+        ...
+
+    @abstractmethod
+    async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+        """
+        åˆ·æ–°è®¤è¯ä»¤ç‰Œ
+
+        Args:
+            old_token: æ—§çš„ä»¤ç‰Œï¼ˆå¯é€‰ï¼‰
+
+        Returns:
+            Token: æ–°çš„è®¤è¯ä»¤ç‰Œ
+
+        Raises:
+            AuthenticationError: è®¤è¯å¤±è´¥
+        """
+        ...
+
+    @property
+    @abstractmethod
+    def provider_name(self) -> str:
+        """è·å–æä¾›è€…åç§°"""
+        ...
+
+
+class AuthenticationError(Exception):
+    """è®¤è¯é”™è¯¯åŸºç±»"""
+    pass
+
+
+class TokenExpiredError(AuthenticationError):
+    """ä»¤ç‰Œè¿‡æœŸé”™è¯¯"""
+    pass
+
+
+class TokenRefreshError(AuthenticationError):
+    """ä»¤ç‰Œåˆ·æ–°é”™è¯¯"""
+    pass
+
+
+class TokenManager:
+    """
+    ä»¤ç‰Œç®¡ç†å™¨
+
+    è´Ÿè´£ç®¡ç†ä¸åŒçš„è®¤è¯æä¾›è€…ï¼Œå¤„ç†ä»¤ç‰Œçš„ç¼“å­˜å’Œè‡ªåŠ¨åˆ·æ–°
+    """
+
+    def __init__(
+        self,
+        default_ttl: float = 3600.0,  # 1å°æ—¶
+        cache_refresh_threshold: float = 300.0,  # 5åˆ†é’Ÿå†…è¿‡æœŸæ—¶åˆ·æ–°
+        max_retry_attempts: int = 3,
+        retry_delay: float = 1.0,
+    ):
+        """
+        åˆå§‹åŒ–ä»¤ç‰Œç®¡ç†å™¨
+
+        Args:
+            default_ttl: é»˜è®¤ä»¤ç‰Œç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰
+            cache_refresh_threshold: ç¼“å­˜åˆ·æ–°é˜ˆå€¼ï¼ˆç§’ï¼‰
+            max_retry_attempts: æœ€å¤§é‡è¯•æ¬¡æ•°
+            retry_delay: é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰
+        """
+        self.default_ttl = default_ttl
+        self.cache_refresh_threshold = cache_refresh_threshold
+        self.max_retry_attempts = max_retry_attempts
+        self.retry_delay = retry_delay
+
+        # ä»¤ç‰Œç¼“å­˜: {provider_name: Token}
+        self.token_cache: Dict[str, Token] = {}
+        # æä¾›è€…ç¼“å­˜: {provider_name: AuthProvider}
+        self.provider_cache: Dict[str, AuthProvider] = {}
+        self.lock = asyncio.Lock()
+
+    async def register_provider(self, provider: AuthProvider) -> None:
+        """
+        æ³¨å†Œè®¤è¯æä¾›è€…
+
+        Args:
+            provider: è®¤è¯æä¾›è€…å®ä¾‹
+        """
+        async with self.lock:
+            provider_name = provider.provider_name
+            if provider_name not in self.token_cache:
+                # å­˜å‚¨providerå¼•ç”¨
+                self.provider_cache[provider_name] = provider
+
+                # é¢„å…ˆè·å–ä¸€ä¸ªä»¤ç‰Œ
+                try:
+                    token = await provider.get_token()
+                    self.token_cache[provider_name] = token
+                    print(f"ğŸ”‘ Registered provider: {provider_name}")
+                except Exception as e:
+                    print(f"âŒ Failed to register provider {provider_name}: {e}")
+                    raise AuthenticationError(f"Failed to register provider {provider_name}: {e}")
+
+    async def get_token(self, provider_name: str, force_refresh: bool = False) -> Token:
+        """
+        è·å–è®¤è¯ä»¤ç‰Œ
+
+        Args:
+            provider_name: æä¾›è€…åç§°
+            force_refresh: æ˜¯å¦å¼ºåˆ¶åˆ·æ–°
+
+        Returns:
+            Token: è®¤è¯ä»¤ç‰Œ
+
+        Raises:
+            AuthenticationError: è®¤è¯å¤±è´¥
+            TokenRefreshError: ä»¤ç‰Œåˆ·æ–°å¤±è´¥
+        """
+        async with self.lock:
+            if provider_name not in self.token_cache:
+                raise AuthenticationError(f"Provider {provider_name} not registered")
+
+            cached_token = self.token_cache[provider_name]
+
+            # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°
+            should_refresh = (
+                force_refresh or
+                not cached_token.is_valid or
+                (cached_token.ttl and cached_token.ttl < self.cache_refresh_threshold)
+            )
+
+            if should_refresh:
+                print(f"ğŸ”„ Refreshing token for provider: {provider_name}")
+                # è¿™é‡Œéœ€è¦é‡æ–°è·å–providerå®ä¾‹è¿›è¡Œåˆ·æ–°
+                # å®é™…å®ç°ä¸­åº”è¯¥ä¿å­˜providerå¼•ç”¨
+                provider = self._get_provider_by_name(provider_name)
+                if not provider:
+                    raise AuthenticationError(f"Provider {provider_name} not found for refresh")
+
+                try:
+                    new_token = await self._retry_token_refresh(provider, cached_token)
+                    self.token_cache[provider_name] = new_token
+                    print(f"âœ… Token refreshed for provider: {provider_name}")
+                    return new_token
+                except Exception as e:
+                    print(f"âŒ Failed to refresh token for {provider_name}: {e}")
+                    if not cached_token.is_valid:
+                        # ç¼“å­˜çš„tokenä¹Ÿæ— æ•ˆäº†ï¼ŒæŠ›å‡ºå¼‚å¸¸
+                        raise TokenRefreshError(f"Failed to refresh token for {provider_name}: {e}")
+                    # è¿”å›æ—§tokenï¼ˆè™½ç„¶å¿«è¿‡æœŸä½†ä»ç„¶æœ‰æ•ˆï¼‰
+                    print(f"âš ï¸ Using old token for {provider_name} (will expire soon)")
+                    return cached_token
+            else:
+                cached_token.record_usage()
+                if cached_token.usage_count % 10 == 0:  # æ¯10æ¬¡ä½¿ç”¨æ‰“å°ä¸€æ¬¡
+                    print(f"ğŸ“Š Token usage for {provider_name}: {cached_token.usage_count} times")
+                return cached_token
+
+    def _get_provider_by_name(self, provider_name: str) -> Optional[AuthProvider]:
+        """
+        æ ¹æ®åç§°è·å–æä¾›è€…å®ä¾‹
+
+        Args:
+            provider_name: æä¾›è€…åç§°
+
+        Returns:
+            Optional[AuthProvider]: æä¾›è€…å®ä¾‹ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None
+        """
+        return self.provider_cache.get(provider_name)
+
+    async def _retry_token_refresh(self, provider: AuthProvider, old_token: Optional[Token] = None) -> Token:
+        """
+        é‡è¯•ä»¤ç‰Œåˆ·æ–°
+
+        Args:
+            provider: è®¤è¯æä¾›è€…
+            old_token: æ—§ä»¤ç‰Œ
+
+        Returns:
+            Token: æ–°ä»¤ç‰Œ
+
+        Raises:
+            TokenRefreshError: åˆ·æ–°å¤±è´¥
+        """
+        last_error = None
+
+        for attempt in range(self.max_retry_attempts):
+            try:
+                new_token = await provider.refresh_token(old_token)
+                return new_token
+            except Exception as e:
+                last_error = e
+                print(f"âš ï¸ Token refresh attempt {attempt + 1} failed: {e}")
+                if attempt < self.max_retry_attempts - 1:
+                    await asyncio.sleep(self.retry_delay * (2 ** attempt))  # æŒ‡æ•°é€€é¿
+
+        raise TokenRefreshError(f"Token refresh failed after {self.max_retry_attempts} attempts: {last_error}")
+
+    async def invalidate_token(self, provider_name: str) -> None:
+        """
+        ä½¿ä»¤ç‰Œå¤±æ•ˆ
+
+        Args:
+            provider_name: æä¾›è€…åç§°
+        """
+        async with self.lock:
+            if provider_name in self.token_cache:
+                del self.token_cache[provider_name]
+                print(f"ğŸ—‘ï¸ Invalidated token for provider: {provider_name}")
+
+    async def get_token_info(self, provider_name: Optional[str] = None) -> Dict[str, Any]:
+        """
+        è·å–ä»¤ç‰Œä¿¡æ¯
+
+        Args:
+            provider_name: æä¾›è€…åç§°ï¼ŒNoneè¡¨ç¤ºè·å–æ‰€æœ‰
+
+        Returns:
+            Dict[str, Any]: ä»¤ç‰Œä¿¡æ¯
+        """
+        async with self.lock:
+            if provider_name:
+                if provider_name in self.token_cache:
+                    return self.token_cache[provider_name].to_dict()
+                else:
+                    return {"error": f"Provider {provider_name} not found"}
+            else:
+                return {
+                    name: token.to_dict()
+                    for name, token in self.token_cache.items()
+                }
+
+    async def get_stats(self) -> Dict[str, Any]:
+        """
+        è·å–ç®¡ç†å™¨ç»Ÿè®¡ä¿¡æ¯
+
+        Returns:
+            Dict[str, Any]: ç»Ÿè®¡ä¿¡æ¯
+        """
+        async with self.lock:
+            total_providers = len(self.token_cache)
+            valid_tokens = sum(1 for token in self.token_cache.values() if token.is_valid)
+            expired_tokens = total_providers - valid_tokens
+
+            total_usage = sum(token.usage_count for token in self.token_cache.values())
+
+            return {
+                'total_providers': total_providers,
+                'valid_tokens': valid_tokens,
+                'expired_tokens': expired_tokens,
+                'total_usage': total_usage,
+                'cache_refresh_threshold': self.cache_refresh_threshold,
+                'default_ttl': self.default_ttl,
+            }
+
+
+class FotMobAuthProvider:
+    """
+    FotMob è®¤è¯æä¾›è€…
+
+    æ¨¡æ‹Ÿä» FotMob é¦–é¡µ HTML ä¸­æå–è®¤è¯ç­¾åçš„é€»è¾‘
+    """
+
+    def __init__(
+        self,
+        base_url: str = "https://www.fotmob.com",
+        timeout: float = 10.0,
+        token_ttl: float = 3600.0,  # 1å°æ—¶
+        user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
+    ):
+        """
+        åˆå§‹åŒ– FotMob è®¤è¯æä¾›è€…
+
+        Args:
+            base_url: FotMob åŸºç¡€URL
+            timeout: è¯·æ±‚è¶…æ—¶æ—¶é—´
+            token_ttl: ä»¤ç‰Œç”Ÿå­˜æ—¶é—´
+            user_agent: ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²
+        """
+        self.base_url = base_url
+        self.timeout = timeout
+        self.token_ttl = token_ttl
+        self.user_agent = user_agent
+
+    @property
+    def provider_name(self) -> str:
+        """è·å–æä¾›è€…åç§°"""
+        return "fotmob"
+
+    async def get_token(self) -> Token:
+        """
+        è·å– FotMob è®¤è¯ä»¤ç‰Œ
+
+        Returns:
+            Token: è®¤è¯ä»¤ç‰Œ
+
+        Raises:
+            AuthenticationError: è®¤è¯å¤±è´¥
+        """
+        try:
+            # æ¨¡æ‹Ÿä» FotMob é¦–é¡µæå– token
+            html_content = await self._fetch_fotmob_homepage()
+            token_data = self._extract_token_from_html(html_content)
+
+            if not token_data:
+                raise AuthenticationError("Failed to extract token from FotMob homepage")
+
+            token = Token(
+                value=token_data['value'],
+                token_type=TokenType.CUSTOM_HEADER,
+                headers=token_data['headers'],
+                expires_at=time.monotonic() + self.token_ttl,
+                provider=self.provider_name
+            )
+
+            print(f"ğŸ”‘ Obtained FotMob token: {token.value[:20]}...")
+            return token
+
+        except Exception as e:
+            print(f"âŒ Failed to get FotMob token: {e}")
+            raise AuthenticationError(f"Failed to get FotMob token: {e}")
+
+    async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+        """
+        åˆ·æ–° FotMob è®¤è¯ä»¤ç‰Œ
+
+        Args:
+            old_token: æ—§ä»¤ç‰Œï¼ˆå¯é€‰ï¼‰
+
+        Returns:
+            Token: æ–°çš„è®¤è¯ä»¤ç‰Œ
+
+        Raises:
+            TokenRefreshError: åˆ·æ–°å¤±è´¥
+        """
+        try:
+            print("ğŸ”„ Refreshing FotMob token...")
+            new_token = await self.get_token()
+            print(f"âœ… FotMob token refreshed successfully")
+            return new_token
+        except Exception as e:
+            print(f"âŒ Failed to refresh FotMob token: {e}")
+            raise TokenRefreshError(f"Failed to refresh FotMob token: {e}")
+
+    async def _fetch_fotmob_homepage(self) -> str:
+        """
+        è·å– FotMob é¦–é¡µ HTML
+
+        Returns:
+            str: HTML å†…å®¹
+
+        Raises:
+            AuthenticationError: è·å–å¤±è´¥
+        """
+        try:
+            timeout = aiohttp.ClientTimeout(total=self.timeout)
+
+            headers = {
+                'User-Agent': self.user_agent,
+                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
+                'Accept-Language': 'en-US,en;q=0.5',
+                'Accept-Encoding': 'gzip, deflate',
+                'Connection': 'keep-alive',
+                'Upgrade-Insecure-Requests': '1',
+            }
+
+            async with aiohttp.ClientSession(timeout=timeout) as session:
+                async with session.get(self.base_url, headers=headers) as response:
+                    if response.status == 200:
+                        return await response.text()
+                    else:
+                        raise AuthenticationError(f"HTTP {response.status}: Failed to fetch FotMob homepage")
+
+        except aiohttp.ClientError as e:
+            raise AuthenticationError(f"Network error while fetching FotMob homepage: {e}")
+
+    def _extract_token_from_html(self, html_content: str) -> Optional[Dict[str, Any]]:
+        """
+        ä» HTML å†…å®¹ä¸­æå–è®¤è¯ä»¤ç‰Œ
+
+        Args:
+            html_content: HTML å†…å®¹
+
+        Returns:
+            Optional[Dict[str, Any]]: ä»¤ç‰Œæ•°æ®ï¼Œå¦‚æœæå–å¤±è´¥è¿”å›None
+        """
+        try:
+            # æ¨¡æ‹Ÿä» HTML ä¸­æå–è®¤è¯ä¿¡æ¯
+            # å®é™…å®ç°ä¸­ï¼Œè¿™äº›å€¼ä¼šä» HTML çš„ JavaScript æˆ– meta æ ‡ç­¾ä¸­æå–
+
+            # æ¨¡æ‹Ÿæå– x-mas header
+            x_mas_match = re.search(r'"x-mas":"([^"]+)"', html_content)
+            x_mas_value = x_mas_match.group(1) if x_mas_match else self._generate_mock_x_mas()
+
+            # æ¨¡æ‹Ÿæå– x-foo signature
+            x_foo_match = re.search(r'"x-foo":"([^"]+)"', html_content)
+            x_foo_value = x_foo_match.group(1) if x_foo_match else self._generate_mock_x_foo()
+
+            # æ¨¡æ‹Ÿæå– client version
+            version_match = re.search(r'"clientVersion":"([^"]+)"', html_content)
+            client_version = version_match.group(1) if version_match else "production:mock_version"
+
+            if not x_mas_value or not x_foo_value:
+                print("âš ï¸ Token extraction incomplete, using mock values")
+
+            token_data = {
+                'value': f"{x_mas_value}:{x_foo_value}",
+                'headers': {
+                    'x-mas': x_mas_value,
+                    'x-foo': x_foo_value,
+                    'x-client-version': client_version,
+                }
+            }
+
+            return token_data
+
+        except Exception as e:
+            print(f"âš ï¸ Token extraction failed, using mock values: {e}")
+            return self._generate_mock_token_data()
+
+    def _generate_mock_x_mas(self) -> str:
+        """ç”Ÿæˆæ¨¡æ‹Ÿçš„ x-mas å€¼"""
+        import hashlib
+        import random
+
+        timestamp = int(time.time())
+        random_str = f"fotmob_{timestamp}_{random.randint(1000, 9999)}"
+        return hashlib.sha256(random_str.encode()).hexdigest()[:32]
+
+    def _generate_mock_x_foo(self) -> str:
+        """ç”Ÿæˆæ¨¡æ‹Ÿçš„ x-foo ç­¾å"""
+        import hashlib
+        import base64
+
+        payload = f"fotmob_auth_{int(time.time())}".encode()
+        signature = hashlib.sha256(payload).digest()
+        return base64.b64encode(signature).decode()[:40]
+
+    def _generate_mock_token_data(self) -> Dict[str, Any]:
+        """ç”Ÿæˆæ¨¡æ‹Ÿä»¤ç‰Œæ•°æ®"""
+        x_mas = self._generate_mock_x_mas()
+        x_foo = self._generate_mock_x_foo()
+
+        return {
+            'value': f"{x_mas}:{x_foo_value}",
+            'headers': {
+                'x-mas': x_mas,
+                'x-foo': x_foo,
+                'x-client-version': "production:mock_version",
+            }
+        }
+
+
+class MockAuthProvider:
+    """
+    æ¨¡æ‹Ÿè®¤è¯æä¾›è€…ï¼ˆç”¨äºæµ‹è¯•ï¼‰
+    """
+
+    def __init__(self, provider_name: str, token_value: str = "mock_token", ttl: float = 300.0):
+        """
+        åˆå§‹åŒ–æ¨¡æ‹Ÿè®¤è¯æä¾›è€…
+
+        Args:
+            provider_name: æä¾›è€…åç§°
+            token_value: ä»¤ç‰Œå€¼
+            ttl: ç”Ÿå­˜æ—¶é—´
+        """
+        self._provider_name = provider_name
+        self.token_value = token_value
+        self.ttl = ttl
+
+    @property
+    def provider_name(self) -> str:
+        """è·å–æä¾›è€…åç§°"""
+        return self._provider_name
+
+    async def get_token(self) -> Token:
+        """è·å–æ¨¡æ‹Ÿä»¤ç‰Œ"""
+        return Token(
+            value=self.token_value,
+            token_type=TokenType.BEARER,
+            expires_at=time.monotonic() + self.ttl,
+            provider=self.provider_name
+        )
+
+    async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+        """åˆ·æ–°æ¨¡æ‹Ÿä»¤ç‰Œ"""
+        new_value = f"{self.token_value}_refreshed_{int(time.time())}"
+        return Token(
+            value=new_value,
+            token_type=TokenType.BEARER,
+            expires_at=time.monotonic() + self.ttl,
+            provider=self.provider_name
+        )
+
+
+# å…¨å±€ä»¤ç‰Œç®¡ç†å™¨å®ä¾‹
+_token_manager: Optional[TokenManager] = None
+
+
+async def get_token_manager() -> TokenManager:
+    """
+    è·å–å…¨å±€ä»¤ç‰Œç®¡ç†å™¨å®ä¾‹
+
+    Returns:
+        TokenManager: ä»¤ç‰Œç®¡ç†å™¨å®ä¾‹
+    """
+    global _token_manager
+    if _token_manager is None:
+        _token_manager = TokenManager()
+    return _token_manager
+
+
+async def close_token_manager():
+    """å…³é—­ä»¤ç‰Œç®¡ç†å™¨"""
+    global _token_manager
+    if _token_manager:
+        _token_manager = None
+
+
+# ä¾¿åˆ©å‡½æ•°
+def create_token_manager(
+    default_ttl: float = 3600.0,
+    cache_refresh_threshold: float = 300.0,
+    **kwargs
+) -> TokenManager:
+    """
+    åˆ›å»ºä»¤ç‰Œç®¡ç†å™¨çš„ä¾¿åˆ©å‡½æ•°
+
+    Args:
+        default_ttl: é»˜è®¤ä»¤ç‰Œç”Ÿå­˜æ—¶é—´
+        cache_refresh_threshold: ç¼“å­˜åˆ·æ–°é˜ˆå€¼
+        **kwargs: å…¶ä»–å‚æ•°
+
+    Returns:
+        TokenManager: ä»¤ç‰Œç®¡ç†å™¨å®ä¾‹
+    """
+    return TokenManager(default_ttl, cache_refresh_threshold, **kwargs)
+
+
+def create_fotmob_provider(**kwargs) -> FotMobAuthProvider:
+    """
+    åˆ›å»º FotMob è®¤è¯æä¾›è€…çš„ä¾¿åˆ©å‡½æ•°
+
+    Args:
+        **kwargs: FotMobAuthProvider å‚æ•°
+
+    Returns:
+        FotMobAuthProvider: FotMob è®¤è¯æä¾›è€…å®ä¾‹
+    """
+    return FotMobAuthProvider(**kwargs)
+
+
+def create_mock_provider(provider_name: str, **kwargs) -> MockAuthProvider:
+    """
+    åˆ›å»ºæ¨¡æ‹Ÿè®¤è¯æä¾›è€…çš„ä¾¿åˆ©å‡½æ•°
+
+    Args:
+        provider_name: æä¾›è€…åç§°
+        **kwargs: MockAuthProvider å‚æ•°
+
+    Returns:
+        MockAuthProvider: æ¨¡æ‹Ÿè®¤è¯æä¾›è€…å®ä¾‹
+    """
+    return MockAuthProvider(provider_name, **kwargs)
+
+
+# æ¨¡å—å¯¼å‡º
+__all__ = [
+    'Token',
+    'TokenType',
+    'AuthProvider',
+    'TokenManager',
+    'FotMobAuthProvider',
+    'MockAuthProvider',
+    'AuthenticationError',
+    'TokenExpiredError',
+    'TokenRefreshError',
+    'get_token_manager',
+    'close_token_manager',
+    'create_token_manager',
+    'create_fotmob_provider',
+    'create_mock_provider',
+]
--- a/.dev/null
+++ b/src/collectors/auth/__init__.py
@@ -0,0 +1,45 @@
+"""
+è®¤è¯æ¨¡å—
+Authentication Module
+
+è¯¥æ¨¡å—æä¾›åŠ¨æ€è®¤è¯åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä»¤ç‰Œç®¡ç†ã€ç¼“å­˜å’Œè‡ªåŠ¨åˆ·æ–°ã€‚
+
+ä¸»è¦ç»„ä»¶:
+- TokenManager: ä»¤ç‰Œç®¡ç†å™¨
+- AuthProvider: è®¤è¯æä¾›è€…åè®®
+- FotMobAuthProvider: FotMob è®¤è¯å®ç°
+"""
+
+from .token_manager import (
+    Token,
+    TokenType,
+    AuthProvider,
+    TokenManager,
+    FotMobAuthProvider,
+    MockAuthProvider,
+    AuthenticationError,
+    TokenExpiredError,
+    TokenRefreshError,
+    get_token_manager,
+    close_token_manager,
+    create_token_manager,
+    create_fotmob_provider,
+    create_mock_provider,
+)
+
+__all__ = [
+    'Token',
+    'TokenType',
+    'AuthProvider',
+    'TokenManager',
+    'FotMobAuthProvider',
+    'MockAuthProvider',
+    'AuthenticationError',
+    'TokenExpiredError',
+    'TokenRefreshError',
+    'get_token_manager',
+    'close_token_manager',
+    'create_token_manager',
+    'create_fotmob_provider',
+    'create_mock_provider',
+]
--- a/.dev/null
+++ b/tests/unit/collectors/auth/test_token_manager.py
@@ -0,0 +1,2959 @@
+"""
+TokenManager å•å…ƒæµ‹è¯•
+Token Manager Unit Tests
+
+è¯¥æµ‹è¯•æ¨¡å—éªŒè¯ TokenManager ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ï¼š
+1. Token æ•°æ®ç±»å±æ€§å’Œæ–¹æ³•
+2. AuthProvider Protocol å®ç°
+3. TokenManager ç¼“å­˜å’Œåˆ·æ–°æœºåˆ¶
+4. é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
+5. å¹¶å‘å®‰å…¨æ€§
+
+ä½œè€…: Lead Collector Engineer
+åˆ›å»ºæ—¶é—´: 2025-12-06
+ç‰ˆæœ¬: 1.0.0
+"""
+
+import asyncio
+import pytest
+import time
+from unittest.mock import AsyncMock, Mock, patch
+
+from src.collectors.auth.token_manager import (
+    Token,
+    TokenType,
+    AuthProvider,
+    TokenManager,
+    FotMobAuthProvider,
+    MockAuthProvider,
+    AuthenticationError,
+    TokenExpiredError,
+    TokenRefreshError,
+    create_token_manager,
+    create_fotmob_provider,
+    create_mock_provider,
+)
+
+
+class TestToken:
+    """Token æ•°æ®ç±»æµ‹è¯•"""
+
+    def test_token_creation_valid(self):
+        """æµ‹è¯•æœ‰æ•ˆTokençš„åˆ›å»º"""
+        future_time = time.monotonic() + 3600.0
+        token = Token(
+            value="test_token_value",
+            token_type=TokenType.BEARER,
+            expires_at=future_time,
+            provider="test_provider"
+        )
+
+        assert token.value == "test_token_value"
+        assert token.token_type == TokenType.BEARER
+        assert token.expires_at == future_time
+        assert token.provider == "test_provider"
+        assert token.usage_count == 0
+        assert isinstance(token.created_at, float)
+        assert token.created_at > 0
+
+    def test_token_creation_with_string_type(self):
+        """æµ‹è¯•ä½¿ç”¨å­—ç¬¦ä¸²åˆ›å»ºTokenç±»å‹"""
+        token = Token(
+            value="test_token",
+            token_type="bearer",  # å­—ç¬¦ä¸²ç±»å‹
+            provider="test_provider"
+        )
+
+        assert token.token_type == TokenType.BEARER
+
+    def test_token_with_api_key_type(self):
+        """æµ‹è¯•API Keyç±»å‹Token"""
+        token = Token(
+            value="api_key_12345",
+            token_type=TokenType.API_KEY,
+            provider="api_service"
+        )
+
+        assert token.token_type == TokenType.API_KEY
+        assert token.is_valid == True
+
+    def test_token_with_custom_header_type(self):
+        """æµ‹è¯•Custom Headerç±»å‹Token"""
+        headers = {
+            "x-api-key": "custom_key_123",
+            "authorization": "Bearer custom_token"
+        }
+        token = Token(
+            value="custom_token_value",
+            token_type=TokenType.CUSTOM_HEADER,
+            headers=headers,
+            provider="custom_service"
+        )
+
+        assert token.token_type == TokenType.CUSTOM_HEADER
+        assert token.headers == headers
+
+    def test_token_is_expired_false(self):
+        """æµ‹è¯•æœªè¿‡æœŸçš„Token"""
+        future_time = time.monotonic() + 3600.0
+        token = Token(
+            value="valid_token",
+            token_type=TokenType.BEARER,
+            expires_at=future_time
+        )
+
+        assert token.is_expired == False
+        assert token.ttl > 0
+
+    def test_token_is_expired_true(self):
+        """æµ‹è¯•å·²è¿‡æœŸçš„Token"""
+        past_time = time.monotonic() - 1.0
+        token = Token(
+            value="expired_token",
+            token_type=TokenType.BEARER,
+            expires_at=past_time
+        )
+
+        assert token.is_expired == True
+        assert token.ttl == 0.0
+
+    def test_token_no_expiry(self):
+        """æµ‹è¯•æ— è¿‡æœŸæ—¶é—´çš„Token"""
+        token = Token(
+            value="never_expires",
+            token_type=TokenType.API_KEY,
+            expires_at=None
+        )
+
+        assert token.is_expired == False
+        assert token.ttl is None
+        assert token.is_valid == True
+
+    def test_token_is_valid_with_valid_token(self):
+        """æµ‹è¯•æœ‰æ•ˆTokençš„éªŒè¯"""
+        token = Token(
+            value="valid_token",
+            token_type=TokenType.BEARER,
+            expires_at=time.monotonic() + 3600.0
+        )
+
+        assert token.is_valid == True
+
+    def test_token_is_valid_with_expired_token(self):
+        """æµ‹è¯•è¿‡æœŸTokençš„éªŒè¯"""
+        token = Token(
+            value="expired_token",
+            token_type=TokenType.BEARER,
+            expires_at=time.monotonic() - 1.0
+        )
+
+        assert token.is_valid == False
+
+    def test_token_is_valid_with_empty_value(self):
+        """æµ‹è¯•ç©ºå€¼Tokençš„éªŒè¯"""
+        token = Token(
+            value="",
+            token_type=TokenType.BEARER,
+            expires_at=time.monotonic() + 3600.0
+        )
+
+        assert token.is_valid == False
+
+    def test_token_ttl_calculation(self):
+        """æµ‹è¯•TTLè®¡ç®—"""
+        future_time = time.monotonic() + 300.0
+        token = Token(
+            value="ttl_test_token",
+            token_type=TokenType.BEARER,
+            expires_at=future_time
+        )
+
+        # TTLåº”è¯¥æ¥è¿‘300ç§’ï¼ˆå…è®¸1ç§’è¯¯å·®ï¼‰
+        assert 290.0 <= token.ttl <= 300.0
+
+    def test_ttl_with_no_expiry(self):
+        """æµ‹è¯•æ— è¿‡æœŸæ—¶é—´Tokençš„TTL"""
+        token = Token(
+            value="no_expiry_token",
+            token_type=TokenType.API_KEY,
+            expires_at=None
+        )
+
+        assert token.ttl is None
+
+    def test_record_usage(self):
+        """æµ‹è¯•Tokenä½¿ç”¨è®°å½•"""
+        token = Token(
+            value="usage_test_token",
+            token_type=TokenType.BEARER
+        )
+
+        assert token.usage_count == 0
+
+        token.record_usage()
+        assert token.usage_count == 1
+
+        token.record_usage()
+        assert token.usage_count == 2
+
+    def test_token_to_dict(self):
+        """æµ‹è¯•Tokenè½¬æ¢ä¸ºå­—å…¸"""
+        headers = {"x-custom": "header_value"}
+        token = Token(
+            value="very_long_token_value_that_should_be_truncated_in_output",
+            token_type=TokenType.CUSTOM_HEADER,
+            headers=headers,
+            expires_at=time.monotonic() + 3600.0,
+            provider="test_provider"
+        )
+        token.record_usage()
+
+        token_dict = token.to_dict()
+
+        assert token_dict['value'] == "very_long_token_valu..."  # æˆªæ–­æ˜¾ç¤º
+        assert token_dict['token_type'] == "custom_header"
+        assert token_dict['headers'] == headers
+        assert token_dict['provider'] == "test_provider"
+        assert token_dict['usage_count'] == 1
+        assert token_dict['is_valid'] == True
+        assert token_dict['is_expired'] == False
+        assert isinstance(token_dict['ttl'], float)
+        assert token_dict['ttl'] > 0
+
+    def test_token_to_dict_short_value(self):
+        """æµ‹è¯•çŸ­Tokenå€¼çš„å­—å…¸è½¬æ¢"""
+        token = Token(
+            value="short",
+            token_type=TokenType.BEARER,
+            provider="test_provider"
+        )
+
+        token_dict = token.to_dict()
+
+        assert token_dict['value'] == "short"  # ä¸æˆªæ–­çŸ­å€¼
+
+    def test_token_str_representation(self):
+        """æµ‹è¯•Tokençš„å­—ç¬¦ä¸²è¡¨ç¤º"""
+        token = Token(
+            value="test_token",
+            token_type=TokenType.BEARER,
+            provider="test_provider",
+            expires_at=time.monotonic() + 3600.0
+        )
+
+        str_repr = str(token)
+        assert "Token(" in str_repr
+        assert "test_provider" in str_repr
+        assert "bearer" in str_repr
+        assert "valid=True" in str_repr
+
+    def test_token_repr(self):
+        """æµ‹è¯•Tokençš„reprè¡¨ç¤º"""
+        token = Token(
+            value="test_token",
+            token_type=TokenType.API_KEY,
+            provider="test_provider"
+        )
+
+        assert repr(token) == str(token)
+
+
+class TestMockAuthProvider:
+    """MockAuthProvider æµ‹è¯•"""
+
+    def test_mock_auth_provider_creation(self):
+        """æµ‹è¯•MockAuthProvideråˆ›å»º"""
+        provider = MockAuthProvider(
+            provider_name="test_mock",
+            token_value="mock_token_123",
+            ttl=600.0
+        )
+
+        assert provider.provider_name == "test_mock"
+        assert provider.token_value == "mock_token_123"
+        assert provider.ttl == 600.0
+
+    def test_mock_auth_provider_default_values(self):
+        """æµ‹è¯•MockAuthProvideré»˜è®¤å€¼"""
+        provider = MockAuthProvider("test_provider")
+
+        assert provider.provider_name == "test_provider"
+        assert provider.token_value == "mock_token"
+        assert provider.ttl == 300.0
+
+    @pytest.mark.asyncio
+    async def test_mock_auth_provider_get_token(self):
+        """æµ‹è¯•MockAuthProviderè·å–Token"""
+        provider = MockAuthProvider(
+            "test_provider",
+            "custom_mock_token",
+            180.0
+        )
+
+        token = await provider.get_token()
+
+        assert isinstance(token, Token)
+        assert token.value == "custom_mock_token"
+        assert token.token_type == TokenType.BEARER
+        assert token.provider == "test_provider"
+        assert token.is_valid == True
+        assert token.ttl > 150.0  # å…è®¸ä¸€äº›æ—¶é—´è¯¯å·®
+
+    @pytest.mark.asyncio
+    async def test_mock_auth_provider_refresh_token(self):
+        """æµ‹è¯•MockAuthProvideråˆ·æ–°Token"""
+        provider = MockAuthProvider("test_provider", "original_token")
+
+        # ç¬¬ä¸€æ¬¡è·å–Token
+        original_token = await provider.get_token()
+
+        # åˆ·æ–°Token
+        refreshed_token = await provider.refresh_token(original_token)
+
+        assert refreshed_token.value != original_token.value
+        assert "refreshed_" in refreshed_token.value
+        assert refreshed_token.provider == "test_provider"
+        assert refreshed_token.is_valid == True
+
+    @pytest.mark.asyncio
+    async def test_mock_auth_provider_refresh_without_old_token(self):
+        """æµ‹è¯•ä¸æä¾›æ—§Tokençš„åˆ·æ–°"""
+        provider = MockAuthProvider("test_provider")
+
+        refreshed_token = await provider.refresh_token()
+
+        assert isinstance(refreshed_token, Token)
+        assert refreshed_token.provider == "test_provider"
+        assert "refreshed_" in refreshed_token.value
+
+
+class TestTokenManagerBasicOperations:
+    """TokenManager åŸºç¡€æ“ä½œæµ‹è¯•"""
+
+    @pytest.fixture
+    def token_manager(self):
+        """åˆ›å»ºTokenManagerå®ä¾‹"""
+        return TokenManager(
+            default_ttl=300.0,
+            cache_refresh_threshold=60.0
+        )
+
+    @pytest.fixture
+    async def mock_provider(self):
+        """åˆ›å»ºMockè®¤è¯æä¾›è€…"""
+        return MockAuthProvider("test_provider", "test_token", 300.0)
+
+    @pytest.mark.asyncio
+    async def test_token_manager_creation(self):
+        """æµ‹è¯•TokenManageråˆ›å»º"""
+        manager = TokenManager(
+            default_ttl=600.0,
+            cache_refresh_threshold=120.0,
+            max_retry_attempts=5,
+            retry_delay=2.0
+        )
+
+        assert manager.default_ttl == 600.0
+        assert manager.cache_refresh_threshold == 120.0
+        assert manager.max_retry_attempts == 5
+        assert manager.retry_delay == 2.0
+        assert len(manager.token_cache) == 0
+        assert len(manager.provider_cache) == 0
+
+    @pytest.mark.asyncio
+    async def test_register_provider_success(self, token_manager, mock_provider):
+        """æµ‹è¯•æˆåŠŸæ³¨å†ŒProvider"""
+        await token_manager.register_provider(mock_provider)
+
+        assert "test_provider" in token_manager.token_cache
+        assert "test_provider" in token_manager.provider_cache
+        assert isinstance(token_manager.token_cache["test_provider"], Token)
+        assert token_manager.provider_cache["test_provider"] == mock_provider
+
+    @pytest.mark.asyncio
+    async def test_register_provider_duplicate(self, token_manager, mock_provider):
+        """æµ‹è¯•é‡å¤æ³¨å†Œç›¸åŒProvider"""
+        # ç¬¬ä¸€æ¬¡æ³¨å†Œ
+        await token_manager.register_provider(mock_provider)
+        first_token = token_manager.token_cache["test_provider"]
+
+        # ç¬¬äºŒæ¬¡æ³¨å†Œç›¸åŒåç§°çš„Provider
+        await token_manager.register_provider(mock_provider)
+        second_token = token_manager.token_cache["test_provider"]
+
+        # åº”è¯¥ä»ç„¶æ˜¯åŒä¸€ä¸ªTokenï¼ˆå› ä¸ºå·²å­˜åœ¨ï¼‰
+        assert first_token == second_token
+        assert len(token_manager.token_cache) == 1
+
+    @pytest.mark.asyncio
+    async def test_get_token_success(self, token_manager, mock_provider):
+        """æµ‹è¯•æˆåŠŸè·å–Token"""
+        await token_manager.register_provider(mock_provider)
+
+        token = await token_manager.get_token("test_provider")
+
+        assert isinstance(token, Token)
+        assert token.provider == "test_provider"
+        assert token.is_valid == True
+
+    @pytest.mark.asyncio
+    async def test_get_token_provider_not_registered(self, token_manager):
+        """æµ‹è¯•è·å–æœªæ³¨å†ŒProviderçš„Token"""
+        with pytest.raises(AuthenticationError) as exc_info:
+            await token_manager.get_token("nonexistent_provider")
+
+        assert "not registered" in str(exc_info.value)
+
+    @pytest.mark.asyncio
+    async def test_get_token_caching(self, token_manager, mock_provider):
+        """æµ‹è¯•Tokenç¼“å­˜æœºåˆ¶"""
+        await token_manager.register_provider(mock_provider)
+
+        # ç¬¬ä¸€æ¬¡è·å–
+        token1 = await token_manager.get_token("test_provider")
+        initial_usage = token1.usage_count
+
+        # ç¬¬äºŒæ¬¡è·å–ï¼ˆåº”è¯¥ä½¿ç”¨ç¼“å­˜ï¼‰
+        token2 = await token_manager.get_token("test_provider")
+
+        # åº”è¯¥æ˜¯åŒä¸€ä¸ªTokenå¯¹è±¡ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰
+        assert token1 is token2
+        assert token1.value == token2.value
+        assert token2.usage_count == initial_usage + 1
+
+    @pytest.mark.asyncio
+    async def test_force_refresh_token(self, token_manager, mock_provider):
+        """æµ‹è¯•å¼ºåˆ¶åˆ·æ–°Token"""
+        await token_manager.register_provider(mock_provider)
+
+        # ç¬¬ä¸€æ¬¡è·å–
+        original_token = await token_manager.get_token("test_provider")
+
+        # å¼ºåˆ¶åˆ·æ–°
+        refreshed_token = await token_manager.get_token("test_provider", force_refresh=True)
+
+        # åº”è¯¥æ˜¯ä¸åŒçš„Tokenå¯¹è±¡
+        assert refreshed_token is not original_token
+        assert refreshed_token.value != original_token.value
+        assert refreshed_token.provider == original_token.provider
+
+    @pytest.mark.asyncio
+    async def test_auto_refresh_on_expiry_threshold(self, token_manager):
+        """æµ‹è¯•åŸºäºé˜ˆå€¼è‡ªåŠ¨åˆ·æ–°"""
+        # åˆ›å»ºçŸ­TTLçš„Provider
+        short_ttl_provider = MockAuthProvider("short_ttl", "short_token", 2.0)
+
+        # è®¾ç½®è¾ƒçŸ­çš„åˆ·æ–°é˜ˆå€¼
+        token_manager.cache_refresh_threshold = 1.5
+        await token_manager.register_provider(short_ttl_provider)
+
+        # ç­‰å¾…è¶…è¿‡åˆ·æ–°é˜ˆå€¼
+        await asyncio.sleep(1.8)
+
+        # è·å–Tokenåº”è¯¥è§¦å‘åˆ·æ–°
+        refreshed_token = await token_manager.get_token("short_ttl")
+
+        assert refreshed_token.is_valid == True
+        assert refreshed_token.ttl > 1.5  # æ–°Tokenåº”è¯¥æœ‰æ›´é•¿çš„TTL
+
+    @pytest.mark.asyncio
+    async def test_invalidate_token(self, token_manager, mock_provider):
+        """æµ‹è¯•ä½¿Tokenå¤±æ•ˆ"""
+        await token_manager.register_provider(mock_provider)
+
+        # ç¡®è®¤Tokenå­˜åœ¨
+        assert "test_provider" in token_manager.token_cache
+
+        # ä½¿Tokenå¤±æ•ˆ
+        await token_manager.invalidate_token("test_provider")
+
+        # ç¡®è®¤Tokenå·²åˆ é™¤
+        assert "test_provider" not in token_manager.token_cache
+        assert "test_provider" in token_manager.provider_cache  # Provideråº”è¯¥ä¿ç•™
+
+    @pytest.mark.asyncio
+    async def test_invalidate_nonexistent_token(self, token_manager):
+        """æµ‹è¯•ä½¿ä¸å­˜åœ¨çš„Tokenå¤±æ•ˆ"""
+        # åº”è¯¥ä¸ä¼šæŠ›å‡ºå¼‚å¸¸
+        await token_manager.invalidate_token("nonexistent_provider")
+
+        # çŠ¶æ€åº”è¯¥ä¿æŒä¸å˜
+        assert len(token_manager.token_cache) == 0
+
+    @pytest.mark.asyncio
+    async def test_get_token_info_single_provider(self, token_manager, mock_provider):
+        """æµ‹è¯•è·å–å•ä¸ªProviderçš„Tokenä¿¡æ¯"""
+        await token_manager.register_provider(mock_provider)
+        token = await token_manager.get_token("test_provider")
+
+        token_info = await token_manager.get_token_info("test_provider")
+
+        assert token_info['provider'] == "test_provider"
+        assert token_info['is_valid'] == True
+        assert 'value' in token_info
+        assert 'ttl' in token_info
+        assert token_info['usage_count'] > 0
+
+    @pytest.mark.asyncio
+    async def test_get_token_info_nonexistent_provider(self, token_manager):
+        """æµ‹è¯•è·å–ä¸å­˜åœ¨Providerçš„Tokenä¿¡æ¯"""
+        token_info = await token_manager.get_token_info("nonexistent_provider")
+
+        assert "error" in token_info
+        assert "not found" in token_info["error"]
+
+    @pytest.mark.asyncio
+    async def test_get_token_info_all_providers(self, token_manager):
+        """æµ‹è¯•è·å–æ‰€æœ‰Providerçš„Tokenä¿¡æ¯"""
+        # æ³¨å†Œå¤šä¸ªProvider
+        provider1 = MockAuthProvider("provider1", "token1")
+        provider2 = MockAuthProvider("provider2", "token2")
+
+        await token_manager.register_provider(provider1)
+        await token_manager.register_provider(provider2)
+
+        all_info = await token_manager.get_token_info()
+
+        assert "provider1" in all_info
+        assert "provider2" in all_info
+        assert len(all_info) == 2
+
+        assert all_info["provider1"]["provider"] == "provider1"
+        assert all_info["provider2"]["provider"] == "provider2"
+
+    @pytest.mark.asyncio
+    async def test_get_stats(self, token_manager):
+        """æµ‹è¯•è·å–ç®¡ç†å™¨ç»Ÿè®¡ä¿¡æ¯"""
+        # åˆå§‹çŠ¶æ€
+        stats = await token_manager.get_stats()
+        assert stats['total_providers'] == 0
+        assert stats['valid_tokens'] == 0
+        assert stats['expired_tokens'] == 0
+        assert stats['total_usage'] == 0
+
+        # æ³¨å†Œä¸€ä¸ªProvider
+        provider = MockAuthProvider("stats_provider", "stats_token", 1.0)
+        await token_manager.register_provider(provider)
+
+        # è·å–Tokenå‡ æ¬¡
+        await token_manager.get_token("stats_provider")
+        await token_manager.get_token("stats_provider")
+
+        stats = await token_manager.get_stats()
+        assert stats['total_providers'] == 1
+        assert stats['valid_tokens'] == 1
+        assert stats['expired_tokens'] == 0
+        assert stats['total_usage'] == 2
+        assert stats['default_ttl'] == 300.0
+        assert stats['cache_refresh_threshold'] == 60.0
+
+    @pytest.mark.asyncio
+    async def test_retry_token_refresh_success_on_retry(self, token_manager):
+        """æµ‹è¯•Tokenåˆ·æ–°é‡è¯•æœºåˆ¶æˆåŠŸ"""
+        # åˆ›å»ºä¸€ä¸ªå‰ä¸¤æ¬¡å¤±è´¥ä½†ç¬¬ä¸‰æ¬¡æˆåŠŸçš„Provider
+        class FlakyProvider:
+            def __init__(self):
+                self.attempt_count = 0
+
+            @property
+            def provider_name(self) -> str:
+                return "flaky_provider"
+
+            async def get_token(self) -> Token:
+                return Token(
+                    value="flaky_token",
+                    token_type=TokenType.BEARER,
+                    provider="flaky_provider"
+                )
+
+            async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+                self.attempt_count += 1
+                if self.attempt_count < 3:
+                    raise Exception(f"Attempt {self.attempt_count} failed")
+                return Token(
+                    value="refreshed_successfully",
+                    token_type=TokenType.BEARER,
+                    provider="flaky_provider"
+                )
+
+        flaky_provider = FlakyProvider()
+        await token_manager.register_provider(flaky_provider)
+
+        # è®¾ç½®ä½é‡è¯•æ¬¡æ•°å’Œé«˜é‡è¯•å»¶è¿Ÿ
+        token_manager.max_retry_attempts = 3
+        token_manager.retry_delay = 0.1
+
+        # å¼ºåˆ¶åˆ·æ–°ï¼ˆåº”è¯¥è§¦å‘é‡è¯•æœºåˆ¶ï¼‰
+        refreshed_token = await token_manager.get_token("flaky_provider", force_refresh=True)
+
+        assert refreshed_token.value == "refreshed_successfully"
+        assert flaky_provider.attempt_count == 3
+
+
+class TestTokenManagerErrorHandling:
+    """TokenManager é”™è¯¯å¤„ç†æµ‹è¯•"""
+
+    @pytest.fixture
+    def token_manager(self):
+        return TokenManager()
+
+    @pytest.mark.asyncio
+    async def test_register_provider_failure(self, token_manager):
+        """æµ‹è¯•Provideræ³¨å†Œå¤±è´¥"""
+        class FailingProvider:
+            @property
+            def provider_name(self) -> str:
+                return "failing_provider"
+
+            async def get_token(self) -> Token:
+                raise Exception("Simulated provider failure")
+
+            async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+                raise Exception("Refresh also fails")
+
+        failing_provider = FailingProvider()
+
+        with pytest.raises(AuthenticationError) as exc_info:
+            await token_manager.register_provider(failing_provider)
+
+        assert "Failed to register provider" in str(exc_info.value)
+        assert len(token_manager.token_cache) == 0
+
+    @pytest.mark.asyncio
+    async def test_token_refresh_failure_with_valid_cache(self, token_manager):
+        """æµ‹è¯•Tokenåˆ·æ–°å¤±è´¥ä½†ç¼“å­˜Tokenä»ç„¶æœ‰æ•ˆ"""
+        class RefreshFailureProvider:
+            def __init__(self):
+                self.initial_token = Token(
+                    value="initial_valid_token",
+                    token_type=TokenType.BEARER,
+                    expires_at=time.monotonic() + 3600.0,  # 1å°æ—¶åè¿‡æœŸ
+                    provider="refresh_failure_provider"
+                )
+
+            @property
+            def provider_name(self) -> str:
+                return "refresh_failure_provider"
+
+            async def get_token(self) -> Token:
+                return self.initial_token
+
+            async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+                raise TokenRefreshError("Refresh always fails")
+
+        provider = RefreshFailureProvider()
+        await token_manager.register_provider(provider)
+
+        # è®¾ç½®çŸ­é˜ˆå€¼å¼ºåˆ¶åˆ·æ–°
+        token_manager.cache_refresh_threshold = 999999.0  # å¼ºåˆ¶åˆ·æ–°
+
+        # è·å–Tokenåº”è¯¥å°è¯•åˆ·æ–°ä½†å¤±è´¥ï¼Œç„¶åè¿”å›ç¼“å­˜çš„Token
+        token = await token_manager.get_token("refresh_failure_provider")
+
+        assert token.value == "initial_valid_token"
+        assert token.is_valid == True
+
+    @pytest.mark.asyncio
+    async def test_token_refresh_failure_with_expired_cache(self, token_manager):
+        """æµ‹è¯•Tokenåˆ·æ–°å¤±è´¥ä¸”ç¼“å­˜Tokenä¹Ÿè¿‡æœŸ"""
+        class ExpiredTokenProvider:
+            def __init__(self):
+                self.expired_token = Token(
+                    value="expired_token",
+                    token_type=TokenType.BEARER,
+                    expires_at=time.monotonic() - 1.0,  # å·²è¿‡æœŸ
+                    provider="expired_provider"
+                )
+
+            @property
+            def provider_name(self) -> str:
+                return "expired_provider"
+
+            async def get_token(self) -> Token:
+                return self.expired_token
+
+            async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+                raise TokenRefreshError("Refresh fails and token is expired")
+
+        provider = ExpiredTokenProvider()
+        await token_manager.register_provider(provider)
+
+        # å¼ºåˆ¶åˆ·æ–°
+        with pytest.raises(TokenRefreshError) as exc_info:
+            await token_manager.get_token("expired_provider", force_refresh=True)
+
+        assert "Failed to refresh token" in str(exc_info.value)
+
+    @pytest.mark.asyncio
+    async def test_concurrent_access_safety(self, token_manager):
+        """æµ‹è¯•å¹¶å‘è®¿é—®å®‰å…¨æ€§"""
+        provider = MockAuthProvider("concurrent_provider", "concurrent_token")
+        await token_manager.register_provider(provider)
+
+        async def get_token_task(task_id: int):
+            return await token_manager.get_token("concurrent_provider")
+
+        # å¹¶å‘è·å–Token
+        tasks = [get_token_task(i) for i in range(10)]
+        tokens = await asyncio.gather(*tasks)
+
+        # æ‰€æœ‰Tokenåº”è¯¥æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼ˆç¼“å­˜ä¸€è‡´æ€§ï¼‰
+        assert all(token is tokens[0] for token in tokens)
+        assert tokens[0].usage_count == 10
+
+
+class TestFotMobAuthProvider:
+    """FotMobAuthProvider æµ‹è¯•"""
+
+    def test_fotmob_provider_creation(self):
+        """æµ‹è¯•FotMobAuthProvideråˆ›å»º"""
+        provider = FotMobAuthProvider(
+            base_url="https://test.fotmob.com",
+            timeout=15.0,
+            token_ttl=7200.0,
+            user_agent="Custom User Agent"
+        )
+
+        assert provider.base_url == "https://test.fotmob.com"
+        assert provider.timeout == 15.0
+        assert provider.token_ttl == 7200.0
+        assert provider.user_agent == "Custom User Agent"
+        assert provider.provider_name == "fotmob"
+
+    def test_fotmob_provider_defaults(self):
+        """æµ‹è¯•FotMobAuthProvideré»˜è®¤å€¼"""
+        provider = FotMobAuthProvider()
+
+        assert provider.base_url == "https://www.fotmob.com"
+        assert provider.timeout == 10.0
+        assert provider.token_ttl == 3600.0
+        assert "Mozilla" in provider.user_agent
+
+    @patch('aiohttp.ClientSession.get')
+    @pytest.mark.asyncio
+    async def test_fotmob_provider_get_token_success(self, mock_get):
+        """æµ‹è¯•FotMobAuthProvideræˆåŠŸè·å–Token"""
+        # æ¨¡æ‹ŸHTTPå“åº”
+        mock_response = AsyncMock()
+        mock_response.status = 200
+        mock_response.text.return_value = '''
+        <html>
+            <script>
+                var config = {
+                    "x-mas": "test_x_mas_value_12345",
+                    "x-foo": "test_x_foo_signature_67890",
+                    "clientVersion": "production:test_version_1.0"
+                };
+            </script>
+        </html>
+        '''
+
+        mock_session = AsyncMock()
+        mock_session.get.return_value.__aenter__.return_value = mock_response
+        mock_get.return_value.__aenter__.return_value = mock_session
+
+        provider = FotMobAuthProvider()
+        token = await provider.get_token()
+
+        assert isinstance(token, Token)
+        assert token.provider == "fotmob"
+        assert token.token_type == TokenType.CUSTOM_HEADER
+        assert "test_x_mas_value_12345:test_x_foo_signature_67890" == token.value
+        assert token.headers['x-mas'] == "test_x_mas_value_12345"
+        assert token.headers['x-foo'] == "test_x_foo_signature_67890"
+        assert token.headers['x-client-version'] == "production:test_version_1.0"
+        assert token.is_valid == True
+        assert token.ttl > 3500.0  # æ¥è¿‘1å°æ—¶
+
+    @patch('aiohttp.ClientSession.get')
+    @pytest.mark.asyncio
+    async def test_fotmob_provider_network_error(self, mock_get):
+        """æµ‹è¯•FotMobAuthProviderç½‘ç»œé”™è¯¯"""
+        import aiohttp
+
+        # æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
+        mock_get.side_effect = aiohttp.ClientConnectorError(
+            connection_key=None,
+            os_error=None
+        )
+
+        provider = FotMobAuthProvider()
+
+        with pytest.raises(AuthenticationError) as exc_info:
+            await provider.get_token()
+
+        assert "Network error while fetching FotMob homepage" in str(exc_info.value)
+
+    @patch('aiohttp.ClientSession.get')
+    @pytest.mark.asyncio
+    async def test_fotmob_provider_http_error(self, mock_get):
+        """æµ‹è¯•FotMobAuthProvider HTTPé”™è¯¯"""
+        # æ¨¡æ‹ŸHTTPé”™è¯¯å“åº”
+        mock_response = AsyncMock()
+        mock_response.status = 403
+
+        mock_session = AsyncMock()
+        mock_session.get.return_value.__aenter__.return_value = mock_response
+        mock_get.return_value.__aenter__.return_value = mock_session
+
+        provider = FotMobAuthProvider()
+
+        with pytest.raises(AuthenticationError) as exc_info:
+            await provider.get_token()
+
+        assert "HTTP 403" in str(exc_info.value)
+
+    @patch('aiohttp.ClientSession.get')
+    @pytest.mark.asyncio
+    async def test_fotmob_provider_partial_token_extraction(self, mock_get):
+        """æµ‹è¯•FotMobAuthProvideréƒ¨åˆ†Tokenæå–"""
+        # æ¨¡æ‹Ÿåªæœ‰éƒ¨åˆ†è®¤è¯ä¿¡æ¯çš„HTML
+        mock_response = AsyncMock()
+        mock_response.status = 200
+        mock_response.text.return_value = '''
+        <html>
+            <script>
+                var config = {
+                    "x-mas": "partial_x_mas_value"
+                    // x-foo ç¼ºå¤±
+                };
+            </script>
+        </html>
+        '''
+
+        mock_session = AsyncMock()
+        mock_session.get.return_value.__aenter__.return_value = mock_response
+        mock_get.return_value.__aenter__.return_value = mock_session
+
+        provider = FotMobAuthProvider()
+        token = await provider.get_token()
+
+        # åº”è¯¥ä½¿ç”¨mockå€¼è¡¥å…¨ç¼ºå¤±çš„éƒ¨åˆ†
+        assert isinstance(token, Token)
+        assert token.provider == "fotmob"
+        assert token.is_valid == True
+        assert "partial_x_mas_value" in token.value
+
+    @patch('aiohttp.ClientSession.get')
+    @pytest.mark.asyncio
+    async def test_fotmob_provider_refresh_token(self, mock_get):
+        """æµ‹è¯•FotMobAuthProvideråˆ·æ–°Token"""
+        # æ¨¡æ‹ŸHTTPå“åº”
+        mock_response = AsyncMock()
+        mock_response.status = 200
+        mock_response.text.return_value = '''
+        <html>
+            <script>
+                var config = {
+                    "x-mas": "refreshed_x_mas_value",
+                    "x-foo": "refreshed_x_foo_signature",
+                    "clientVersion": "production:refreshed_version"
+                };
+            </script>
+        </html>
+        '''
+
+        mock_session = AsyncMock()
+        mock_session.get.return_value.__aenter__.return_value = mock_response
+        mock_get.return_value.__aenter__.return_value = mock_session
+
+        provider = FotMobAuthProvider()
+        old_token = Token(
+            value="old_token",
+            token_type=TokenType.CUSTOM_HEADER,
+            provider="fotmob"
+        )
+
+        refreshed_token = await provider.refresh_token(old_token)
+
+        assert refreshed_token.value != old_token.value
+        assert "refreshed_x_mas_value:refreshed_x_foo_signature" == refreshed_token.value
+        assert refreshed_token.provider == "fotmob"
+        assert refreshed_token.is_valid == True
+
+
+class TestConvenienceFunctions:
+    """ä¾¿åˆ©å‡½æ•°æµ‹è¯•"""
+
+    def test_create_token_manager(self):
+        """æµ‹è¯•create_token_managerä¾¿åˆ©å‡½æ•°"""
+        manager = create_token_manager(
+            default_ttl=1800.0,
+            cache_refresh_threshold=300.0,
+            max_retry_attempts=5
+        )
+
+        assert isinstance(manager, TokenManager)
+        assert manager.default_ttl == 1800.0
+        assert manager.cache_refresh_threshold == 300.0
+        assert manager.max_retry_attempts == 5
+
+    def test_create_fotmob_provider(self):
+        """æµ‹è¯•create_fotmob_providerä¾¿åˆ©å‡½æ•°"""
+        provider = create_fotmob_provider(
+            timeout=20.0,
+            token_ttl=7200.0
+        )
+
+        assert isinstance(provider, FotMobAuthProvider)
+        assert provider.timeout == 20.0
+        assert provider.token_ttl == 7200.0
+
+    def test_create_mock_provider(self):
+        """æµ‹è¯•create_mock_providerä¾¿åˆ©å‡½æ•°"""
+        provider = create_mock_provider(
+            "test_mock_provider",
+            token_value="custom_mock_value",
+            ttl=600.0
+        )
+
+        assert isinstance(provider, MockAuthProvider)
+        assert provider.provider_name == "test_mock_provider"
+        assert provider.token_value == "custom_mock_value"
+        assert provider.ttl == 600.0
+
+
+class TestIntegrationWorkflow:
+    """é›†æˆå·¥ä½œæµç¨‹æµ‹è¯•"""
+
+    @pytest.mark.asyncio
+    async def test_complete_workflow_with_multiple_providers(self):
+        """æµ‹è¯•å¤šProviderå®Œæ•´å·¥ä½œæµç¨‹"""
+        manager = TokenManager(
+            default_ttl=300.0,
+            cache_refresh_threshold=60.0
+        )
+
+        # åˆ›å»ºå¤šä¸ªProvider
+        fotmob_provider = create_fotmob_provider(token_ttl=300.0)
+        mock_provider1 = create_mock_provider("service1", "token1", 300.0)
+        mock_provider2 = create_mock_provider("service2", "token2", 300.0)
+
+        # æ³¨å†Œæ‰€æœ‰Providerï¼ˆé™¤äº†fotmobå› ä¸ºå®ƒéœ€è¦ç½‘ç»œï¼‰
+        await manager.register_provider(mock_provider1)
+        await manager.register_provider(mock_provider2)
+
+        # æµ‹è¯•è·å–ä¸åŒProviderçš„Token
+        token1 = await manager.get_token("service1")
+        token2 = await manager.get_token("service2")
+
+        assert token1.provider == "service1"
+        assert token2.provider == "service2"
+        assert token1.value != token2.value
+
+        # æµ‹è¯•ç¼“å­˜æœºåˆ¶
+        token1_cached = await manager.get_token("service1")
+        assert token1 is token1_cached
+        assert token1_cached.usage_count == 2
+
+        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
+        stats = await manager.get_stats()
+        assert stats['total_providers'] == 2
+        assert stats['valid_tokens'] == 2
+        assert stats['total_usage'] == 3
+
+        # æµ‹è¯•Tokenä¿¡æ¯
+        all_info = await manager.get_token_info()
+        assert "service1" in all_info
+        assert "service2" in all_info
+
+    @pytest.mark.asyncio
+    async def test_workflow_with_token_expiry_and_refresh(self):
+        """æµ‹è¯•Tokenè¿‡æœŸå’Œåˆ·æ–°å·¥ä½œæµç¨‹"""
+        manager = TokenManager(
+            default_ttl=2.0,
+            cache_refresh_threshold=1.0
+        )
+
+        # åˆ›å»ºçŸ­TTLçš„Provider
+        short_ttl_provider = create_mock_provider("short_ttl", "short_token", 2.0)
+        await manager.register_provider(short_ttl_provider)
+
+        # è·å–åˆå§‹Token
+        initial_token = await manager.get_token("short_ttl")
+        initial_value = initial_token.value
+
+        # ç­‰å¾…è¶…è¿‡åˆ·æ–°é˜ˆå€¼
+        await asyncio.sleep(1.2)
+
+        # å†æ¬¡è·å–åº”è¯¥è§¦å‘åˆ·æ–°
+        refreshed_token = await manager.get_token("short_ttl")
+
+        assert refreshed_token.value != initial_value
+        assert refreshed_token.is_valid == True
+        assert refreshed_token.ttl > 1.5  # æ–°Tokenåº”è¯¥æœ‰æ›´é•¿çš„TTL
+
+    @pytest.mark.asyncio
+    async def test_concurrent_workflow_safety(self):
+        """æµ‹è¯•å¹¶å‘å·¥ä½œæµç¨‹å®‰å…¨æ€§"""
+        manager = TokenManager()
+        provider = create_mock_provider("concurrent", "concurrent_token")
+        await manager.register_provider(provider)
+
+        async def worker_task(worker_id: int):
+            """å·¥ä½œä»»åŠ¡"""
+            token = await manager.get_token("concurrent")
+            await asyncio.sleep(0.01)  # æ¨¡æ‹Ÿå·¥ä½œ
+            return worker_id, token.usage_count
+
+        # å¯åŠ¨å¤šä¸ªå¹¶å‘ä»»åŠ¡
+        tasks = [worker_task(i) for i in range(20)]
+        results = await asyncio.gather(*tasks)
+
+        # éªŒè¯ç»“æœ
+        usage_counts = [result[1] for result in results]
+        max_usage = max(usage_counts)
+        min_usage = min(usage_counts)
+
+        # ä½¿ç”¨æ¬¡æ•°åº”è¯¥åˆ†å¸ƒåœ¨1åˆ°20ä¹‹é—´
+        assert min_usage >= 1
+        assert max_usage == 20
+
+        # æœ€ç»ˆTokenä½¿ç”¨æ¬¡æ•°åº”è¯¥æ˜¯20
+        final_token = await manager.get_token("concurrent")
+        assert final_token.usage_count == 20
+
+    @pytest.mark.asyncio
+    async def test_error_recovery_workflow(self):
+        """æµ‹è¯•é”™è¯¯æ¢å¤å·¥ä½œæµç¨‹"""
+        manager = TokenManager()
+
+        # åˆ›å»ºä¸€ä¸ªä¼šé—´æ­‡æ€§å¤±è´¥çš„Provider
+        class IntermittentFailureProvider:
+            def __init__(self):
+                self.call_count = 0
+
+            @property
+            def provider_name(self) -> str:
+                return "intermittent"
+
+            async def get_token(self) -> Token:
+                self.call_count += 1
+                if self.call_count <= 1:
+                    raise Exception("First call fails")
+                return Token(
+                    value="success_after_retry",
+                    token_type=TokenType.BEARER,
+                    provider="intermittent"
+                )
+
+            async def refresh_token(self, old_token: Optional[Token] = None) -> Token:
+                return Token(
+                    value="refreshed_token",
+                    token_type=TokenType.BEARER,
+                    provider="intermittent"
+                )
+
+        provider = IntermittentFailureProvider()
+
+        # æ³¨å†Œåº”è¯¥å¤±è´¥ï¼ˆå› ä¸ºç¬¬ä¸€æ¬¡get_tokenå¤±è´¥ï¼‰
+        with pytest.raises(AuthenticationError):
+            await manager.register_provider(provider)
+
+        # é‡ç½®call_countç„¶åæ‰‹åŠ¨æ·»åŠ åˆ°ç¼“å­˜ï¼ˆæ¨¡æ‹Ÿä¿®å¤åçš„æƒ…å†µï¼‰
+        provider.call_count = 0
+        try:
+            await provider.get_token()  # è¿™æ¬¡åº”è¯¥æˆåŠŸ
+        except:
+            pass
+
+        # æ‰‹åŠ¨æ³¨å†Œåˆ°ç¼“å­˜
+        if provider.call_count > 0:
+            token = await provider.get_token()
+            manager.provider_cache["intermittent"] = provider
+            manager.token_cache["intermittent"] = token
+
+            # ç°åœ¨åº”è¯¥å¯ä»¥æ­£å¸¸å·¥ä½œ
+            token = await manager.get_token("intermittent")
+            assert token.value == "success_after_retry"
+
+
+if __name__ == "__main__":
+    pytest.main([__file__, "-v"])
--- a/.dev/null
+++ b/scripts/auth_integration_test.py
@@ -0,0 +1,495 @@
+#!/usr/bin/env python3
+"""
+è®¤è¯é›†æˆæµ‹è¯•è„šæœ¬
+Authentication Integration Test Script
+
+è¯¥è„šæœ¬æ¨¡æ‹Ÿå®Œæ•´çš„è®¤è¯é“¾è·¯ï¼š
+1. TokenManager è·å–è®¤è¯ä»¤ç‰Œ
+2. RateLimiter æ§åˆ¶è¯·æ±‚é¢‘ç‡
+3. ProxyPool è·å–ä»£ç†
+4. å‘èµ·HTTPè¯·æ±‚ï¼ˆMockï¼‰
+5. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
+
+ä½¿ç”¨ç¤ºä¾‹:
+    python scripts/auth_integration_test.py --fotmob --requests 20
+    python scripts/auth_integration_test.py --demo --verbose
+
+ä½œè€…: Lead Collector Engineer
+åˆ›å»ºæ—¶é—´: 2025-12-06
+ç‰ˆæœ¬: 1.0.0
+"""
+
+import argparse
+import asyncio
+import json
+import sys
+import time
+from pathlib import Path
+from typing import Any, Dict, List, Optional
+from unittest.mock import AsyncMock, Mock
+
+# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ° Python è·¯å¾„
+project_root = Path(__file__).parent.parent
+sys.path.insert(0, str(project_root))
+
+from src.collectors.auth import (
+    TokenManager,
+    FotMobAuthProvider,
+    MockAuthProvider,
+    create_token_manager,
+    create_fotmob_provider,
+    create_mock_provider,
+)
+from src.collectors.rate_limiter import RateLimiter, create_rate_limiter
+from src.collectors.proxy_pool import ProxyPool, create_proxy_pool, RotationStrategy
+
+
+class AuthIntegrationTester:
+    """è®¤è¯é›†æˆæµ‹è¯•å™¨"""
+
+    def __init__(self, args):
+        # è®¾ç½®é»˜è®¤å€¼
+        self.num_requests = getattr(args, 'num_requests', 10)
+        self.rate_limit = getattr(args, 'rate_limit', 5.0)
+        self.burst = getattr(args, 'burst', 10)
+        self.use_proxies = getattr(args, 'use_proxies', False)
+        self.proxy_strategy = getattr(args, 'proxy_strategy', 'weighted_random')
+        self.fotmob = getattr(args, 'fotmob', False)
+        self.verbose = getattr(args, 'verbose', False)
+        self.token_info = getattr(args, 'token_info', False)
+        self.timeout = getattr(args, 'timeout', 10.0)
+        self.token_ttl = getattr(args, 'token_ttl', 300.0)
+        self.refresh_threshold = getattr(args, 'refresh_threshold', 60.0)
+        self.force_refresh = getattr(args, 'force_refresh', False)
+        self.request_timeout = getattr(args, 'request_timeout', 10.0)
+        self.concurrent = getattr(args, 'concurrent', False)
+
+        self.token_manager: Optional[TokenManager] = None
+        self.rate_limiter: Optional[RateLimiter] = None
+        self.proxy_pool: Optional[ProxyPool] = None
+
+        # ç»Ÿè®¡ä¿¡æ¯
+        self.stats = {
+            'total_requests': 0,
+            'successful_requests': 0,
+            'failed_requests': 0,
+            'token_refreshes': 0,
+            'proxy_rotations': 0,
+            'rate_limited_requests': 0,
+            'errors': []
+        }
+
+    async def setup(self) -> None:
+        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
+        print("ğŸ”§ è®¾ç½®è®¤è¯é›†æˆæµ‹è¯•ç¯å¢ƒ...")
+
+        # 1. è®¾ç½®TokenManager
+        self.token_manager = create_token_manager(
+            default_ttl=self.token_ttl,
+            cache_refresh_threshold=self.refresh_threshold
+        )
+
+        if self.fotmob:
+            # ä½¿ç”¨FotMobè®¤è¯
+            fotmob_provider = create_fotmob_provider(timeout=self.timeout)
+            await self.token_manager.register_provider(fotmob_provider)
+            print("âœ… æ³¨å†ŒFotMobè®¤è¯æä¾›è€…")
+        else:
+            # ä½¿ç”¨æ¨¡æ‹Ÿè®¤è¯
+            mock_provider = MockAuthProvider(
+                "demo_provider",
+                f"demo_token_{int(time.time())}",
+                self.token_ttl
+            )
+            await self.token_manager.register_provider(mock_provider)
+            print("âœ… æ³¨å†Œæ¨¡æ‹Ÿè®¤è¯æä¾›è€…")
+
+        # 2. è®¾ç½®RateLimiter
+        self.rate_limiter = create_rate_limiter({
+            "api_requests": {
+                "rate": self.rate_limit,
+                "burst": self.burst,
+                "max_wait_time": self.request_timeout
+            }
+        })
+        print(f"âœ… è®¾ç½®é€Ÿç‡é™åˆ¶å™¨: {self.rate_limit} QPS, çªå‘å®¹é‡ {self.burst}")
+
+        # 3. è®¾ç½®ProxyPool
+        if self.use_proxies:
+            proxy_urls = [
+                "http://127.0.0.1:8080",
+                "http://127.0.0.1:8081",
+                "http://127.0.0.1:8082",
+                "socks5://127.0.0.1:1080"
+            ]
+            self.proxy_pool = create_proxy_pool(
+                proxy_urls,
+                strategy=RotationStrategy(self.proxy_strategy),
+                auto_health_check=False
+            )
+            await self.proxy_pool.initialize()
+            print(f"âœ… è®¾ç½®ä»£ç†æ± : {len(proxy_urls)} ä¸ªä»£ç†ï¼Œç­–ç•¥: {self.proxy_strategy}")
+        else:
+            print("âš ï¸  è·³è¿‡ä»£ç†æ± è®¾ç½®ï¼ˆä¸ä½¿ç”¨ä»£ç†ï¼‰")
+
+        print("âœ… ç¯å¢ƒè®¾ç½®å®Œæˆ")
+
+    async def teardown(self) -> None:
+        """æ¸…ç†æµ‹è¯•ç¯å¢ƒ"""
+        print("ğŸ§¹ æ¸…ç†æµ‹è¯•ç¯å¢ƒ...")
+
+        if self.proxy_pool:
+            await self.proxy_pool.close()
+        print("âœ… ä»£ç†æ± å·²å…³é—­")
+
+    async def simulate_request(self, request_id: int) -> Dict[str, Any]:
+        """
+        æ¨¡æ‹Ÿå•ä¸ªHTTPè¯·æ±‚
+
+        Args:
+            request_id: è¯·æ±‚ID
+
+        Returns:
+            Dict[str, Any]: è¯·æ±‚ç»“æœ
+        """
+        start_time = time.monotonic()
+        result = {
+            'request_id': request_id,
+            'start_time': start_time,
+            'success': False,
+            'error': None,
+            'token_used': None,
+            'proxy_used': None,
+            'rate_limited': False,
+            'response_time': 0.0
+        }
+
+        try:
+            # 1. è·å–è®¤è¯ä»¤ç‰Œ
+            if self.verbose:
+                print(f"   ğŸ“‹ è¯·æ±‚ {request_id}: è·å–è®¤è¯ä»¤ç‰Œ...")
+
+            token = await self.token_manager.get_token(
+                "fotmob" if self.fotmob else "demo_provider",
+                force_refresh=self.force_refresh
+            )
+
+            if not token.is_valid:
+                raise Exception("Invalid authentication token")
+
+            result['token_used'] = token.value[:20] + "..."
+
+            # 2. åº”ç”¨é€Ÿç‡é™åˆ¶
+            if self.verbose:
+                print(f"   ğŸš¦ è¯·æ±‚ {request_id}: åº”ç”¨é€Ÿç‡é™åˆ¶...")
+
+            async with self.rate_limiter.acquire("api_requests"):
+                rate_limit_time = time.monotonic()
+                wait_time = rate_limit_time - start_time
+                if wait_time > 0.1:  # ç­‰å¾…è¶…è¿‡0.1ç§’
+                    result['rate_limited'] = True
+                    self.stats['rate_limited_requests'] += 1
+
+                # 3. è·å–ä»£ç†ï¼ˆå¦‚æœå¯ç”¨ï¼‰
+                proxy = None
+                if self.proxy_pool:
+                    if self.verbose:
+                        print(f"   ğŸŒ è¯·æ±‚ {request_id}: è·å–ä»£ç†...")
+
+                    proxy = await self.proxy_pool.get_proxy()
+                    if proxy:
+                        result['proxy_used'] = proxy.url
+                        self.stats['proxy_rotations'] += 1
+                    else:
+                        raise Exception("No available proxy")
+
+                # 4. æ¨¡æ‹ŸHTTPè¯·æ±‚
+                if self.verbose:
+                    print(f"   ğŸ“¡ è¯·æ±‚ {request_id}: å‘èµ·HTTPè¯·æ±‚...")
+
+                request_result = await self._mock_http_request(token, proxy if self.use_proxies else None)
+
+                if request_result['success']:
+                    result['success'] = True
+                    self.stats['successful_requests'] += 1
+                else:
+                    result['error'] = request_result['error']
+                    self.stats['failed_requests'] += 1
+
+            result['response_time'] = time.monotonic() - start_time
+
+            # 5. è®°å½•ä½¿ç”¨ç»Ÿè®¡
+            if self.use_proxies and proxy:
+                await self.proxy_pool.record_proxy_result(
+                    proxy, result['success'], result['response_time'] * 1000
+                )
+
+        except Exception as e:
+            result['error'] = str(e)
+            result['response_time'] = time.monotonic() - start_time
+            self.stats['failed_requests'] += 1
+            self.stats['errors'].append({
+                'request_id': request_id,
+                'error': str(e),
+                'timestamp': time.monotonic()
+            })
+
+        self.stats['total_requests'] += 1
+        return result
+
+    async def _mock_http_request(self, token, proxy=None) -> Dict[str, Any]:
+        """
+        æ¨¡æ‹ŸHTTPè¯·æ±‚
+
+        Args:
+            token: è®¤è¯ä»¤ç‰Œ
+            proxy: ä»£ç†å¯¹è±¡ï¼ˆå¯é€‰ï¼‰
+
+        Returns:
+            Dict[str, Any]: è¯·æ±‚ç»“æœ
+        """
+        try:
+            # æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
+            await asyncio.sleep(0.05 + (hash(token.value) % 10) * 0.01)  # 50-150ms
+
+            # æ¨¡æ‹ŸæˆåŠŸç‡ï¼ˆ80%ï¼‰
+            import random
+            if random.random() < 0.8:
+                return {
+                    'success': True,
+                    'status_code': 200,
+                    'response': {"data": "mock_response_data"}
+                }
+            else:
+                return {
+                    'success': False,
+                    'status_code': 500,
+                    'error': "Simulated server error"
+                }
+
+        except Exception as e:
+            return {
+                'success': False,
+                'error': str(e)
+            }
+
+    async def run_requests(self) -> None:
+        """è¿è¡Œè¯·æ±‚æµ‹è¯•"""
+        print(f"\nğŸš€ å¼€å§‹æ‰§è¡Œ {self.num_requests} ä¸ªè¯·æ±‚æµ‹è¯•...")
+        print(f"   é…ç½®: è®¤è¯={'FotMob' if self.fotmob else 'Demo'}")
+        print(f"   é…ç½®: é€Ÿç‡é™åˆ¶={self.rate_limit} QPS, çªå‘={self.burst}")
+        print(f"   é…ç½®: ä»£ç†={'å¯ç”¨' if self.use_proxies else 'ç¦ç”¨'}")
+
+        # è¯·æ±‚ç»“æœæ”¶é›†
+        results = []
+
+        if self.concurrent:
+            # å¹¶å‘è¯·æ±‚
+            print("ğŸ”„ ä½¿ç”¨å¹¶å‘è¯·æ±‚æ¨¡å¼...")
+            tasks = [
+                self.simulate_request(i)
+                for i in range(self.num_requests)
+            ]
+            results = await asyncio.gather(*tasks, return_exceptions=True)
+        else:
+            # ä¸²è¡Œè¯·æ±‚
+            print("ğŸ”„ ä½¿ç”¨ä¸²è¡Œè¯·æ±‚æ¨¡å¼...")
+            for i in range(self.num_requests):
+                result = await self.simulate_request(i)
+                results.append(result)
+
+        # å¤„ç†ç»“æœ
+        successful_results = [r for r in results if not isinstance(r, Exception) and r['success']]
+        failed_results = [r for r in results if not isinstance(r, Exception) and not r['success']]
+
+        # è¾“å‡ºç»“æœæ‘˜è¦
+        await self._print_results_summary(successful_results, failed_results, results)
+
+    async def _print_results_summary(self, successful: List[Dict], failed: List[Dict], all_results: List[Any]) -> None:
+        """æ‰“å°ç»“æœæ‘˜è¦"""
+        print(f"\nğŸ“Š è¯·æ±‚ç»“æœæ‘˜è¦:")
+        print(f"   æ€»è¯·æ±‚æ•°: {len(all_results)}")
+        print(f"   æˆåŠŸè¯·æ±‚: {len(successful)} ({len(successful)/len(all_results)*100:.1f}%)")
+        print(f"   å¤±è´¥è¯·æ±‚: {len(failed)} ({len(failed)/len(all_results)*100:.1f}%)")
+
+        if self.verbose and successful:
+            # æ˜¾ç¤ºæˆåŠŸçš„è¯·æ±‚
+            print(f"\nâœ… æˆåŠŸè¯·æ±‚è¯¦æƒ…:")
+            for result in successful[:5]:  # åªæ˜¾ç¤ºå‰5ä¸ª
+                print(f"   è¯·æ±‚ {result['request_id']}: "
+                      f"{result['response_time']:.3f}s, "
+                      f"Token: {result['token_used']}, "
+                      f"ä»£ç†: {result['proxy_used'] or 'æ— '}")
+
+        if self.verbose and failed:
+            # æ˜¾ç¤ºå¤±è´¥çš„è¯·æ±‚
+            print(f"\nâŒ å¤±è´¥è¯·æ±‚è¯¦æƒ…:")
+            for result in failed[:5]:  # åªæ˜¾ç¤ºå‰5ä¸ª
+                print(f"   è¯·æ±‚ {result['request_id']}: "
+                      f"{result['response_time']:.3f}s, "
+                      f"é”™è¯¯: {result['error']}")
+
+        # ä»£ç†ä½¿ç”¨ç»Ÿè®¡
+        if self.use_proxies and self.proxy_pool:
+            proxy_stats = self.proxy_pool.get_stats()
+            print(f"\nğŸŒ ä»£ç†æ± ç»Ÿè®¡:")
+            print(f"   æ€»ä»£ç†: {proxy_stats['total']}")
+            print(f"   æ´»è·ƒ: {proxy_stats['active']}")
+            print(f"   ç¦ç”¨: {proxy_stats['banned']}")
+            print(f"   å¥åº·: {proxy_stats['healthy']}")
+
+        # Token Managerç»Ÿè®¡
+        if self.token_manager:
+            token_stats = await self.token_manager.get_stats()
+            print(f"\nğŸ”‘ è®¤è¯ç®¡ç†å™¨ç»Ÿè®¡:")
+            print(f"   æä¾›è€…: {token_stats['total_providers']}")
+            print(f"   æœ‰æ•ˆä»¤ç‰Œ: {token_stats['valid_tokens']}")
+            print(f"   è¿‡æœŸä»¤ç‰Œ: {token_stats['expired_tokens']}")
+            print(f"   æ€»ä½¿ç”¨æ¬¡æ•°: {token_stats['total_usage']}")
+
+        # é€Ÿç‡é™åˆ¶ç»Ÿè®¡
+        print(f"\nğŸš¦ é€Ÿç‡é™åˆ¶ç»Ÿè®¡:")
+        print(f"   è¢«é™æµè¯·æ±‚: {self.stats['rate_limited_requests']}")
+        print(f"   é™æµç‡: {self.stats['rate_limited_requests']/self.stats['total_requests']*100:.1f}%")
+
+    async def print_detailed_stats(self) -> None:
+        """æ‰“å°è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯"""
+        print(f"\nğŸ“‹ è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯:")
+        print(json.dumps(self.stats, indent=2, ensure_ascii=False))
+
+        if self.token_info and self.token_manager:
+            token_info = await self.token_manager.get_token_info()
+            print(f"\nğŸ”‘ ä»¤ç‰Œè¯¦ç»†ä¿¡æ¯:")
+            print(json.dumps(token_info, indent=2, ensure_ascii=False))
+
+
+def parse_args():
+    """è§£æå‘½ä»¤è¡Œå‚æ•°"""
+    parser = argparse.ArgumentParser(
+        description="è®¤è¯é›†æˆæµ‹è¯•å·¥å…·",
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+        epilog="""
+ç¤ºä¾‹ç”¨æ³•:
+  # åŸºç¡€æµ‹è¯•
+  python scripts/auth_integration_test.py --demo --requests 10
+
+  # FotMobè®¤è¯æµ‹è¯•
+  python scripts/auth_integration_test.py --fotmob --requests 20
+
+  # é«˜å¹¶å‘æµ‹è¯•
+  python scripts/auth_integration_test.py --demo --requests 100 --concurrent
+
+  # ä½¿ç”¨ä»£ç†æ± 
+  python scripts/auth_integration_test.py --demo --requests 50 --use-proxies
+        """
+    )
+
+    # è®¤è¯é…ç½®
+    parser.add_argument(
+        "--fotmob",
+        action="store_true",
+        help="ä½¿ç”¨FotMobè®¤è¯ï¼ˆé»˜è®¤ä½¿ç”¨Demoè®¤è¯ï¼‰"
+    )
+    parser.add_argument(
+        "--demo",
+        action="store_true",
+        help="ä½¿ç”¨Demoè®¤è¯ï¼ˆé»˜è®¤ï¼‰"
+    )
+    parser.add_argument(
+        "--token-ttl",
+        type=float,
+        default=300.0,
+        help="ä»¤ç‰Œç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰ (é»˜è®¤: 300)"
+    )
+    parser.add_argument(
+        "--refresh-threshold",
+        type=float,
+        default=60.0,
+        help="ä»¤ç‰Œåˆ·æ–°é˜ˆå€¼ï¼ˆç§’ï¼‰ (é»˜è®¤: 60)"
+    )
+    parser.add_argument(
+        "--force-refresh",
+        action="store_true",
+        help="å¼ºåˆ¶åˆ·æ–°ä»¤ç‰Œ"
+    )
+
+    # è¯·æ±‚é…ç½®
+    parser.add_argument(
+        "--requests", "-n",
+        type=int,
+        default=10,
+        help="è¯·æ±‚æ•°é‡ (é»˜è®¤: 10)"
+    )
+    parser.add_argument(
+        "--concurrent",
+        action="store_true",
+        help="å¹¶å‘æ‰§è¡Œè¯·æ±‚"
+    )
+    parser.add_argument(
+        "--rate-limit",
+        type=float,
+        default=5.0,
+        help="é€Ÿç‡é™åˆ¶ QPS (é»˜è®¤: 5.0)"
+    )
+    parser.add_argument(
+        "--burst",
+        type=int,
+        default=10,
+        help="çªå‘å®¹é‡ (é»˜è®¤: 10)"
+    )
+    parser.add_argument(
+        "--request-timeout",
+        type=float,
+        default=10.0,
+        help="è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ (é»˜è®¤: 10)"
+    )
+
+    # ä»£ç†é…ç½®
+    parser.add_argument(
+        "--use-proxies",
+        action="store_true",
+        help="å¯ç”¨ä»£ç†æ± "
+    )
+    parser.add_argument(
+        "--proxy-strategy",
+        choices=["random", "round_robin", "weighted_random", "health_first"],
+        default="weighted_random",
+        help="ä»£ç†è½®è¯¢ç­–ç•¥ (é»˜è®¤: weighted_random)"
+    )
+
+    # è¾“å‡ºé…ç½®
+    parser.add_argument(
+        "--verbose", "-v",
+        action="store_true",
+        help="è¯¦ç»†è¾“å‡º"
+    )
+    parser.add_argument(
+        "--token-info",
+        action="store_true",
+        help="æ˜¾ç¤ºä»¤ç‰Œè¯¦ç»†ä¿¡æ¯"
+    )
+    parser.add_argument(
+        "--timeout",
+        type=float,
+        default=10.0,
+        help="ç½‘ç»œè¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ (é»˜è®¤: 10)"
+    )
+
+    args = parser.parse_args()
+
+    # é»˜è®¤ä½¿ç”¨demoè®¤è¯
+    if not args.fotmob and not args.demo:
+        args.demo = True
+
+    return args
+
+
+async def main():
+    """ä¸»å‡½æ•°"""
+    args = parse_args()
+
+    try:
+        tester = AuthIntegrationTester(args)
+        await tester.setup()
+        await tester.run_requests()
+        await tester.print_detailed_stats()
+
+    except KeyboardInterrupt:
+        print("\nâš ï¸  ç”¨æˆ·ä¸­æ–­æ“ä½œ")
+    except Exception as e:
+        print(f"âŒ é”™è¯¯: {e}")
+        if args.verbose:
+            import traceback
+            traceback.print_exc()
+        sys.exit(1)
+    finally:
+        if 'tester' in locals():
+            await tester.teardown()
+
+
+if __name__ == "__main__":
+    asyncio.run(main())