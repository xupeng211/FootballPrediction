diff --git a/src/database/compat.py b/src/database/compat.py
new file mode 100644
index 000000000..b4f731bf2
--- /dev/null
+++ b/src/database/compat.py
@@ -0,0 +1,202 @@
+"""
+数据库兼容适配器（临时过渡用）
+Database Compatibility Adapter (Temporary Migration Helper)
+
+⚠️ 注意：这是临时适配器，用于逐步迁移到异步接口
+⚠️ WARNING: This is a temporary adapter for gradual migration to async interfaces
+
+使用方法：
+1. 短期：直接替换 import 语句
+   from src.database.compat import fetch_all_sync, fetch_one_sync, execute_sync
+
+2. 中期：逐步将函数改为 async
+   async def my_function():
+       result = await fetch_all(query, params)
+
+3. 长期：完全迁移到 async_manager.py
+   from src.database.async_manager import fetch_all
+"""
+
+import asyncio
+import logging
+from typing import Any, Optional, Dict, List
+from sqlalchemy import text
+
+from .async_manager import fetch_all, fetch_one, execute
+
+logger = logging.getLogger(__name__)
+
+
+def fetch_all_sync(query, params: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
+    """
+    同步版本的 fetch_all（适配器）
+
+    Args:
+        query: SQL查询语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        查询结果列表
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 fetch_all_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, fetch_all(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(fetch_all(query, params))
+
+
+def fetch_one_sync(query, params: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, Any]]:
+    """
+    同步版本的 fetch_one（适配器）
+
+    Args:
+        query: SQL查询语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        单个查询结果字典或None
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 fetch_one_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, fetch_one(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(fetch_one(query, params))
+
+
+def execute_sync(query, params: Optional[Dict[str, Any]] = None) -> Any:
+    """
+    同步版本的 execute（适配器）
+
+    Args:
+        query: SQL语句或SQLAlchemy对象
+        params: 查询参数字典
+
+    Returns:
+        执行结果
+
+    Warning:
+        此函数使用 asyncio.run()，不适用于已有事件循环的环境
+        仅用于临时迁移，尽快改为异步版本
+    """
+    logger.warning(
+        "⚠️ 使用同步适配器 execute_sync，建议改为异步版本。"
+        "文件位置需要重构以支持异步操作。"
+    )
+    try:
+        # 尝试在现有事件循环中运行
+        loop = asyncio.get_running_loop()
+        # 如果已有事件循环，创建任务
+        import concurrent.futures
+        with concurrent.futures.ThreadPoolExecutor() as executor:
+            future = executor.submit(asyncio.run, execute(query, params))
+            return future.result()
+    except RuntimeError:
+        # 没有事件循环，使用 asyncio.run
+        return asyncio.run(execute(query, params))
+
+
+# ============================================================================
+# 向后兼容的包装函数（用于最常见的场景）
+# ============================================================================
+
+class DatabaseCompatManager:
+    """
+    数据库兼容管理器
+
+    提供与旧 DatabaseManager 类似的接口，但内部使用新的异步实现
+    临时用于减少迁移风险
+    """
+
+    def __init__(self):
+        """初始化兼容管理器"""
+        logger.warning("⚠️ 使用 DatabaseCompatManager，建议迁移到 AsyncDatabaseManager")
+
+    def get_session(self):
+        """获取数据库会话（同步接口 - 临时兼容）"""
+        logger.warning("⚠️ get_session() 同步接口已弃用，请改为异步实现")
+        # 返回一个兼容的会话包装器
+        return SyncSessionWrapper()
+
+
+class SyncSessionWrapper:
+    """
+    同步会话包装器（临时兼容用）
+
+    提供类似旧版同步会话的接口，但内部使用异步实现
+    """
+
+    def __init__(self):
+        self._closed = False
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+
+    def execute(self, query, params=None):
+        """执行查询（同步包装）"""
+        if isinstance(query, str):
+            query = text(query)
+        return execute_sync(query, params)
+
+    def fetchall(self, query, params=None):
+        """获取所有结果（同步包装）"""
+        return fetch_all_sync(query, params)
+
+    def fetchone(self, query, params=None):
+        """获取单个结果（同步包装）"""
+        return fetch_one_sync(query, params)
+
+    def close(self):
+        """关闭会话"""
+        self._closed = True
+        logger.debug("SyncSessionWrapper 已关闭")
+
+    def commit(self):
+        """提交事务（兼容方法）"""
+        logger.debug("SyncSessionWrapper commit (兼容方法)")
+
+    def rollback(self):
+        """回滚事务（兼容方法）"""
+        logger.debug("SyncSessionWrapper rollback (兼容方法)")
+
+
+# 导出接口
+__all__ = [
+    # 主要适配器函数
+    "fetch_all_sync",
+    "fetch_one_sync",
+    "execute_sync",
+    # 兼容管理器类
+    "DatabaseCompatManager",
+    "SyncSessionWrapper",
+]
\ No newline at end of file
diff --git a/tests/unit/test_async_manager.py b/tests/unit/test_async_manager.py
new file mode 100644
index 000000000..0ed271f0e
--- /dev/null
+++ b/tests/unit/test_async_manager.py
@@ -0,0 +1,460 @@
+"""
+异步数据库管理器单元测试
+Unit Tests for Async Database Manager
+
+测试新的异步数据库接口的正确性、性能和边界情况
+"""
+
+import pytest
+import asyncio
+from unittest.mock import AsyncMock, MagicMock, patch
+from sqlalchemy import text, create_engine
+from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
+from typing import Dict, Any, Optional
+
+from src.database.async_manager import (
+    AsyncDatabaseManager,
+    initialize_database,
+    get_database_manager,
+    get_db_session,
+    fetch_all,
+    fetch_one,
+    execute,
+    DatabaseRole
+)
+
+
+class TestAsyncDatabaseManager:
+    """异步数据库管理器测试类"""
+
+    @pytest.fixture
+    async def test_db_url(self):
+        """测试数据库URL"""
+        return "sqlite+aiosqlite:///:memory:"
+
+    @pytest.fixture
+    async def postgres_db_url(self):
+        """PostgreSQL测试数据库URL（用于连接池测试）"""
+        return "postgresql+asyncpg://postgres:postgres@localhost:5432/test_football_prediction"
+
+    @pytest.fixture
+    async def db_manager(self, test_db_url):
+        """创建测试数据库管理器实例"""
+        manager = AsyncDatabaseManager()
+        # SQLite不支持连接池参数，使用简单配置
+        manager.initialize(test_db_url, echo=False, pool_size=None)
+        yield manager
+        # 清理
+        await manager.close()
+
+    async def test_singleton_pattern(self, test_db_url):
+        """测试单例模式"""
+        manager1 = AsyncDatabaseManager()
+        manager2 = AsyncDatabaseManager()
+
+        assert manager1 is manager2, "应该返回同一个实例"
+
+        # 初始化后应该是同一个实例
+        manager1.initialize(test_db_url)
+        manager3 = AsyncDatabaseManager()
+        assert manager1 is manager3, "初始化后仍应该是同一个实例"
+
+    async def test_initialization(self, test_db_url):
+        """测试初始化"""
+        manager = AsyncDatabaseManager()
+
+        # 初始化前
+        assert not manager.is_initialized, "初始化前应该是未初始化状态"
+
+        # 初始化
+        manager.initialize(test_db_url)
+
+        # 初始化后
+        assert manager.is_initialized, "初始化后应该是已初始化状态"
+        assert manager.engine is not None, "引擎应该存在"
+        assert manager.session_factory is not None, "会话工厂应该存在"
+
+    async def test_duplicate_initialization_warning(self, test_db_url, caplog):
+        """测试重复初始化警告"""
+        manager = AsyncDatabaseManager()
+        manager.initialize(test_db_url)
+
+        # 第二次初始化应该产生警告
+        with caplog.at_level("WARNING"):
+            manager.initialize(test_db_url)
+
+        assert "已经初始化" in caplog.text, "应该记录重复初始化警告"
+
+    async def test_connection_check(self, db_manager):
+        """测试连接检查"""
+        # 健康连接
+        status = await db_manager.check_connection()
+        assert status["status"] == "healthy", "连接应该是健康的"
+        assert status["response_time_ms"] is not None, "应该有响应时间"
+        assert status["database_url"] is not None, "应该有数据库URL"
+
+    async def test_connection_check_uninitialized(self):
+        """测试未初始化连接检查"""
+        manager = AsyncDatabaseManager()
+
+        status = await manager.check_connection()
+        assert status["status"] == "error", "未初始化应该是错误状态"
+        assert "未初始化" in status["message"], "错误消息应该包含未初始化"
+
+    async def test_url_conversion(self):
+        """测试URL自动转换"""
+        manager = AsyncDatabaseManager()
+
+        # 测试 postgresql → postgresql+asyncpg
+        manager.initialize("postgresql://user:pass@localhost/db")
+        assert "+asyncpg" in manager._database_url, "应该自动转换为异步URL"
+
+        # 测试 sqlite → sqlite+aiosqlite
+        manager = AsyncDatabaseManager()  # 重置
+        manager.initialize("sqlite:///test.db")
+        assert "+aiosqlite" in manager._database_url, "应该自动转换为异步SQLite URL"
+
+    async def test_engine_configuration(self, test_db_url):
+        """测试引擎配置"""
+        manager = AsyncDatabaseManager()
+
+        custom_config = {
+            "pool_size": 5,
+            "max_overflow": 10,
+            "echo": True
+        }
+
+        manager.initialize(test_db_url, **custom_config)
+
+        # 验证配置是否应用（通过引擎属性检查）
+        engine = manager.engine
+        assert engine.pool.size() == 5, "连接池大小应该正确设置"
+        # 注意：其他配置可能需要通过其他方式验证
+
+
+class TestGlobalFunctions:
+    """全局函数测试类"""
+
+    @pytest.fixture
+    async def setup_database(self):
+        """设置测试数据库"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+    async def test_initialize_database(self, setup_database):
+        """测试全局初始化函数"""
+        manager = get_database_manager()
+        assert manager.is_initialized, "全局初始化应该成功"
+
+    async def test_get_database_manager_uninitialized(self):
+        """测试未初始化时获取管理器"""
+        # 创建新的管理器实例（未初始化）
+        from src.database.async_manager import _db_manager
+        _db_manager._initialized = False
+
+        with pytest.raises(RuntimeError, match="未初始化"):
+            get_database_manager()
+
+    async def test_get_db_session_context_manager(self, setup_database):
+        """测试数据库会话上下文管理器"""
+        async with get_db_session() as session:
+            assert isinstance(session, AsyncSession), "应该返回AsyncSession实例"
+            assert session.is_active, "会话应该是活跃状态"
+
+        # 会话应该自动关闭
+        assert not session.is_active, "会话应该已关闭"
+
+    async def test_get_db_session_error_handling(self, setup_database):
+        """测试会话错误处理"""
+        with patch('src.database.async_manager.get_database_manager') as mock_get_manager:
+            mock_session = AsyncMock()
+            mock_session.execute.side_effect = Exception("Test error")
+
+            mock_manager = AsyncMock()
+            mock_manager.session_factory.return_value.__aenter__.return_value = mock_session
+            mock_get_manager.return_value = mock_manager
+
+            with pytest.raises(Exception, match="Test error"):
+                async with get_db_session() as session:
+                    await session.execute(text("SELECT 1"))
+
+            # 验证回滚被调用
+            mock_session.rollback.assert_called_once()
+
+
+class TestConvenienceMethods:
+    """便捷方法测试类"""
+
+    @pytest.fixture
+    async def test_db_with_data(self):
+        """创建包含测试数据的数据库"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_users (
+                    id INTEGER PRIMARY KEY,
+                    name TEXT NOT NULL,
+                    email TEXT UNIQUE
+                )
+            """))
+            await session.commit()
+
+        yield test_url
+
+    async def test_fetch_all_success(self, test_db_with_data):
+        """测试 fetch_all 成功案例"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com'),
+                ('Bob', 'bob@test.com')
+            """))
+            await session.commit()
+
+        # 测试 fetch_all
+        results = await fetch_all(text("SELECT * FROM test_users"))
+
+        assert len(results) == 2, "应该返回2条记录"
+        assert results[0]["name"] == "Alice", "第一条记录应该是Alice"
+        assert results[1]["name"] == "Bob", "第二条记录应该是Bob"
+
+    async def test_fetch_all_with_params(self, test_db_with_data):
+        """测试 fetch_all 带参数"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com'),
+                ('Bob', 'bob@test.com')
+            """))
+            await session.commit()
+
+        # 测试带参数的查询
+        results = await fetch_all(
+            text("SELECT * FROM test_users WHERE name = :name"),
+            {"name": "Alice"}
+        )
+
+        assert len(results) == 1, "应该返回1条记录"
+        assert results[0]["email"] == "alice@test.com", "邮箱应该正确"
+
+    async def test_fetch_all_empty_result(self, test_db_with_data):
+        """测试 fetch_all 空结果"""
+        results = await fetch_all(text("SELECT * FROM test_users WHERE 1=0"))
+        assert results == [], "空表查询应该返回空列表"
+
+    async def test_fetch_one_success(self, test_db_with_data):
+        """测试 fetch_one 成功案例"""
+        # 插入测试数据
+        async with get_db_session() as session:
+            await session.execute(text("""
+                INSERT INTO test_users (name, email) VALUES
+                ('Alice', 'alice@test.com')
+            """))
+            await session.commit()
+
+        # 测试 fetch_one
+        result = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Alice'"))
+
+        assert result is not None, "应该返回结果"
+        assert result["name"] == "Alice", "名称应该是Alice"
+        assert result["email"] == "alice@test.com", "邮箱应该正确"
+
+    async def test_fetch_one_not_found(self, test_db_with_data):
+        """测试 fetch_one 未找到"""
+        result = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Nonexistent'"))
+        assert result is None, "未找到应该返回None"
+
+    async def test_execute_insert(self, test_db_with_data):
+        """测试 execute 插入操作"""
+        result = await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Charlie", "email": "charlie@test.com"}
+        )
+
+        # 验证插入成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Charlie'"))
+        assert user is not None, "用户应该被插入"
+        assert user["email"] == "charlie@test.com", "邮箱应该正确"
+
+    async def test_execute_update(self, test_db_with_data):
+        """测试 execute 更新操作"""
+        # 插入初始数据
+        await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Dave", "email": "dave@old.com"}
+        )
+
+        # 更新数据
+        await execute(
+            text("UPDATE test_users SET email = :new_email WHERE name = :name"),
+            {"name": "Dave", "new_email": "dave@new.com"}
+        )
+
+        # 验证更新成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Dave'"))
+        assert user["email"] == "dave@new.com", "邮箱应该被更新"
+
+    async def test_execute_delete(self, test_db_with_data):
+        """测试 execute 删除操作"""
+        # 插入初始数据
+        await execute(
+            text("INSERT INTO test_users (name, email) VALUES (:name, :email)"),
+            {"name": "Eve", "email": "eve@test.com"}
+        )
+
+        # 删除数据
+        await execute(text("DELETE FROM test_users WHERE name = 'Eve'"))
+
+        # 验证删除成功
+        user = await fetch_one(text("SELECT * FROM test_users WHERE name = 'Eve'"))
+        assert user is None, "用户应该被删除"
+
+    async def test_string_queries(self, test_db_with_data):
+        """测试字符串SQL查询"""
+        # 插入测试数据
+        await execute(
+            "INSERT INTO test_users (name, email) VALUES (?, ?)",
+            {"name": "Frank", "email": "frank@test.com"}
+        )
+
+        # 使用字符串查询
+        result = await fetch_one("SELECT * FROM test_users WHERE name = 'Frank'")
+        assert result is not None, "应该找到Frank"
+        assert result["email"] == "frank@test.com", "邮箱应该正确"
+
+
+class TestErrorHandling:
+    """错误处理测试类"""
+
+    async def test_database_connection_error(self):
+        """测试数据库连接错误"""
+        with pytest.raises(Exception):
+            # 使用无效的数据库URL
+            manager = AsyncDatabaseManager()
+            manager.initialize("sqlite+aiosqlite:///invalid/path/test.db")
+            await manager.check_connection()
+
+    async def test_sql_syntax_error(self):
+        """测试SQL语法错误"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        with pytest.raises(Exception):
+            await fetch_one(text("INVALID SQL QUERY"))
+
+    async def test_constraint_violation(self):
+        """测试约束违反"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建带唯一约束的表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_unique (
+                    id INTEGER PRIMARY KEY,
+                    email TEXT UNIQUE NOT NULL
+                )
+            """))
+            await session.commit()
+
+        # 插入第一条记录
+        await execute(
+            text("INSERT INTO test_unique (email) VALUES (:email)"),
+            {"email": "test@example.com"}
+        )
+
+        # 尝试插入重复记录应该失败
+        with pytest.raises(Exception):
+            await execute(
+                text("INSERT INTO test_unique (email) VALUES (:email)"),
+                {"email": "test@example.com"}
+            )
+
+
+class TestPerformance:
+    """性能测试类"""
+
+    async def test_concurrent_access(self):
+        """测试并发访问"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_concurrent (
+                    id INTEGER PRIMARY KEY,
+                    value TEXT
+                )
+            """))
+            await session.commit()
+
+        # 并发插入测试
+        async def insert_record(record_id):
+            await execute(
+                text("INSERT INTO test_concurrent (id, value) VALUES (:id, :value)"),
+                {"id": record_id, "value": f"record_{record_id}"}
+            )
+
+        # 并发执行插入
+        tasks = [insert_record(i) for i in range(10)]
+        await asyncio.gather(*tasks)
+
+        # 验证所有记录都被插入
+        results = await fetch_all(text("SELECT COUNT(*) as count FROM test_concurrent"))
+        assert results[0]["count"] == 10, "应该插入10条记录"
+
+    async def test_batch_operation_performance(self):
+        """测试批量操作性能"""
+        test_url = "sqlite+aiosqlite:///:memory:"
+        initialize_database(test_url)
+
+        # 创建测试表
+        async with get_db_session() as session:
+            await session.execute(text("""
+                CREATE TABLE test_batch (
+                    id INTEGER PRIMARY KEY,
+                    name TEXT,
+                    value INTEGER
+                )
+            """))
+            await session.commit()
+
+        # 准备批量数据
+        batch_data = [
+            {"id": i, "name": f"item_{i}", "value": i * 10}
+            for i in range(100)
+        ]
+
+        # 测试批量插入性能
+        import time
+        start_time = time.time()
+
+        await execute(
+            text("""
+                INSERT INTO test_batch (id, name, value)
+                VALUES (:id, :name, :value)
+            """),
+            batch_data
+        )
+
+        end_time = time.time()
+        duration = end_time - start_time
+
+        # 验证结果
+        results = await fetch_all(text("SELECT COUNT(*) as count FROM test_batch"))
+        assert results[0]["count"] == 100, "应该插入100条记录"
+
+        # 性能断言（批量操作应该很快）
+        assert duration < 5.0, f"批量操作应该很快，但耗时: {duration:.2f}秒"
+
+
+# 测试标记
+pytest.mark.unit = pytest.mark.unit
+pytest.mark.asyncio = pytest.mark.asyncio
+pytest.mark.database = pytest.mark.database
\ No newline at end of file
