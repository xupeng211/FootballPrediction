--- a/src/utils/dict_utils.py+++ b/src/utils/dict_utils.py@@ -10,7 +10,7 @@     """字典处理工具类."""
 
     @staticmethod
-    def deep_merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
+async def deep_merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
         """深度合并字典 - 递归合并嵌套字典,dict2的值会覆盖dict1中的同名键."""
         result = dict1.copy()
         for key, value in dict2.items():
@@ -27,7 +27,7 @@         return result
 
     @staticmethod
-    def flatten_dict(
+async def flatten_dict(
         d: dict[str, Any], parent_key: str = "", sep: str = "."
     ) -> dict[str, Any]:
         # 构建新的键名,使用分隔符连接层级关系
@@ -42,12 +42,12 @@         return dict(items)
 
     @staticmethod
-    def filter_none_values(d: dict[str, Any]) -> dict[str, Any]:
+async def filter_none_values(d: dict[str, Any]) -> dict[str, Any]:
         """过滤掉None值的键值对."""
         return {k: v for k, v in d.items() if v is not None}
 
     @staticmethod
-    def filter_empty_values(d: dict[str, Any]) -> dict[str, Any]:
+async def filter_empty_values(d: dict[str, Any]) -> dict[str, Any]:
         """过滤掉空值（空字符串,空列表,空字典）的键值对."""
         return {
             k: v
@@ -56,17 +56,17 @@         }
 
     @staticmethod
-    def filter_by_keys(d: dict[str, Any], keys: list[str]) -> dict[str, Any]:
+async def filter_by_keys(d: dict[str, Any], keys: list[str]) -> dict[str, Any]:
         """只保留指定的键."""
         return {k: v for k, v in d.items() if k in keys}
 
     @staticmethod
-    def exclude_keys(d: dict[str, Any], keys: list[str]) -> dict[str, Any]:
+async def exclude_keys(d: dict[str, Any], keys: list[str]) -> dict[str, Any]:
         """排除指定的键."""
         return {k: v for k, v in d.items() if k not in keys}
 
     @staticmethod
-    def get_nested_value(
+async def get_nested_value(
         d: dict[str, Any], key_path: str | list[str], default: Any = None
     ) -> Any:
         """获取嵌套字典中的值.
@@ -96,7 +96,7 @@             return default
 
     @staticmethod
-    def set_nested_value(
+async def set_nested_value(
         d: dict[str, Any], key_path: str | list[str], value: Any
     ) -> None:
         """设置嵌套字典中的值.
@@ -125,39 +125,39 @@         current[keys[-1]] = value
 
     @staticmethod
-    def rename_keys(d: dict[str, Any], key_map: dict[str, str]) -> dict[str, Any]:
+async def rename_keys(d: dict[str, Any], key_map: dict[str, str]) -> dict[str, Any]:
         """重命名字典的键."""
-        return {key_map.get(k, k): v for k, v in d.items()}
-
-    @staticmethod
-    def swap_keys(d: dict[str, Any]) -> dict[str, Any]:
+        return {key_map.await get(k, k): v for k, v in d.items()}
+
+    @staticmethod
+async def swap_keys(d: dict[str, Any]) -> dict[str, Any]:
         """交换字典的键和值."""
         return {str(v): k for k, v in d.items()}
 
     @staticmethod
-    def invert_dict(d: dict[str, Any]) -> dict[Any, str]:
+async def invert_dict(d: dict[str, Any]) -> dict[Any, str]:
         """反转字典（键值互换）."""
         return {v: k for k, v in d.items()}
 
     @staticmethod
-    def pick_values(d: dict[str, Any], keys: list[str]) -> list[Any]:
+async def pick_values(d: dict[str, Any], keys: list[str]) -> list[Any]:
         """提取指定键的值."""
-        return [d.get(k) for k in keys]
-
-    @staticmethod
-    def count_values(d: dict[str, Any]) -> int:
+        return [d.await get(k) for k in keys]
+
+    @staticmethod
+async def count_values(d: dict[str, Any]) -> int:
         """计算字典中值的总数."""
         return len(d)
 
     @staticmethod
-    def is_empty(d: dict[str, Any] | None) -> bool:
+async def is_empty(d: dict[str, Any] | None) -> bool:
         """检查字典是否为空."""
         if d is None:
             return True
         return len(d) == 0
 
     @staticmethod
-    def merge_list(dicts: list[dict[str, Any]]) -> dict[str, Any]:
+async def merge_list(dicts: list[dict[str, Any]]) -> dict[str, Any]:
         """合并多个字典（后面的会覆盖前面的）."""
         result = {}
         for d in dicts:
@@ -166,19 +166,19 @@         return result
 
     @staticmethod
-    def chunk_dict(d: dict[str, Any], chunk_size: int) -> list[dict[str, Any]]:
+async def chunk_dict(d: dict[str, Any], chunk_size: int) -> list[dict[str, Any]]:
         items = list(d.items())
         return [
             dict(items[i : i + chunk_size]) for i in range(0, len(items), chunk_size)
         ]
 
     @staticmethod
-    def sort_keys(d: dict[str, Any], reverse: bool = False) -> dict[str, Any]:
+async def sort_keys(d: dict[str, Any], reverse: bool = False) -> dict[str, Any]:
         """按键排序."""
         return dict(sorted(d.items(), key=lambda item: item[0], reverse=reverse))
 
     @staticmethod
-    def group_by_first_char(d: dict[str, Any]) -> dict[str, dict[str, Any]]:
+async def group_by_first_char(d: dict[str, Any]) -> dict[str, dict[str, Any]]:
         """按首字母分组."""
         result = {}
         for key, value in d.items():
@@ -189,7 +189,7 @@         return result
 
     @staticmethod
-    def validate_required_keys(
+async def validate_required_keys(
         d: dict[str, Any], required_keys: list[str]
     ) -> list[str]:
         """验证必需的键是否存在."""
@@ -200,10 +200,10 @@         return missing
 
     @staticmethod
-    def convert_keys_case(d: dict[str, Any], case: str = "lower") -> dict[str, Any]:
+async def convert_keys_case(d: dict[str, Any], case: str = "lower") -> dict[str, Any]:
         """转换键的大小写（递归处理嵌套字典）."""
 
-        def _convert(obj, case):
+async def _convert(obj, case):
             if isinstance(obj, dict):
                 if case == "lower":
                     return {k.lower(): _convert(v, case) for k, v in obj.items()}
@@ -221,62 +221,62 @@         return _convert(d, case)
 
     @staticmethod
-    def deep_clone(d: dict[str, Any]) -> dict[str, Any]:
+async def deep_clone(d: dict[str, Any]) -> dict[str, Any]:
         """深度克隆字典."""
         import copy
 
         return copy.deepcopy(d)
 
     @staticmethod
-    def merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
+async def merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
         """浅度合并字典 - dict2的值会覆盖dict1中的同名键."""
         result = dict1.copy()
         result.update(dict2)
         return result
 
     @staticmethod
-    def get(d: dict[str, Any], key: str, default: Any = None) -> Any:
+async def get(d: dict[str, Any], key: str, default: Any = None) -> Any:
         """获取字典值，支持默认值."""
-        return d.get(key, default)
-
-    @staticmethod
-    def has_key(d: dict[str, Any], key: str) -> bool:
+        return d.await get(key, default)
+
+    @staticmethod
+async def has_key(d: dict[str, Any], key: str) -> bool:
         """检查字典是否包含指定键."""
         return key in d
 
     @staticmethod
-    def filter_keys(d: dict[str, Any], filter_func) -> dict[str, Any]:
+async def filter_keys(d: dict[str, Any], filter_func) -> dict[str, Any]:
         """根据过滤函数筛选键值对."""
         return {k: v for k, v in d.items() if filter_func(k)}
 
 
 # 顶级函数，用于直接导入
-def deep_merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
+async def deep_merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
     """深度合并字典 - 递归合并嵌套字典,dict2的值会覆盖dict1中的同名键."""
     return DictUtils.deep_merge(dict1, dict2)
 
 
-def merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
+async def merge(dict1: dict[str, Any], dict2: dict[str, Any]) -> dict[str, Any]:
     """浅度合并字典 - dict2的值会覆盖dict1中的同名键."""
     return DictUtils.merge(dict1, dict2)
 
 
-def deep_clone(d: dict[str, Any]) -> dict[str, Any]:
+async def deep_clone(d: dict[str, Any]) -> dict[str, Any]:
     """深度克隆字典."""
     return DictUtils.deep_clone(d)
 
 
-def get(d: dict[str, Any], key: str, default: Any = None) -> Any:
+async def get(d: dict[str, Any], key: str, default: Any = None) -> Any:
     """获取字典值，支持默认值."""
-    return DictUtils.get(d, key, default)
-
-
-def has_key(d: dict[str, Any], key: str) -> bool:
+    return DictUtils.await get(d, key, default)
+
+
+async def has_key(d: dict[str, Any], key: str) -> bool:
     """检查字典是否包含指定键."""
     return DictUtils.has_key(d, key)
 
 
-def get_nested_value(
+async def get_nested_value(
     d: dict[str, Any], key_path: str | list[str], default: Any = None
 ) -> Any:
     """获取嵌套字典中的值."""
@@ -296,7 +296,7 @@         return default
 
 
-def set_nested_value(
+async def set_nested_value(
     d: dict[str, Any], key_path: str | list[str], value: Any
 ) -> dict[str, Any]:
     """设置嵌套字典中的值."""
@@ -316,10 +316,10 @@     return d
 
 
-def flatten_dict(d: dict[str, Any], separator: str = ".") -> dict[str, Any]:
+async def flatten_dict(d: dict[str, Any], separator: str = ".") -> dict[str, Any]:
     """扁平化嵌套字典."""
 
-    def _flatten(obj, parent_key="", sep="."):
+async def _flatten(obj, parent_key="", sep="."):
         items = []
         for k, v in obj.items():
             new_key = f"{parent_key}{sep}{k}" if parent_key else str(k)
@@ -332,7 +332,7 @@     return _flatten(d, sep=separator)
 
 
-def filter_dict(
+async def filter_dict(
     d: dict[str, Any], keys: list[str] = None, predicate=None
 ) -> dict[str, Any]:
     """过滤字典，只保留指定的键或满足条件的键值对."""
@@ -346,10 +346,10 @@         return {}
 
 
-def rename_keys(d: dict[str, Any], key_map: dict[str, str]) -> dict[str, Any]:
+async def rename_keys(d: dict[str, Any], key_map: dict[str, str]) -> dict[str, Any]:
     """重命名字典中的键."""
     result = {}
     for key, value in d.items():
-        new_key = key_map.get(key, key)
+        new_key = key_map.await get(key, key)
         result[new_key] = value
     return result
