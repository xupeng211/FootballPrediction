--- a/src/cache/unified_cache.py+++ b/src/cache/unified_cache.py@@ -19,7 +19,7 @@ class UnifiedCacheManager:
     """统一缓存管理器 - 多级缓存实现."""
 
-    def __init__(self, redis_client=None, local_cache_size: int = 1000):
+async def __init__(self, redis_client=None, local_cache_size: int = 1000):
         self.redis_client = redis_client
         self.local_cache = {}  # L1本地缓存
         self.local_cache_size = local_cache_size
@@ -33,7 +33,7 @@         }
         self.cache_config = self._get_cache_config()
 
-    def _get_cache_config(self) -> dict[str, int]:
+async def _get_cache_config(self) -> dict[str, int]:
         """获取统一的缓存配置."""
         return {
             # 预测相关缓存 - 高频访问
@@ -59,11 +59,11 @@             "default": 300,  # 5分钟
         }
 
-    def _generate_cache_key(self, key: str, cache_type: str) -> str:
+async def _generate_cache_key(self, key: str, cache_type: str) -> str:
         """生成缓存键."""
         return f"{cache_type}:{key}"
 
-    def _update_local_cache(self, key: str, value: Any, ttl: int | None = None):
+async def _update_local_cache(self, key: str, value: Any, ttl: int | None = None):
         """更新本地缓存（LRU实现 + TTL支持）."""
         if len(self.local_cache) >= self.local_cache_size:
             # 简单的LRU实现：删除最旧的条目
@@ -83,7 +83,7 @@             "expire_time": expire_time,
         }
 
-    def _serialize_data(self, data: Any) -> bytes:
+async def _serialize_data(self, data: Any) -> bytes:
         """序列化数据."""
         try:
             if isinstance(data, (str, int, float, bool)):
@@ -95,7 +95,7 @@             # 返回空字典的序列化结果，避免递归调用
             return b"{}"
 
-    def _deserialize_data(self, data: bytes) -> Any:
+async def _deserialize_data(self, data: bytes) -> Any:
         """反序列化数据."""
         try:
             # 尝试反序列化为字符串
@@ -120,7 +120,7 @@             cache_entry = self.local_cache[cache_key]
 
             # 检查TTL过期
-            if cache_entry.get("expire_time") is not None:
+            if cache_entry.await get("expire_time") is not None:
                 if time.time() > cache_entry["expire_time"]:
                     # 缓存已过期，删除并继续
                     del self.local_cache[cache_key]
@@ -142,7 +142,7 @@         if self.redis_client:
             try:
                 redis_key = f"cache:{cache_key}"
-                cached_data = await self.redis_client.get(redis_key)
+                cached_data = await self.redis_client.await get(redis_key)
 
                 if cached_data:
                     # 反序列化数据
@@ -176,7 +176,7 @@         try:
             # 获取TTL
             if ttl is None:
-                ttl = self.cache_config.get(cache_type, 300)
+                ttl = self.cache_config.await get(cache_type, 300)
 
             # 生成缓存键
             cache_key = self._generate_cache_key(key, cache_type)
@@ -321,7 +321,7 @@ _cache_manager: UnifiedCacheManager | None = None
 
 
-def get_cache_manager() -> UnifiedCacheManager:
+async def get_cache_manager() -> UnifiedCacheManager:
     """获取全局缓存管理器实例."""
     global _cache_manager
     if _cache_manager is None:
@@ -343,14 +343,14 @@ 
 
 # 缓存装饰器
-def cached(
+async def cached(
     cache_type: str = "default",
     ttl: int | None = None,
     key_func: Callable | None = None,
 ):
     """缓存装饰器."""
 
-    def decorator(func):
+async def decorator(func):
         @wraps(func)
         async def wrapper(*args, **kwargs):
             # 生成缓存键
@@ -365,7 +365,7 @@ 
             # 尝试从缓存获取
             cache_manager = get_cache_manager()
-            cached_result = await cache_manager.get(cache_key, cache_type)
+            cached_result = await cache_manager.await get(cache_key, cache_type)
 
             if cached_result is not None:
                 logger.debug(f"Cache hit for function {func.__name__}")
@@ -390,10 +390,10 @@ 
 
 # 性能监控装饰器
-def performance_monitor(threshold: float = 1.0):
+async def performance_monitor(threshold: float = 1.0):
     """性能监控装饰器."""
 
-    def decorator(func):
+async def decorator(func):
         @wraps(func)
         async def wrapper(*args, **kwargs):
             start_time = time.time()
