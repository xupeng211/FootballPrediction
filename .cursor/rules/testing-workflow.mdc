# 测试工作流规范

## 🧪 测试框架标准

- **单元测试**: 使用pytest作为主要测试框架
- **测试发现**: 测试文件以`test_`开头，测试函数以`test_`开头
- **断言**: 优先使用pytest的断言语法，避免unittest的assert方法
- **参数化测试**: 使用`@pytest.mark.parametrize`进行参数化测试
## 📊 覆盖率要求

- **最低覆盖率**: >= 80%
- **覆盖率工具**: 使用coverage.py生成覆盖率报告
- **排除文件**: 测试文件本身不计入覆盖率统计
- **关键路径**: 核心业务逻辑必须达到95%+覆盖率
## 📁 测试组织结构

- **单元测试**: `tests/unit/` - 测试单个函数/类
- **集成测试**: `tests/integration/` - 测试模块间交互
- **测试数据**: `tests/fixtures/` - 共享测试数据和夹具
- **配置**: `tests/conftest.py` - pytest配置和共享夹具
## ✅ 测试编写原则

- **独立性**: 每个测试独立运行，不依赖其他测试
- **可重复**: 测试结果稳定，多次运行结果一致
- **清晰命名**: 测试名称清楚描述测试目的
- **单一断言**: 每个测试专注验证一个行为
- **边界测试**: 包含正常、边界和异常情况的测试
## 🔧 测试执行

- **完整测试**: `make test` - 运行所有测试
- **单元测试**: `make test-unit` - 仅运行单元测试（推荐用于快速反馈）
- **快速测试**: `make test-quick` - 快速运行单元测试，带超时和失败限制
- **完整覆盖率**: `make coverage` - 生成完整覆盖率报告（可能较慢）
- **快速覆盖率**: `make coverage-fast` - 仅基于单元测试生成快速覆盖率报告（推荐）
- **🐳 CI模拟**: `./ci-verify.sh` - 在Docker环境中运行完整CI流程
- **CI集成**: 所有测试必须在CI环境通过
## 🐳 Docker环境测试

- **环境隔离**: 使用Docker确保测试环境一致性
- **服务依赖**: 自动启动PostgreSQL、Redis等依赖服务
- **真实环境**: 模拟GitHub Actions CI的完整运行环境
- **推送前验证**: 推送代码前必须通过`./ci-verify.sh`验证
## 🚫 测试禁忌

- 测试中不使用真实外部依赖
- 不在测试中修改全局状态
- 避免测试间的隐式依赖
- 不跳过失败的测试，要修复或删除
## ⚙️ 测试故障排查

- **`make coverage` 卡顿或缓慢?**
  - **首选方案**: 使用 `make coverage-fast` 或 `make test-quick`。
  - **原因**: 完整测试集规模过大，或包含需要外部服务（数据库、API）的集成测试。
- **测试因依赖服务失败?**
  - **检查服务**: 运行 `docker-compose ps` 确保 `postgres` 和 `redis` 等服务正在运行。
  - **启动服务**: 如果服务未运行，使用 `docker-compose up -d` 启动它们。
- **如何快速定位错误?**
  - **立即停止**: 使用 `pytest -x` 或 `--maxfail=N` 选项，在第一次或第N次失败后立即停止测试。
  - **运行单个文件**: `pytest tests/unit/test_some_module.py` - 隔离问题范围。
  - **详细输出**: 使用 `-v` (verbose) 和 `--tb=long` (long traceback) 获取更详细的错误信息。
